/* Generated code for Python module 'spotipy.client'
 * created by Nuitka version 0.6.8.4
 *
 * This code is in part copyright 2020 Kay Hayen.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include "nuitka/prelude.h"

#include "__helpers.h"

/* The "_module_spotipy$client" is a Python object pointer of module type.
 *
 * Note: For full compatibility with CPython, every module variable access
 * needs to go through it except for cases where the module cannot possibly
 * have changed in the mean time.
 */

PyObject *module_spotipy$client;
PyDictObject *moduledict_spotipy$client;

/* The declarations of module constants used, if any. */
static PyObject *const_str_plain_current_user_saved_albums_add;
extern PyObject *const_str_plain_headers;
extern PyObject *const_int_pos_20;
extern PyObject *const_str_plain___spec__;
static PyObject *const_str_digest_f0e105bf49756ecd3dea138844c26914;
static PyObject *const_str_plain_current_user_saved_tracks_delete;
extern PyObject *const_str_plain___del__;
static PyObject *const_str_plain_seek_track;
extern PyObject *const_str_plain___name__;
static PyObject *const_str_digest_e0d1219e8a48804ba7d3a250a3f19160;
static PyObject *const_str_digest_2ae13eed670f9290bb0c4f0c9875dd03;
static PyObject *const_str_digest_5787669024b1126d33f548eee9dfba27;
extern PyObject *const_str_plain_locale;
static PyObject *const_str_plain_user_follow_artists;
static PyObject *const_str_digest_01c654b122905b0b1b32480ee925f6b7;
static PyObject *const_str_digest_050195bad0e1f8243f136319af575115;
extern PyObject *const_str_plain_object;
static PyObject *const_str_digest_65c509e2a4b059c00782449ebd31f314;
extern PyObject *const_str_plain_POST;
static PyObject *const_str_digest_7d861053956b1ca5c8912878e2b1167a;
static PyObject *const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple;
extern PyObject *const_str_plain_bool;
static PyObject *const_str_digest_5f146a4556c0c7bd93727cb0e0330379;
extern PyObject *const_str_plain_albums;
extern PyObject *const_str_plain_PUT;
static PyObject *const_str_digest_b105cfca3528b94b86600f9e31c46f44;
static PyObject *const_tuple_int_pos_50_none_none_tuple;
static PyObject *const_str_plain_time_signature;
static PyObject *const_str_digest_7475ac184a2aa6f3857bca677c46863f;
static PyObject *const_str_plain_current_user;
static PyObject *const_str_plain__get_id;
static PyObject *const_str_digest_f072b674dcd223579507c51d0df33d44;
static PyObject *const_str_digest_9d2743a3aa01b480c9d69ac590d83c7b;
extern PyObject *const_str_plain__session;
static PyObject *const_str_plain_auth_manager;
static PyObject *const_tuple_str_digest_d7c7baadbbd36aaede69325123afee60_tuple;
extern PyObject *const_str_plain_mode;
static PyObject *const_str_digest_5b2f21fd676ae63c8602c70b44bb1a65;
static PyObject *const_str_digest_c8a70ac71cb2b20e5082c1200ba03922;
static PyObject *const_tuple_str_plain_self_str_plain_type_str_plain_id_tuple;
extern PyObject *const_str_plain_shows;
static PyObject *const_str_digest_9c2ae9a1450f607e30d3dd15ddb3202e;
extern PyObject *const_int_pos_5;
static PyObject *const_str_plain_featured_playlists;
static PyObject *const_tuple_str_digest_78c0f8fb326d72503211c7f83461a856_tuple;
static PyObject *const_str_digest_3d645e04bcf949fb901ec9ddbe408b65;
extern PyObject *const_str_plain_next;
extern PyObject *const_str_plain_public;
extern PyObject *const_tuple_none_none_none_tuple;
static PyObject *const_str_plain_next_track;
static PyObject *const_str_plain_artist_top_tracks;
static PyObject *const_str_plain_me;
static PyObject *const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple;
extern PyObject *const_str_plain_timeout;
static PyObject *const_str_plain__auth_manager;
static PyObject *const_str_digest_7ec0c6fc74111291c6117e275b9af9e9;
extern PyObject *const_str_plain___debug__;
static PyObject *const_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19;
static PyObject *const_list_str_plain_Spotify_str_plain_SpotifyException_list;
extern PyObject *const_tuple_str_plain_s_str_plain_self_tuple;
static PyObject *const_str_digest_72731c07d3278ac93ddcb33bedc1ae3a;
static PyObject *const_int_pos_504;
static PyObject *const_str_plain_time_range;
static PyObject *const_str_digest_66b5be10145db796e200edc04368805f;
extern PyObject *const_str_plain_str;
extern PyObject *const_tuple_none_none_none_none_tuple;
static PyObject *const_str_digest_f464ef528bb072445c99cf21a2c7ffc3;
static PyObject *const_str_digest_5fa7996b99deb750a6e6de8b5f21cbf4;
static PyObject *const_str_digest_d395ee4166bcad255ab6cb1b5c5f9e0b;
static PyObject *const_tuple_int_pos_20_int_0_tuple;
extern PyObject *const_int_neg_2;
static PyObject *const_str_digest_b50684ce91176f628bca5e02ea01b473;
static PyObject *const_str_plain_current_user_saved_shows_contains;
static PyObject *const_str_plain_recommendations;
static PyObject *const_str_digest_757ba791492fe0a6bb1e97e655265d19;
static PyObject *const_tuple_str_plain_self_str_plain_playlist_id_str_plain_plid_tuple;
extern PyObject *const_str_plain_path;
extern PyObject *const_str_plain_six;
static PyObject *const_str_digest_a140ca1afdc95e3bc95838a29ed7a7cb;
extern PyObject *const_str_plain_proxies;
static PyObject *const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple;
static PyObject *const_str_digest_1a8b6548667df279696cefce4cc3a3c1;
static PyObject *const_str_digest_07f46abe28b5e592c82e8deb6b13c902;
extern PyObject *const_str_digest_eb7db257536c3fbd0210e240db4c263e;
static PyObject *const_tuple_str_digest_6ba34161f4b1f940d6d5b6c37f996eea_tuple;
static PyObject *const_str_plain_loudness;
extern PyObject *const_str_plain_attribute;
static PyObject *const_str_plain_album_type;
extern PyObject *const_str_plain_name;
extern PyObject *const_str_digest_504b77692b694460b8c25198a52c83ba;
static PyObject *const_str_digest_c176c326cbe6514933ab2d3696cbe8eb;
static PyObject *const_str_digest_1220c3da1cafe83a535c664450909a43;
static PyObject *const_str_digest_3d01ef8d22d715e36161185be7af38c8;
extern PyObject *const_str_plain_exceptions;
static PyObject *const_tuple_52f5b989419359389333ac00979cfcda_tuple;
static PyObject *const_str_digest_6b8ace3f84c15e9c2104ecbe7cae2585;
static PyObject *const_tuple_none_int_pos_20_int_0_tuple;
static PyObject *const_str_plain_seed_artists;
static PyObject *const_str_digest_44d4f41b8805ad55f08f3244d0e3b445;
static PyObject *const_str_plain_playlist_tracks;
extern PyObject *const_str_plain_ids;
extern PyObject *const_str_digest_6d6a615162e89eb148ba9bf8dbfc06d3;
static PyObject *const_str_digest_7040c56b8e50bb41180c395c1e114602;
extern PyObject *const_str_plain_currently_playing;
static PyObject *const_str_plain_transfer_playback;
extern PyObject *const_int_pos_500;
static PyObject *const_str_digest_ad86a189ebf14691511cbd1323b36137;
extern PyObject *const_str_plain_False;
static PyObject *const_tuple_str_plain_self_str_plain_volume_percent_str_plain_device_id_tuple;
static PyObject *const_str_digest_069bc1a16ac92217a1a2071901af3a5a;
extern PyObject *const_str_plain_urllib3;
static PyObject *const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple;
static PyObject *const_str_digest_930d390398b95425d4ffd93f06305d01;
static PyObject *const_str_plain_collaborative;
static PyObject *const_str_digest_967a403b50fcd58b05904c6eb0b02666;
extern PyObject *const_str_plain_HTTPAdapter;
static PyObject *const_str_digest_614602b0b9c0300e03c45bbfd5d983fd;
extern PyObject *const_int_0;
static PyObject *const_str_plain__auth;
extern PyObject *const_str_plain_response;
static PyObject *const_str_digest_ad8a921df4ed7d5d7dfdb50bbff1b86a;
extern PyObject *const_str_plain_max_retries;
static PyObject *const_str_plain_seed_tracks;
extern PyObject *const_str_plain_oauth_manager;
static PyObject *const_str_plain_user_follow_users;
static PyObject *const_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9;
static PyObject *const_str_digest_2e3834ae29b14c0ccc2520a1888eb751;
static PyObject *const_str_digest_c694d59c7b8c840b24e0bfebb7bc0d33;
static PyObject *const_str_digest_798b1b3ff15941081d0a1905436770f1;
static PyObject *const_str_digest_5ad7dec315c7c67463047637575d5a5d;
extern PyObject *const_str_plain_retry;
static PyObject *const_str_digest_79519b954015c155dd29d1b46a9c1158;
static PyObject *const_str_digest_826172b5b9d28ef349545850487317c6;
static PyObject *const_str_digest_da6c98784a359364f8b00206a371e05a;
extern PyObject *const_tuple_str_plain_data_tuple;
static PyObject *const_str_digest_bc8036c231ae7fe76f8be4f140448aca;
extern PyObject *const_str_plain_type;
static PyObject *const_str_digest_c0f7f6ac2ded292348d4d33e1370f034;
static PyObject *const_str_digest_ad0cd2e91af697e20ab6ef3c064eeb24;
static PyObject *const_str_plain_artist_albums;
extern PyObject *const_str_plain___cached__;
extern PyObject *const_tuple_none_tuple;
static PyObject *const_str_plain_trackid;
static PyObject *const_str_digest_7bcf090e47dac41bef268864bc11052d;
static PyObject *const_str_digest_2dbaaa50149a05432865aa8002090146;
extern PyObject *const_str_plain_categories;
static PyObject *const_str_plain_min_;
static PyObject *const_tuple_str_digest_1220c3da1cafe83a535c664450909a43_tuple;
extern PyObject *const_str_plain_status_forcelist;
static PyObject *const_str_plain_user_playlist_change_details;
extern PyObject *const_str_plain_album;
static PyObject *const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple;
static PyObject *const_str_digest_5090487500dd71ff8ac64eb8e9322d70;
extern PyObject *const_int_pos_1;
static PyObject *const_str_digest_da2afbbf6793907933f5ecd26dc790fb;
static PyObject *const_str_plain_user_playlist_unfollow;
static PyObject *const_str_digest_692c4b25f3b4e214a8f7bcfe297e5fa9;
static PyObject *const_str_digest_839a8c1f15a51259ddc0a84ae73da1ee;
static PyObject *const_tuple_none_none_none_int_pos_20_none_tuple;
static PyObject *const_str_digest_180864d7a3022e5d03259a9166cebeb6;
static PyObject *const_str_plain_current_user_saved_shows;
static PyObject *const_str_digest_04a9401e879dd7f163ef999a3d8c8737;
extern PyObject *const_str_plain_state;
extern PyObject *const_str_plain_raise_for_status;
static PyObject *const_str_plain_current_user_recently_played;
static PyObject *const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_retry_str_plain_adapter_tuple;
extern PyObject *const_str_plain___prepare__;
static PyObject *const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple;
static PyObject *const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple;
static PyObject *const_str_digest_3c86c46e0167d5634370eed30742bc81;
extern PyObject *const_str_plain_url;
static PyObject *const_str_digest_719b93109d0bcd472ce92b9ca5f0b0a1;
static PyObject *const_str_digest_0d902bb3bd6b845836b00d2cb91900bb;
static PyObject *const_str_plain_current_user_saved_albums_delete;
static PyObject *const_str_digest_45149880b235040e3cc1276f459ecfa0;
static PyObject *const_tuple_str_plain_self_str_plain_albums_str_plain_tlist_tuple;
static PyObject *const_str_plain_range_start;
static PyObject *const_str_digest_4c12e1d5470fdec172110c6d89b8e1f3;
static PyObject *const_tuple_8cc3613134194fa97627fa253dd27832_tuple;
extern PyObject *const_str_plain_kwargs;
static PyObject *const_str_digest_c288d80fe09d5296eb3f023ab83cce4b;
extern PyObject *const_str_plain_http;
static PyObject *const_str_digest_fe0740ea6f5308d7e1b3f22eff165a3c;
extern PyObject *const_str_plain_format;
extern PyObject *const_str_plain_property;
extern PyObject *const_str_plain_startswith;
static PyObject *const_str_plain_uris;
extern PyObject *const_tuple_str_plain_http_tuple;
extern PyObject *const_str_plain_artist;
static PyObject *const_str_digest_8e9f262240f32f6727dab4cb6fe61480;
static PyObject *const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple;
static PyObject *const_tuple_str_digest_5ecac5642f7e480103d36531036f6532_tuple;
extern PyObject *const_str_plain_playlist;
static PyObject *const_str_digest_7d03408a0919929aa3016cec79244567;
static PyObject *const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple;
static PyObject *const_str_digest_aca4116a97710d2d33f68f95d3da0496;
static PyObject *const_str_plain_position;
static PyObject *const_str_digest_5ffaaf10b0544615d3c06b06a2628169;
static PyObject *const_tuple_str_plain_self_str_plain_auth_manager_tuple;
extern PyObject *const_str_plain_track_id;
static PyObject *const_str_digest_16e376831744b80c309abc0ab80ac512;
extern PyObject *const_str_plain_episodes;
extern PyObject *const_str_plain___file__;
extern PyObject *const_str_plain_setter;
static PyObject *const_str_digest_709f5323a138435d167ad8ffaa8e9e75;
static PyObject *const_tuple_int_pos_10_int_0_str_plain_track_none_tuple;
static PyObject *const_str_plain_playlist_cover_image;
static PyObject *const_str_digest_921be7d0436af20df73b917a524de443;
extern PyObject *const_str_plain_backoff_factor;
static PyObject *const_tuple_str_digest_da2afbbf6793907933f5ecd26dc790fb_tuple;
static PyObject *const_str_digest_5fffeb0d87cae7fe6ec23be661f2fd69;
static PyObject *const_str_plain_devices;
static PyObject *const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple;
extern PyObject *const_str_plain_US;
static PyObject *const_str_plain_tlist;
static PyObject *const_str_digest_fcd3a7c6c8bc32050163417ad987af39;
static PyObject *const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple;
static PyObject *const_str_digest_5b506f304dd8229333e7f1c8eeb8465b;
static PyObject *const_str_digest_848b05d9873b21f3410831cc56f1f4f0;
static PyObject *const_str_digest_ad1b0c6365dc3c25056e3014de5caa7d;
static PyObject *const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple;
extern PyObject *const_str_plain_GET;
static PyObject *const_str_plain_user_playlist_replace_tracks;
static PyObject *const_str_plain__delete;
static PyObject *const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41;
extern PyObject *const_str_plain_payload;
static PyObject *const_str_digest_c8dd3e40bf7394768822193fde87cb0c;
extern PyObject *const_str_plain_read;
static PyObject *const_str_digest_0e6e939b250c1a8ba18da5e85aa91db2;
extern PyObject *const_str_plain_connect;
static PyObject *const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple;
extern PyObject *const_str_plain_mount;
static PyObject *const_str_plain_current_user_saved_tracks;
extern PyObject *const_str_plain_lower;
static PyObject *const_tuple_str_plain_self_str_plain_user_str_plain_playlist_id_tuple;
extern PyObject *const_str_plain___orig_bases__;
extern PyObject *const_str_plain_close;
static PyObject *const_tuple_type_ValueError_type_KeyError_tuple;
static PyObject *const_str_plain_current_user_top_artists;
static PyObject *const_str_plain_instrumentalness;
static PyObject *const_str_digest_6e473efda59bed328f388eb28cfe5f4e;
static PyObject *const_str_digest_e96964f806da53ae36961b93a992dcdc;
static PyObject *const_tuple_str_plain_self_str_plain_device_id_tuple;
extern PyObject *const_str_plain___qualname__;
static PyObject *const_str_plain_valence;
static PyObject *const_str_digest_8db972dc902d3ee7ab11dac29db55dce;
static PyObject *const_str_digest_391f9f64704d3a7c47cf625eccafc7c0;
static PyObject *const_str_digest_8a674a9696fb048c8df9608719462515;
static PyObject *const_tuple_str_digest_8921f974345d80799e10e01caa480348_tuple;
static PyObject *const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple;
extern PyObject *const_str_plain_category_id;
static PyObject *const_tuple_str_plain_self_str_plain_market_tuple;
static PyObject *const_str_digest_a0a94d59c8ae6f19fa06528cbb359dd0;
static PyObject *const_str_plain__post;
extern PyObject *const_str_plain_timestamp;
static PyObject *const_str_digest_fc25e5cf6e0b48aa9d408ea60121013f;
static PyObject *const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple;
static PyObject *const_str_digest_3e78615d7227579781094c3c19b67451;
extern PyObject *const_str_plain_e;
extern PyObject *const_str_plain_message;
static PyObject *const_tuple_str_digest_c7224164f58b9974744c1a8795894870_tuple;
static PyObject *const_tuple_str_digest_35f78d818bb0285af39fbe7dbc808b01_tuple;
static PyObject *const_str_digest_5ea519055b607b7c1ff94d353137ea59;
extern PyObject *const_str_plain_context;
static PyObject *const_str_digest_9a029006dffa7d97b13721aeb2f78406;
static PyObject *const_str_digest_276fb866df82e86eb69e538ba8a0f638;
static PyObject *const_tuple_e154c21abc67708aeafc1bb2f6712757_tuple;
static PyObject *const_str_plain_user_playlist;
extern PyObject *const_str_plain_endpoint;
static PyObject *const_str_plain_liveness;
static PyObject *const_str_digest_223709650aeac13928929205a42f7ef5;
static PyObject *const_str_digest_9dc62dec5d04c5eb8a17c90c45485f89;
static PyObject *const_str_digest_a2dd6239923e72eabb819f2d368b274b;
extern PyObject *const_str_plain_retries;
static PyObject *const_tuple_92627fe8b33459c81955bb22182b44fc_tuple;
static PyObject *const_str_digest_bc9ddd864c719d358505256c02db1172;
static PyObject *const_str_digest_4b32f198f6de09ec1a43edf661b1c6e4;
extern PyObject *const_str_plain_show_id;
extern PyObject *const_str_plain_error;
static PyObject *const_str_digest_54e4b558d0d0cb3a69eebc739356fc4d;
static PyObject *const_str_digest_bd964b21b4b89004df13ec1af48482be;
static PyObject *const_str_digest_07e7f9ec031b8623c28ffb0538000243;
static PyObject *const_str_digest_19a37dfa2366a4f037bdcf195f572705;
static PyObject *const_str_plain_previous_track;
extern PyObject *const_str_plain_adapters;
static PyObject *const_str_digest_35f78d818bb0285af39fbe7dbc808b01;
static PyObject *const_str_digest_00b8f5f56af562fc9d94296f9e2775bc;
static PyObject *const_str_digest_57bce8905b9357b4bbbeafff3c64bd6a;
extern PyObject *const_str_plain___getitem__;
extern PyObject *const_str_plain___all__;
static PyObject *const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple;
static PyObject *const_str_digest_a9b9b45a6cb5971d9dde9506256891bd;
static PyObject *const_str_digest_589d9c66020624c5607b648b0706e668;
extern PyObject *const_str_plain_adapter;
static PyObject *const_str_digest_c837bee036dd14c3f093d35248327022;
static PyObject *const_str_digest_9a89b14ef9f9031019bb64544b058eba;
static PyObject *const_str_digest_8d3d887854fd55e6c944eb78e0e51acb;
static PyObject *const_str_plain_user_unfollow_artists;
static PyObject *const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple;
static PyObject *const_str_digest_ab8a4dee974a2c8d40c89f0c65db03e5;
extern PyObject *const_str_plain_dumps;
extern PyObject *const_str_plain__put;
extern PyObject *const_str_plain_play;
extern PyObject *const_str_plain_origin;
extern PyObject *const_str_plain_as_dict;
static PyObject *const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple;
static PyObject *const_str_plain_range_length;
extern PyObject *const_str_digest_75fd71b1edada749c2ef7ac810062295;
static PyObject *const_str_plain_category_playlists;
static PyObject *const_str_plain_market;
extern PyObject *const_str_plain_DELETE;
extern PyObject *const_str_plain_warning;
static PyObject *const_str_digest_7b4aeedd2d02cc6c175e110c0bda8734;
extern PyObject *const_str_plain_HTTPError;
static PyObject *const_str_digest_e0de147f27f355d47023f4e16df331f0;
static PyObject *const_str_digest_a98e8b7de683f2bff160c84779fead57;
static PyObject *const_str_digest_a5475341d16ac442212eca2ae5ce481c;
static PyObject *const_str_digest_86b299db541ebe8d4a030a5cb6ee08ca;
static PyObject *const_str_plain_default_retry_codes;
static PyObject *const_tuple_str_plain_self_str_plain_path_str_plain_device_id_tuple;
static PyObject *const_str_digest_a4092bb382602ef0ef001894fe04bc08;
static PyObject *const_str_plain_seed_genres;
static PyObject *const_str_digest_2053fcde6598069e7f533c9fe817316c;
static PyObject *const_str_digest_453d9a13f190051d0fb607026b4faf41;
static PyObject *const_str_plain_medium_term;
extern PyObject *const_str_digest_904eb8663ffdf47125032c6fe29e82f7;
extern PyObject *const_int_pos_503;
static PyObject *const_str_digest_af8a59ee158f81b27a541e29aa6b044e;
static PyObject *const_tuple_str_digest_f072b674dcd223579507c51d0df33d44_tuple;
static PyObject *const_str_digest_88f8614620997a7b7c5450e0473e6487;
static PyObject *const_tuple_str_digest_453d9a13f190051d0fb607026b4faf41_tuple;
static PyObject *const_str_plain_user_playlist_create;
static PyObject *const_str_digest_5d829d81793681107bd9dec71adcd753;
static PyObject *const_tuple_str_plain_self_str_plain_user_tuple;
static PyObject *const_str_digest_ea7d6548ef37d4b0632c164c6b7bea7c;
static PyObject *const_tuple_6367be7db62c8846531c10fec757318e_tuple;
static PyObject *const_str_digest_51b7dd8ac0216ff3eefb41eb4578f977;
static PyObject *const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple;
extern PyObject *const_str_chr_47;
static PyObject *const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple;
static PyObject *const_str_plain_image_b64;
static PyObject *const_str_digest_ca1b89362262296b98ca23da8d1a4747;
static PyObject *const_str_digest_96a41717fe5579fbdcb4a2aecebaef20;
extern PyObject *const_str_plain_uri;
static PyObject *const_str_digest_a3911b6aa4c898878e39b3942a493b69;
extern PyObject *const_str_plain_key;
static PyObject *const_str_digest_0607b1eabf6f75dc0f138641d9491d4d;
static PyObject *const_str_plain_acousticness;
static PyObject *const_int_pos_599;
static PyObject *const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple;
extern PyObject *const_str_plain___init__;
static PyObject *const_str_plain_popularity;
static PyObject *const_tuple_4886489b19733e5c89d8dc50502d893b_tuple;
static PyObject *const_str_digest_c6869dc60b510805e792b2878f36c2bb;
static PyObject *const_str_plain_playlist_owner_id;
static PyObject *const_str_plain_tr;
static PyObject *const_tuple_true_str_empty_tuple;
extern PyObject *const_str_plain_method;
static PyObject *const_str_digest_b3ea5a61b9afb9d8e21446f8f679560f;
extern PyObject *const_str_plain_duration_ms;
static PyObject *const_str_digest_1668a40f9d67d62504803c85c35ad2c7;
extern PyObject *const_str_plain_has_location;
static PyObject *const_str_plain_album_tracks;
static PyObject *const_str_digest_b53a9225f95dfacd53de288eb49849b4;
static PyObject *const_str_digest_dc236d8b13fa2bcf6bf5c872ea44aaa2;
static PyObject *const_tuple_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19_tuple;
extern PyObject *const_str_plain_Retry;
extern PyObject *const_str_empty;
static PyObject *const_str_plain__internal_call;
static PyObject *const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple;
extern PyObject *const_tuple_none_none_tuple;
static PyObject *const_str_digest_bac177f6409c0163a72de93274bfcfda;
extern PyObject *const_int_pos_100;
static PyObject *const_tuple_str_digest_437745d19c2123e6ab1318a417676e2d_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_limit_str_plain_after_tuple;
static PyObject *const_str_plain_audio_analysis;
extern PyObject *const_tuple_str_plain_self_str_plain_result_tuple;
extern PyObject *const_str_plain_result;
static PyObject *const_str_digest_eca0f059baf41471e999a751e560bd50;
extern PyObject *const_str_plain_request;
extern PyObject *const_str_plain_getLogger;
static PyObject *const_tuple_str_digest_1e8042c594f592682be42de584406334_tuple;
static PyObject *const_str_digest_06ce06e2e0ca5ed295843a89172ce4cf;
static PyObject *const_str_digest_c4e4d6ee79b254fd0456272a4368eceb;
static PyObject *const_str_digest_aac40a8551d6102f0d2c30ca4a15eac4;
static PyObject *const_str_plain_current_user_playlists;
static PyObject *const_str_digest_6c9e8a9e157453a28103d4c0f15c86e1;
extern PyObject *const_str_digest_63ccfd6c601861c5b2bf4382d0053b4d;
static PyObject *const_str_plain_energy;
static PyObject *const_str_digest_72b0d4f925b9f004a6696b8da7844b76;
static PyObject *const_str_digest_cf0e60aeef8b8fd92f93cc4479500be7;
static PyObject *const_str_digest_7c5b74be3ada649b49557a7869eb03b9;
static PyObject *const_str_plain_context_uri;
extern PyObject *const_str_plain_SpotifyException;
static PyObject *const_str_plain_volume_percent;
extern PyObject *const_str_plain_prefix;
extern PyObject *const_str_plain_json;
static PyObject *const_str_digest_9ea71127940e425419165c8e7548f59f;
static PyObject *const_str_digest_bb9045d588645f6e09401dc640cbacf2;
extern PyObject *const_int_neg_1;
static PyObject *const_str_digest_ab6127a399e734894254eb9c80531bea;
static PyObject *const_str_digest_dfc401f7f4274ac522480928076aa127;
extern PyObject *const_str_plain_id;
static PyObject *const_str_digest_24c4dd15df6ed2447b60cca67615bd7b;
static PyObject *const_tuple_str_plain_self_str_plain_album_id_str_plain_trid_tuple;
extern PyObject *const_str_plain_q;
static PyObject *const_str_digest_3a6be6041bbd3413cb3fb03eb5d525c3;
static PyObject *const_str_digest_43e37e636612ec263698913cfae18f8d;
static PyObject *const_str_digest_fce8e7d40ad236922eb432562db251e4;
static PyObject *const_str_plain_current_user_saved_tracks_contains;
static PyObject *const_tuple_str_plain_search_tuple;
extern PyObject *const_tuple_true_tuple;
static PyObject *const_str_digest_22f5858d3d743416f99b1d8706361486;
static PyObject *const_str_digest_56394365e919e0b53cf3c29c5a7817fb;
extern PyObject *const_str_plain___doc__;
static PyObject *const_str_plain_current_user_followed_artists;
static PyObject *const_str_digest_764f11a6df082195a71078a86865117a;
extern PyObject *const_str_digest_7c06a402579f6f9d9db7f3e04da983fc;
extern PyObject *const_str_plain__get;
static PyObject *const_str_digest_fbe05da63d91a0174ef8bf2a7a18534f;
static PyObject *const_str_digest_13b574c3ba7ad6187b88b6911cadbc9a;
extern PyObject *const_str_plain_data;
static PyObject *const_str_digest_9edb48669a614c3726ceb81da3fc4901;
static PyObject *const_tuple_str_digest_182a5343dd2556daa4702ebff5e2a31b_tuple;
static PyObject *const_str_plain_new_releases;
extern PyObject *const_str_plain_s;
static PyObject *const_str_digest_1e8919abc0a68df77aed3737901ad587;
extern PyObject *const_str_plain_warnings;
static PyObject *const_str_digest_14d6f4175da676c87e845226510aa004;
static PyObject *const_str_digest_1e8042c594f592682be42de584406334;
static PyObject *const_tuple_str_plain_US_tuple;
static PyObject *const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple;
static PyObject *const_str_digest_93fcca36131047b95019094338820d2f;
static PyObject *const_str_digest_df5e9278827652f7a7b9ebd1b7a18fde;
static PyObject *const_str_digest_b3ecf44f109d34b3e52af7f2f5b62594;
static PyObject *const_str_digest_304ab7a50291c9fae677bb6cb2a9f8c4;
static PyObject *const_str_plain_user_playlist_reorder_tracks;
extern PyObject *const_tuple_str_plain_self_str_plain_ids_tuple;
static PyObject *const_str_digest_6bda413d1a4d6e15ff4de52373c1a00e;
extern PyObject *const_str_plain_string_types;
extern PyObject *const_str_plain_content_type;
static PyObject *const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple;
extern PyObject *const_tuple_str_plain_self_tuple;
static PyObject *const_str_plain_target_;
static PyObject *const_str_digest_704bea8878314747d972920e0987e163;
extern PyObject *const_str_plain_after;
static PyObject *const_str_digest_41fba648edc091dc1004ac663d8aecf4;
static PyObject *const_str_plain_status_retries;
static PyObject *const_str_plain_recommendation_genre_seeds;
static PyObject *const_str_plain__get_uri;
extern PyObject *const_str_plain_playlist_id;
static PyObject *const_str_digest_147b8574c689a39dd3e1208a7a6f7a89;
static PyObject *const_str_digest_6ba34161f4b1f940d6d5b6c37f996eea;
extern PyObject *const_tuple_empty;
static PyObject *const_str_digest_d50c5bd1c8d54069535879650ef443a5;
extern PyObject *const_str_plain_append;
static PyObject *const_str_digest_066f6638a3c907c0e5cd1174d5ace6b8;
extern PyObject *const_str_plain_episode_id;
extern PyObject *const_str_plain_device_id;
static PyObject *const_str_digest_4b2c8ed8fa5094614f7604f6c34e95fa;
extern PyObject *const_int_pos_10;
static PyObject *const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple;
static PyObject *const_str_plain_current_user_saved_albums;
static PyObject *const_str_digest_78c0f8fb326d72503211c7f83461a856;
static PyObject *const_str_digest_188a1166bacfa060b47e8694a15a3090;
extern PyObject *const_str_plain_split;
extern PyObject *const_str_plain_token;
static PyObject *const_str_plain_insert_before;
extern PyObject *const_str_plain_album_id;
static PyObject *const_tuple_str_plain_min__str_plain_max__str_plain_target__tuple;
static PyObject *const_str_digest_461572c4c90bffa6a73b81c05396465c;
extern PyObject *const_str_plain_list;
extern PyObject *const_tuple_str_chr_63_tuple;
static PyObject *const_str_digest_01799024cb32c197cee13a1245d6fb67;
static PyObject *const_str_digest_131c4d8f12787eb624dbe9d8626d17ce;
static PyObject *const_str_plain_audio_features;
extern PyObject *const_str_plain_Spotify;
static PyObject *const_str_plain_previous;
static PyObject *const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple;
extern PyObject *const_str_plain_off;
static PyObject *const_str_digest_5a0f1de4f1f7388aa7e656e8bcb182b9;
extern PyObject *const_str_plain_msg;
static PyObject *const_str_digest_8921f974345d80799e10e01caa480348;
extern PyObject *const_str_plain_Authorization;
extern PyObject *const_str_plain_episode;
static PyObject *const_str_digest_52a058966bc59abea536c1108c5ed4b1;
static PyObject *const_str_digest_b44ed5b039ecf981522aec07f6a4ce6f;
static PyObject *const_tuple_682b992cd17b43443c5763aa401a1636_tuple;
static PyObject *const_tuple_str_plain_recommendations_tuple;
static PyObject *const_tuple_str_digest_5787669024b1126d33f548eee9dfba27_tuple;
static PyObject *const_str_plain__build_session;
static PyObject *const_str_digest_f0e0d92a883a0d37afc5c36db66989d0;
static PyObject *const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple;
static PyObject *const_str_digest_bd0f2b232e10978ffc7d0f9d3001ad87;
static PyObject *const_str_plain_max_;
static PyObject *const_str_digest_7a15e76af9258d39e881ccef235c8981;
static PyObject *const_str_digest_2a2c2ba43f4eedfd2d13747c6caa8b25;
static PyObject *const_str_digest_ec2e7cf9c1786efb908b0c0f264590c3;
static PyObject *const_str_digest_2973be41c7df6ecef1d423c6cbae5728;
static PyObject *const_str_digest_f73af7c71e1dcd5503718d51f23de060;
static PyObject *const_str_plain_device_ids;
static PyObject *const_str_plain_client_credentials_manager;
static PyObject *const_str_digest_f3bd18c4e4dfe3b238c61f74d4197ffd;
extern PyObject *const_str_plain___class__;
static PyObject *const_str_digest_5be1b56c4c0b8911c4aba922d20a0188;
extern PyObject *const_str_plain_tracks;
static PyObject *const_str_plain_current_user_playing_track;
static PyObject *const_tuple_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9_tuple;
static PyObject *const_str_digest_1edf7ef291a6d2f13ad21e7a038ba6db;
static PyObject *const_str_digest_0a31963364057b0f70b283146476706a;
static PyObject *const_str_digest_a3c47fe9db46a4cbfc5719fa2ef262a7;
extern PyObject *const_str_plain___module__;
extern PyObject *const_str_plain_api;
static PyObject *const_str_plain_current_user_saved_albums_contains;
static PyObject *const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple;
extern PyObject *const_str_plain_debug;
extern PyObject *const_str_plain_user;
static PyObject *const_str_digest_d8013f6ad51769ccfee3dd58bb3f0652;
extern PyObject *const_str_plain_requests;
static PyObject *const_str_digest_4c586604e0e933a3b0da727a9d982d51;
static PyObject *const_str_plain_speechiness;
extern PyObject *const_str_plain_update;
static PyObject *const_str_digest_00fb433b6c8f8c4e9d59bd70cd5fee15;
extern PyObject *const_str_digest_9b53e2759f78e025448df529ac650919;
static PyObject *const_tuple_2c14864855545e1854bee3fef626583e_tuple;
static PyObject *const_str_digest_182a5343dd2556daa4702ebff5e2a31b;
extern PyObject *const_tuple_str_chr_47_tuple;
extern PyObject *const_str_plain_logger;
static PyObject *const_str_digest_8778ffeefebf38a1b121e70d438be59e;
static PyObject *const_tuple_str_plain_self_str_plain_token_tuple;
static PyObject *const_str_digest_1e83f61e759b7fbea9a801cec29b5024;
extern PyObject *const_str_plain_volume;
static PyObject *const_str_digest_143a93a582706d71ac985cd217d846c8;
static PyObject *const_tuple_str_plain_t_str_plain_self_tuple;
static PyObject *const_tuple_str_digest_12c7255d70fc5dcdbef99c54e18933c6_tuple;
extern PyObject *const_str_plain_get;
static PyObject *const_str_plain__append_device_id;
extern PyObject *const_str_plain_track;
static PyObject *const_str_digest_787903cd874d847847a2eb2ef416f6c3;
static PyObject *const_str_digest_329cc980f9b9d0864824ea93bbfb8a73;
extern PyObject *const_str_plain_artist_id;
extern PyObject *const_str_plain_logging;
static PyObject *const_tuple_149384ac75bf30697541a03a2af20cf7_tuple;
static PyObject *const_str_digest_32a4ae71788e298e6b9dd987b7a52688;
static PyObject *const_str_plain_pause_playback;
static PyObject *const_str_digest_f79216834977c09ad46a369d9c09854c;
static PyObject *const_tuple_str_plain_self_str_plain_artists_str_plain_tlist_tuple;
static PyObject *const_str_digest_51757cba85587a91188620a63866ff3b;
extern PyObject *const_str_plain_warn;
static PyObject *const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple;
static PyObject *const_str_digest_d8a87e891106f59734dd2f86091ec954;
extern PyObject *const_str_plain_metaclass;
static PyObject *const_str_plain_user_playlist_is_following;
extern PyObject *const_str_plain_shuffle;
extern PyObject *const_tuple_str_plain___class___tuple;
extern PyObject *const_str_plain_results;
extern PyObject *const_str_angle_metaclass;
static PyObject *const_tuple_none_none_none_int_pos_20_int_0_tuple;
extern PyObject *const_str_plain_offset;
static PyObject *const_tuple_str_digest_7475ac184a2aa6f3857bca677c46863f_tuple;
static PyObject *const_tuple_none_none_int_pos_20_int_0_tuple;
extern PyObject *const_str_plain_total;
extern PyObject *const_str_plain_args;
static PyObject *const_str_digest_1a4d1829bf809cce5d46da7256560962;
static PyObject *const_str_digest_1efba7d43fe6a9ddb536f5135ef1050e;
static PyObject *const_tuple_fe00d07b498f378d886063a767afe437_tuple;
extern PyObject *const_str_plain_a;
static PyObject *const_str_plain_user_playlist_follow_playlist;
static PyObject *const_str_digest_7af1b86e99338fd4edc6b03cce965252;
extern PyObject *const_str_plain_requests_timeout;
static PyObject *const_str_plain_playlist_upload_cover_image;
extern PyObject *const_str_plain_param;
static PyObject *const_str_digest_32e139cf9c005363a7161616e92f1a08;
static PyObject *const_str_plain_set_auth;
static PyObject *const_str_digest_c756b049a62b03e8fe36ada60a54a03e;
static PyObject *const_str_plain_alist;
static PyObject *const_str_digest_beb9b463b31c02c01059bbfe0eabf6bb;
extern PyObject *const_tuple_str_plain_SpotifyException_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_position_ms_str_plain_device_id_tuple;
extern PyObject *const_tuple_str_chr_58_tuple;
static PyObject *const_tuple_none_none_none_int_pos_100_int_0_none_tuple;
extern PyObject *const_str_plain_join;
extern PyObject *const_str_chr_63;
extern PyObject *const_int_pos_429;
extern PyObject *const_str_plain_description;
static PyObject *const_tuple_int_pos_50_int_0_none_tuple;
static PyObject *const_str_digest_43404de583c5367e36ea771b97f2561a;
static PyObject *const_str_plain_current_user_saved_tracks_add;
extern PyObject *const_str_digest_1781891970018ef9597f363946d7327b;
static PyObject *const_str_plain_current_user_saved_shows_delete;
static PyObject *const_str_plain_user_ids;
static PyObject *const_str_plain_artist_related_artists;
extern PyObject *const_tuple_str_plain_track_tuple;
static PyObject *const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple;
static PyObject *const_str_digest_1a1f42c161bd7332ead3228a329cb87a;
static PyObject *const_str_digest_b21dca84fcf4e8562e492b36f54e621b;
extern PyObject *const_str_chr_44;
extern PyObject *const_str_plain_status;
static PyObject *const_str_digest_b89a24c0a3cc4571b4b02536ba3d2fd4;
extern PyObject *const_str_plain_t;
static PyObject *const_str_digest_8162ab5fc511821afe1608ebaabcc365;
static PyObject *const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple;
static PyObject *const_tuple_int_pos_50_int_0_tuple;
static PyObject *const_str_plain_force_play;
static PyObject *const_str_plain_additional_types;
static PyObject *const_str_digest_231f278518e15360f0e83a2b4f233662;
extern PyObject *const_str_plain_int;
extern PyObject *const_str_plain_Session;
static PyObject *const_str_digest_e58eec2a5ea585c2c4db40f39721d451;
static PyObject *const_str_digest_cd1fee3b799518143086c98a6701773c;
extern PyObject *const_str_plain_DeprecationWarning;
static PyObject *const_str_plain_position_ms;
extern PyObject *const_str_plain_limit;
static PyObject *const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple;
static PyObject *const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple;
static PyObject *const_str_plain_start_playback;
static PyObject *const_str_plain_user_unfollow_users;
static PyObject *const_str_digest_b2eef765f8c5abb067a011988de44235;
static PyObject *const_str_digest_c7224164f58b9974744c1a8795894870;
static PyObject *const_str_digest_c2cb8cbc6b1b5e281950e97a3fe1622b;
static PyObject *const_str_digest_c9db8737dfcddf87703a20dae86d6cc6;
static PyObject *const_str_plain_current_user_saved_shows_add;
static PyObject *const_str_digest_4cd2fe7e56ff8b75b38406398ccf5849;
extern PyObject *const_str_plain_repeat;
static PyObject *const_str_digest_3fad55d9b16e5e6483c31abe09170773;
extern PyObject *const_str_plain_status_code;
static PyObject *const_str_plain_current_user_top_tracks;
static PyObject *const_str_digest_ba8367de31b2273f9e2a709972d2a97c;
extern PyObject *const_tuple_int_pos_1_none_tuple;
static PyObject *const_str_plain_itype;
static PyObject *const_str_digest_fce43981ff247be47ab0a78bb306a831;
static PyObject *const_str_digest_7a2c470ea5f10c23533f984d841d174e;
static PyObject *const_str_plain_positions;
static PyObject *const_str_digest_a9e497a69e6698a5ac0200bc3be01588;
extern PyObject *const_tuple_str_plain_e_str_plain_self_tuple;
static PyObject *const_tuple_int_pos_20_none_tuple;
static PyObject *const_float_0_3;
extern PyObject *const_str_plain_get_access_token;
static PyObject *const_str_plain_plid;
static PyObject *const_str_digest_85b964c01ed70f92a87af7b95815e594;
static PyObject *const_str_plain_tempo;
static PyObject *const_str_plain_snapshot_id;
static PyObject *const_tuple_str_digest_5090487500dd71ff8ac64eb8e9322d70_tuple;
extern PyObject *const_str_plain_show;
static PyObject *const_str_plain_user_playlist_tracks;
static PyObject *const_str_digest_ffa0992fc3e937316133dc1511c1babb;
static PyObject *const_str_digest_5ecac5642f7e480103d36531036f6532;
static PyObject *const_tuple_none_none_tuple_str_plain_track_tuple_tuple;
static PyObject *const_str_digest_ddf63d8e67c74433202126d85f63720d;
extern PyObject *const_tuple_none_none_none_none_none_tuple;
static PyObject *const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple;
static PyObject *const_tuple_str_plain_a_str_plain_self_tuple;
static PyObject *const_str_digest_08fa1fbd4fd8fbd433259816d4c0fd80;
static PyObject *const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple;
static PyObject *const_str_digest_f416654f39bbd99bbde9721618eb36fd;
static PyObject *const_tuple_str_digest_5b506f304dd8229333e7f1c8eeb8465b_tuple;
static PyObject *const_str_plain_trid;
extern PyObject *const_str_plain_artists;
static PyObject *const_str_digest_14aa8f39ae92cdfa19768e4e257f6ad7;
static PyObject *const_tuple_str_digest_5d829d81793681107bd9dec71adcd753_tuple;
static PyObject *const_str_digest_eef54eb775249e83f1addd1b51ffa30a;
extern PyObject *const_str_plain_search;
extern PyObject *const_str_chr_58;
static PyObject *const_str_digest_22b1054355e50899c6bf88a5e7c14b90;
static PyObject *const_str_plain_add_to_queue;
extern PyObject *const_str_plain_tid;
extern PyObject *const_str_plain_requests_session;
extern PyObject *const_str_angle_listcomp;
static PyObject *const_str_digest_bb4c36c3f1ee6d15e5217090585577d5;
static PyObject *const_str_digest_f309ed4485e7bd297d91d86c0feee8f3;
static PyObject *const_str_digest_12c7255d70fc5dcdbef99c54e18933c6;
static PyObject *const_str_plain_current_playback;
static PyObject *const_str_digest_72c39d9a88a6b461c157aee4ce2cc943;
static PyObject *const_str_digest_1e1ba398d96e94b69ce683dfb2e1f429;
extern PyObject *const_int_pos_50;
static PyObject *const_str_digest_410a71fafeb675394fe1eff0fefe1fca;
static PyObject *const_str_digest_2eaee9335e32606751b873994e96fd80;
static PyObject *const_str_digest_e20746e27b808631c68a7de73dcbf7e4;
static PyObject *const_str_digest_7b3c05a139c5aea99aa8643803da85a9;
static PyObject *const_str_plain_slist;
static PyObject *const_str_digest_5a23bff0529b8d304971c75ac5c0c642;
static PyObject *const_str_digest_19eeb686661d8ef9861c731891632dbe;
static PyObject *const_str_digest_66a2e17c5d838acae507a0388b923c91;
static PyObject *const_tuple_str_digest_6c9e8a9e157453a28103d4c0f15c86e1_tuple;
static PyObject *const_str_digest_13224bc18feb1ba01c2cde37d88d6b18;
static PyObject *const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple;
extern PyObject *const_tuple_type_object_tuple;
static PyObject *const_str_digest_424fcad737c334bc0999dd054930c345;
static PyObject *const_tuple_069764dd8c1ec01972656675304328c5_tuple;
static PyObject *const_str_digest_bf9d8f637e1f805885861297c4fd2e7b;
extern PyObject *const_str_plain_params;
static PyObject *const_str_plain_before;
static PyObject *const_str_digest_2426d2d37163dd769cdef1fa7ba0a966;
static PyObject *const_str_digest_9254db74895e65fc859713643b2ed8ae;
static PyObject *const_list_str_plain_track_str_plain_context_str_plain_off_list;
static PyObject *const_tuple_str_digest_c8dd3e40bf7394768822193fde87cb0c_tuple;
static PyObject *const_str_digest_f82a2299550c18805d7c9a6deebb5f8b;
static PyObject *const_str_digest_d7c7baadbbd36aaede69325123afee60;
extern PyObject *const_str_plain_auth;
extern PyObject *const_int_pos_3;
static PyObject *const_int_pos_502;
static PyObject *const_str_digest_5e2d0d309d6799d2b2500c57eb38e379;
static PyObject *const_str_digest_437745d19c2123e6ab1318a417676e2d;
extern PyObject *const_dict_79c040486cc871a74ef4d9ecc0ccc16f;
extern PyObject *const_str_plain_fields;
extern PyObject *const_str_plain_self;
extern PyObject *const_str_plain_RetryError;
extern PyObject *const_str_plain_country;
static PyObject *const_str_digest_7bdf7f5f2cee1538c772082d0885025f;
static PyObject *const_str_digest_19ca16d6b65b3385e7e95a982e32ddeb;
static PyObject *const_tuple_str_digest_dfc401f7f4274ac522480928076aa127_tuple;
static PyObject *const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple;
static PyObject *const_str_digest_fcff0159a761cd6996e868984e5eb286;
static PyObject *const_str_digest_98b1ec6a4ee97b8abcc611c4f94337a4;
static PyObject *const_tuple_11a6319e07aa050aed810c998ea37058_tuple;
static PyObject *const_str_plain_user_playlist_add_tracks;
extern PyObject *const_str_plain_user_playlists;
static PyObject *const_str_digest_879242dc41bf721b411af8e2247307b4;
static PyObject *const_str_plain_ftracks;
static PyObject *const_str_digest_d7ab0864ba2818d4a280416965102e06;
static PyObject *const_str_plain__auth_headers;
static PyObject *const_str_plain_show_episodes;
static PyObject *const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple;
static PyObject *const_str_digest_d8d7e79085a29dc1ccf4d3c139ad694e;
static PyObject *const_tuple_str_plain_tid_str_plain_self_tuple;
static PyObject *const_str_digest_875010cc3f8d07790f010cc5f17820c8;
static PyObject *const_str_plain_danceability;
static PyObject *const_str_digest_e778dc668e45ddcafe4d67d943148e2d;
static PyObject *const_str_digest_2774574c30cb390537d18eadfb6194c4;
static PyObject *const_tuple_str_plain_self_str_plain_auth_tuple;
static PyObject *module_filename_obj;

/* Indicator if this modules private constants were created yet. */
static bool constants_created = false;

/* Function to create module private constants. */
static void createModuleConstants(void) {
    const_str_plain_current_user_saved_albums_add = UNSTREAM_STRING_ASCII(&constant_bin[ 598851 ], 29, 1);
    const_str_digest_f0e105bf49756ecd3dea138844c26914 = UNSTREAM_STRING_ASCII(&constant_bin[ 598880 ], 13, 0);
    const_str_plain_current_user_saved_tracks_delete = UNSTREAM_STRING_ASCII(&constant_bin[ 598893 ], 32, 1);
    const_str_plain_seek_track = UNSTREAM_STRING_ASCII(&constant_bin[ 598925 ], 10, 1);
    const_str_digest_e0d1219e8a48804ba7d3a250a3f19160 = UNSTREAM_STRING_ASCII(&constant_bin[ 598935 ], 15, 0);
    const_str_digest_2ae13eed670f9290bb0c4f0c9875dd03 = UNSTREAM_STRING_ASCII(&constant_bin[ 598950 ], 22, 0);
    const_str_digest_5787669024b1126d33f548eee9dfba27 = UNSTREAM_STRING_ASCII(&constant_bin[ 598972 ], 19, 0);
    const_str_plain_user_follow_artists = UNSTREAM_STRING_ASCII(&constant_bin[ 598991 ], 19, 1);
    const_str_digest_01c654b122905b0b1b32480ee925f6b7 = UNSTREAM_STRING_ASCII(&constant_bin[ 599010 ], 271, 0);
    const_str_digest_050195bad0e1f8243f136319af575115 = UNSTREAM_STRING_ASCII(&constant_bin[ 599281 ], 34, 0);
    const_str_digest_65c509e2a4b059c00782449ebd31f314 = UNSTREAM_STRING_ASCII(&constant_bin[ 599315 ], 15, 0);
    const_str_digest_7d861053956b1ca5c8912878e2b1167a = UNSTREAM_STRING_ASCII(&constant_bin[ 599330 ], 11, 0);
    const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple, 1, const_str_plain_albums); Py_INCREF(const_str_plain_albums);
    const_str_plain_alist = UNSTREAM_STRING_ASCII(&constant_bin[ 599341 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple, 2, const_str_plain_alist); Py_INCREF(const_str_plain_alist);
    const_str_digest_5f146a4556c0c7bd93727cb0e0330379 = UNSTREAM_STRING_ASCII(&constant_bin[ 599346 ], 23, 0);
    const_str_digest_b105cfca3528b94b86600f9e31c46f44 = UNSTREAM_STRING_ASCII(&constant_bin[ 599369 ], 8, 0);
    const_tuple_int_pos_50_none_none_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_none_none_tuple, 0, const_int_pos_50); Py_INCREF(const_int_pos_50);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_none_none_tuple, 1, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_none_none_tuple, 2, Py_None); Py_INCREF(Py_None);
    const_str_plain_time_signature = UNSTREAM_STRING_ASCII(&constant_bin[ 599377 ], 14, 1);
    const_str_digest_7475ac184a2aa6f3857bca677c46863f = UNSTREAM_STRING_ASCII(&constant_bin[ 599391 ], 44, 0);
    const_str_plain_current_user = UNSTREAM_STRING_ASCII(&constant_bin[ 598851 ], 12, 1);
    const_str_plain__get_id = UNSTREAM_STRING_ASCII(&constant_bin[ 573668 ], 7, 1);
    const_str_digest_f072b674dcd223579507c51d0df33d44 = UNSTREAM_STRING_ASCII(&constant_bin[ 599435 ], 14, 0);
    const_str_digest_9d2743a3aa01b480c9d69ac590d83c7b = UNSTREAM_STRING_ASCII(&constant_bin[ 599449 ], 14, 0);
    const_str_plain_auth_manager = UNSTREAM_STRING_ASCII(&constant_bin[ 16939 ], 12, 1);
    const_tuple_str_digest_d7c7baadbbd36aaede69325123afee60_tuple = PyTuple_New(1);
    const_str_digest_d7c7baadbbd36aaede69325123afee60 = UNSTREAM_STRING_ASCII(&constant_bin[ 599463 ], 37, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_d7c7baadbbd36aaede69325123afee60_tuple, 0, const_str_digest_d7c7baadbbd36aaede69325123afee60); Py_INCREF(const_str_digest_d7c7baadbbd36aaede69325123afee60);
    const_str_digest_5b2f21fd676ae63c8602c70b44bb1a65 = UNSTREAM_STRING_ASCII(&constant_bin[ 599500 ], 27, 0);
    const_str_digest_c8a70ac71cb2b20e5082c1200ba03922 = UNSTREAM_STRING_ASCII(&constant_bin[ 599527 ], 905, 0);
    const_tuple_str_plain_self_str_plain_type_str_plain_id_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_str_plain_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_str_plain_id_tuple, 1, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_type_str_plain_id_tuple, 2, const_str_plain_id); Py_INCREF(const_str_plain_id);
    const_str_digest_9c2ae9a1450f607e30d3dd15ddb3202e = UNSTREAM_STRING_ASCII(&constant_bin[ 600432 ], 36, 0);
    const_str_plain_featured_playlists = UNSTREAM_STRING_ASCII(&constant_bin[ 600468 ], 18, 1);
    const_tuple_str_digest_78c0f8fb326d72503211c7f83461a856_tuple = PyTuple_New(1);
    const_str_digest_78c0f8fb326d72503211c7f83461a856 = UNSTREAM_STRING_ASCII(&constant_bin[ 600486 ], 9, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_78c0f8fb326d72503211c7f83461a856_tuple, 0, const_str_digest_78c0f8fb326d72503211c7f83461a856); Py_INCREF(const_str_digest_78c0f8fb326d72503211c7f83461a856);
    const_str_digest_3d645e04bcf949fb901ec9ddbe408b65 = UNSTREAM_STRING_ASCII(&constant_bin[ 600495 ], 267, 0);
    const_str_plain_next_track = UNSTREAM_STRING_ASCII(&constant_bin[ 600762 ], 10, 1);
    const_str_plain_artist_top_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 600772 ], 17, 1);
    const_str_plain_me = UNSTREAM_STRING_ASCII(&constant_bin[ 2 ], 2, 1);
    const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 1, const_str_plain_locale); Py_INCREF(const_str_plain_locale);
    PyTuple_SET_ITEM(const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 2, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 3, const_str_plain_timestamp); Py_INCREF(const_str_plain_timestamp);
    PyTuple_SET_ITEM(const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 4, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 5, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_str_plain__auth_manager = UNSTREAM_STRING_ASCII(&constant_bin[ 600789 ], 13, 1);
    const_str_digest_7ec0c6fc74111291c6117e275b9af9e9 = UNSTREAM_STRING_ASCII(&constant_bin[ 600802 ], 10, 0);
    const_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19 = UNSTREAM_STRING_ASCII(&constant_bin[ 600812 ], 30, 0);
    const_list_str_plain_Spotify_str_plain_SpotifyException_list = PyList_New(2);
    PyList_SET_ITEM(const_list_str_plain_Spotify_str_plain_SpotifyException_list, 0, const_str_plain_Spotify); Py_INCREF(const_str_plain_Spotify);
    PyList_SET_ITEM(const_list_str_plain_Spotify_str_plain_SpotifyException_list, 1, const_str_plain_SpotifyException); Py_INCREF(const_str_plain_SpotifyException);
    const_str_digest_72731c07d3278ac93ddcb33bedc1ae3a = UNSTREAM_STRING_ASCII(&constant_bin[ 600842 ], 14, 0);
    const_int_pos_504 = PyLong_FromUnsignedLong(504ul);
    const_str_plain_time_range = UNSTREAM_STRING_ASCII(&constant_bin[ 600856 ], 10, 1);
    const_str_digest_66b5be10145db796e200edc04368805f = UNSTREAM_STRING_ASCII(&constant_bin[ 600866 ], 105, 0);
    const_str_digest_f464ef528bb072445c99cf21a2c7ffc3 = UNSTREAM_STRING_ASCII(&constant_bin[ 600971 ], 15, 0);
    const_str_digest_5fa7996b99deb750a6e6de8b5f21cbf4 = UNSTREAM_STRING_ASCII(&constant_bin[ 600986 ], 19, 0);
    const_str_digest_d395ee4166bcad255ab6cb1b5c5f9e0b = UNSTREAM_STRING_ASCII(&constant_bin[ 601005 ], 23, 0);
    const_tuple_int_pos_20_int_0_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_int_0_tuple, 0, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_int_0_tuple, 1, const_int_0); Py_INCREF(const_int_0);
    const_str_digest_b50684ce91176f628bca5e02ea01b473 = UNSTREAM_STRING_ASCII(&constant_bin[ 601028 ], 34, 0);
    const_str_plain_current_user_saved_shows_contains = UNSTREAM_STRING_ASCII(&constant_bin[ 601062 ], 33, 1);
    const_str_plain_recommendations = UNSTREAM_STRING_ASCII(&constant_bin[ 599463 ], 15, 1);
    const_str_digest_757ba791492fe0a6bb1e97e655265d19 = UNSTREAM_STRING_ASCII(&constant_bin[ 601095 ], 41, 0);
    const_tuple_str_plain_self_str_plain_playlist_id_str_plain_plid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_playlist_id_str_plain_plid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_playlist_id_str_plain_plid_tuple, 1, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    const_str_plain_plid = UNSTREAM_STRING_ASCII(&constant_bin[ 601136 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_playlist_id_str_plain_plid_tuple, 2, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    const_str_digest_a140ca1afdc95e3bc95838a29ed7a7cb = UNSTREAM_STRING_ASCII(&constant_bin[ 601140 ], 179, 0);
    const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple, 1, const_str_plain_state); Py_INCREF(const_str_plain_state);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple, 2, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_str_digest_1a8b6548667df279696cefce4cc3a3c1 = UNSTREAM_STRING_ASCII(&constant_bin[ 601319 ], 224, 0);
    const_str_digest_07f46abe28b5e592c82e8deb6b13c902 = UNSTREAM_STRING_ASCII(&constant_bin[ 601543 ], 11, 0);
    const_tuple_str_digest_6ba34161f4b1f940d6d5b6c37f996eea_tuple = PyTuple_New(1);
    const_str_digest_6ba34161f4b1f940d6d5b6c37f996eea = UNSTREAM_STRING_ASCII(&constant_bin[ 601554 ], 17, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_6ba34161f4b1f940d6d5b6c37f996eea_tuple, 0, const_str_digest_6ba34161f4b1f940d6d5b6c37f996eea); Py_INCREF(const_str_digest_6ba34161f4b1f940d6d5b6c37f996eea);
    const_str_plain_loudness = UNSTREAM_STRING_ASCII(&constant_bin[ 601571 ], 8, 1);
    const_str_plain_album_type = UNSTREAM_STRING_ASCII(&constant_bin[ 601579 ], 10, 1);
    const_str_digest_c176c326cbe6514933ab2d3696cbe8eb = UNSTREAM_STRING_ASCII(&constant_bin[ 601589 ], 360, 0);
    const_str_digest_1220c3da1cafe83a535c664450909a43 = UNSTREAM_STRING_ASCII(&constant_bin[ 601949 ], 43, 0);
    const_str_digest_3d01ef8d22d715e36161185be7af38c8 = UNSTREAM_STRING_ASCII(&constant_bin[ 601992 ], 12, 0);
    const_tuple_52f5b989419359389333ac00979cfcda_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 1, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_str_plain_context_uri = UNSTREAM_STRING_ASCII(&constant_bin[ 602004 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 2, const_str_plain_context_uri); Py_INCREF(const_str_plain_context_uri);
    const_str_plain_uris = UNSTREAM_STRING_ASCII(&constant_bin[ 599421 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 3, const_str_plain_uris); Py_INCREF(const_str_plain_uris);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 4, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_str_plain_position_ms = UNSTREAM_STRING_ASCII(&constant_bin[ 602015 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 5, const_str_plain_position_ms); Py_INCREF(const_str_plain_position_ms);
    PyTuple_SET_ITEM(const_tuple_52f5b989419359389333ac00979cfcda_tuple, 6, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_str_digest_6b8ace3f84c15e9c2104ecbe7cae2585 = UNSTREAM_STRING_ASCII(&constant_bin[ 602026 ], 14, 0);
    const_tuple_none_int_pos_20_int_0_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_20_int_0_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_20_int_0_tuple, 1, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_20_int_0_tuple, 2, const_int_0); Py_INCREF(const_int_0);
    const_str_plain_seed_artists = UNSTREAM_STRING_ASCII(&constant_bin[ 602040 ], 12, 1);
    const_str_digest_44d4f41b8805ad55f08f3244d0e3b445 = UNSTREAM_STRING_ASCII(&constant_bin[ 602052 ], 127, 0);
    const_str_plain_playlist_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 602179 ], 15, 1);
    const_str_digest_7040c56b8e50bb41180c395c1e114602 = UNSTREAM_STRING_ASCII(&constant_bin[ 602194 ], 37, 0);
    const_str_plain_transfer_playback = UNSTREAM_STRING_ASCII(&constant_bin[ 602231 ], 17, 1);
    const_str_digest_ad86a189ebf14691511cbd1323b36137 = UNSTREAM_STRING_ASCII(&constant_bin[ 602248 ], 144, 0);
    const_tuple_str_plain_self_str_plain_volume_percent_str_plain_device_id_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_volume_percent_str_plain_device_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_volume_percent = UNSTREAM_STRING_ASCII(&constant_bin[ 601045 ], 14, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_volume_percent_str_plain_device_id_tuple, 1, const_str_plain_volume_percent); Py_INCREF(const_str_plain_volume_percent);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_volume_percent_str_plain_device_id_tuple, 2, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_str_digest_069bc1a16ac92217a1a2071901af3a5a = UNSTREAM_STRING_ASCII(&constant_bin[ 602392 ], 22, 0);
    const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple, 1, const_str_plain_show_id); Py_INCREF(const_str_plain_show_id);
    const_str_plain_market = UNSTREAM_STRING_ASCII(&constant_bin[ 602339 ], 6, 1);
    PyTuple_SET_ITEM(const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple, 2, const_str_plain_market); Py_INCREF(const_str_plain_market);
    const_str_plain_trid = UNSTREAM_STRING_ASCII(&constant_bin[ 602414 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple, 3, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_digest_930d390398b95425d4ffd93f06305d01 = UNSTREAM_STRING_ASCII(&constant_bin[ 602418 ], 26, 0);
    const_str_plain_collaborative = UNSTREAM_STRING_ASCII(&constant_bin[ 602444 ], 13, 1);
    const_str_digest_967a403b50fcd58b05904c6eb0b02666 = UNSTREAM_STRING_ASCII(&constant_bin[ 602457 ], 29, 0);
    const_str_digest_614602b0b9c0300e03c45bbfd5d983fd = UNSTREAM_STRING_ASCII(&constant_bin[ 601007 ], 8, 0);
    const_str_plain__auth = UNSTREAM_STRING_ASCII(&constant_bin[ 8681 ], 5, 1);
    const_str_digest_ad8a921df4ed7d5d7dfdb50bbff1b86a = UNSTREAM_STRING_ASCII(&constant_bin[ 602486 ], 34, 0);
    const_str_plain_seed_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 602520 ], 11, 1);
    const_str_plain_user_follow_users = UNSTREAM_STRING_ASCII(&constant_bin[ 602531 ], 17, 1);
    const_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9 = UNSTREAM_STRING_ASCII(&constant_bin[ 602548 ], 17, 0);
    const_str_digest_2e3834ae29b14c0ccc2520a1888eb751 = UNSTREAM_STRING_ASCII(&constant_bin[ 602565 ], 107, 0);
    const_str_digest_c694d59c7b8c840b24e0bfebb7bc0d33 = UNSTREAM_STRING_ASCII(&constant_bin[ 602672 ], 36, 0);
    const_str_digest_798b1b3ff15941081d0a1905436770f1 = UNSTREAM_STRING_ASCII(&constant_bin[ 602708 ], 15, 0);
    const_str_digest_5ad7dec315c7c67463047637575d5a5d = UNSTREAM_STRING_ASCII(&constant_bin[ 602723 ], 47, 0);
    const_str_digest_79519b954015c155dd29d1b46a9c1158 = UNSTREAM_STRING_ASCII(&constant_bin[ 602770 ], 13, 0);
    const_str_digest_826172b5b9d28ef349545850487317c6 = UNSTREAM_STRING_ASCII(&constant_bin[ 602783 ], 114, 0);
    const_str_digest_da6c98784a359364f8b00206a371e05a = UNSTREAM_STRING_ASCII(&constant_bin[ 602897 ], 10, 0);
    const_str_digest_bc8036c231ae7fe76f8be4f140448aca = UNSTREAM_STRING_ASCII(&constant_bin[ 602898 ], 9, 0);
    const_str_digest_c0f7f6ac2ded292348d4d33e1370f034 = UNSTREAM_STRING_ASCII(&constant_bin[ 602907 ], 34, 0);
    const_str_digest_ad0cd2e91af697e20ab6ef3c064eeb24 = UNSTREAM_STRING_ASCII(&constant_bin[ 602941 ], 39, 0);
    const_str_plain_artist_albums = UNSTREAM_STRING_ASCII(&constant_bin[ 602980 ], 13, 1);
    const_str_plain_trackid = UNSTREAM_STRING_ASCII(&constant_bin[ 602993 ], 7, 1);
    const_str_digest_7bcf090e47dac41bef268864bc11052d = UNSTREAM_STRING_ASCII(&constant_bin[ 603000 ], 539, 0);
    const_str_digest_2dbaaa50149a05432865aa8002090146 = UNSTREAM_STRING_ASCII(&constant_bin[ 603539 ], 623, 0);
    const_str_plain_min_ = UNSTREAM_STRING_ASCII(&constant_bin[ 604162 ], 4, 1);
    const_tuple_str_digest_1220c3da1cafe83a535c664450909a43_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_1220c3da1cafe83a535c664450909a43_tuple, 0, const_str_digest_1220c3da1cafe83a535c664450909a43); Py_INCREF(const_str_digest_1220c3da1cafe83a535c664450909a43);
    const_str_plain_user_playlist_change_details = UNSTREAM_STRING_ASCII(&constant_bin[ 604166 ], 28, 1);
    const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple, 2, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple, 3, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_str_digest_5090487500dd71ff8ac64eb8e9322d70 = UNSTREAM_STRING_ASCII(&constant_bin[ 604194 ], 25, 0);
    const_str_digest_da2afbbf6793907933f5ecd26dc790fb = UNSTREAM_STRING_ASCII(&constant_bin[ 599346 ], 3, 0);
    const_str_plain_user_playlist_unfollow = UNSTREAM_STRING_ASCII(&constant_bin[ 604219 ], 22, 1);
    const_str_digest_692c4b25f3b4e214a8f7bcfe297e5fa9 = UNSTREAM_STRING_ASCII(&constant_bin[ 604241 ], 173, 0);
    const_str_digest_839a8c1f15a51259ddc0a84ae73da1ee = UNSTREAM_STRING_ASCII(&constant_bin[ 604414 ], 23, 0);
    const_tuple_none_none_none_int_pos_20_none_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_none_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_none_tuple, 1, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_none_tuple, 2, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_none_tuple, 3, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_none_tuple, 4, Py_None); Py_INCREF(Py_None);
    const_str_digest_180864d7a3022e5d03259a9166cebeb6 = UNSTREAM_STRING_ASCII(&constant_bin[ 604437 ], 640, 0);
    const_str_plain_current_user_saved_shows = UNSTREAM_STRING_ASCII(&constant_bin[ 601062 ], 24, 1);
    const_str_digest_04a9401e879dd7f163ef999a3d8c8737 = UNSTREAM_STRING_ASCII(&constant_bin[ 605077 ], 176, 0);
    const_str_plain_current_user_recently_played = UNSTREAM_STRING_ASCII(&constant_bin[ 605253 ], 28, 1);
    const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 1, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 2, const_str_plain_fields); Py_INCREF(const_str_plain_fields);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 3, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 4, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 5, const_str_plain_market); Py_INCREF(const_str_plain_market);
    const_str_plain_additional_types = UNSTREAM_STRING_ASCII(&constant_bin[ 605281 ], 16, 1);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 6, const_str_plain_additional_types); Py_INCREF(const_str_plain_additional_types);
    PyTuple_SET_ITEM(const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 7, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    const_tuple_str_plain_self_str_plain_retry_str_plain_adapter_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_retry_str_plain_adapter_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_retry_str_plain_adapter_tuple, 1, const_str_plain_retry); Py_INCREF(const_str_plain_retry);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_retry_str_plain_adapter_tuple, 2, const_str_plain_adapter); Py_INCREF(const_str_plain_adapter);
    const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple, 1, const_str_plain_track_id); Py_INCREF(const_str_plain_track_id);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple, 2, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple, 1, const_str_plain_album_id); Py_INCREF(const_str_plain_album_id);
    PyTuple_SET_ITEM(const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple, 2, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple, 3, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple, 4, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_digest_3c86c46e0167d5634370eed30742bc81 = UNSTREAM_STRING(&constant_bin[ 605297 ], 210, 0);
    const_str_digest_719b93109d0bcd472ce92b9ca5f0b0a1 = UNSTREAM_STRING_ASCII(&constant_bin[ 605507 ], 16, 0);
    const_str_digest_0d902bb3bd6b845836b00d2cb91900bb = UNSTREAM_STRING_ASCII(&constant_bin[ 605523 ], 36, 0);
    const_str_plain_current_user_saved_albums_delete = UNSTREAM_STRING_ASCII(&constant_bin[ 605559 ], 32, 1);
    const_str_digest_45149880b235040e3cc1276f459ecfa0 = UNSTREAM_STRING_ASCII(&constant_bin[ 605591 ], 238, 0);
    const_tuple_str_plain_self_str_plain_albums_str_plain_tlist_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_albums_str_plain_tlist_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_albums_str_plain_tlist_tuple, 1, const_str_plain_albums); Py_INCREF(const_str_plain_albums);
    const_str_plain_tlist = UNSTREAM_STRING_ASCII(&constant_bin[ 17886 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_albums_str_plain_tlist_tuple, 2, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_str_plain_range_start = UNSTREAM_STRING_ASCII(&constant_bin[ 605829 ], 11, 1);
    const_str_digest_4c12e1d5470fdec172110c6d89b8e1f3 = UNSTREAM_STRING_ASCII(&constant_bin[ 605840 ], 187, 0);
    const_tuple_8cc3613134194fa97627fa253dd27832_tuple = PyTuple_New(12);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 1, const_str_plain_auth); Py_INCREF(const_str_plain_auth);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 2, const_str_plain_requests_session); Py_INCREF(const_str_plain_requests_session);
    const_str_plain_client_credentials_manager = UNSTREAM_STRING_ASCII(&constant_bin[ 606027 ], 26, 1);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 3, const_str_plain_client_credentials_manager); Py_INCREF(const_str_plain_client_credentials_manager);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 4, const_str_plain_oauth_manager); Py_INCREF(const_str_plain_oauth_manager);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 5, const_str_plain_auth_manager); Py_INCREF(const_str_plain_auth_manager);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 6, const_str_plain_proxies); Py_INCREF(const_str_plain_proxies);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 7, const_str_plain_requests_timeout); Py_INCREF(const_str_plain_requests_timeout);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 8, const_str_plain_status_forcelist); Py_INCREF(const_str_plain_status_forcelist);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 9, const_str_plain_retries); Py_INCREF(const_str_plain_retries);
    const_str_plain_status_retries = UNSTREAM_STRING_ASCII(&constant_bin[ 606053 ], 14, 1);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 10, const_str_plain_status_retries); Py_INCREF(const_str_plain_status_retries);
    PyTuple_SET_ITEM(const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 11, const_str_plain_backoff_factor); Py_INCREF(const_str_plain_backoff_factor);
    const_str_digest_c288d80fe09d5296eb3f023ab83cce4b = UNSTREAM_STRING_ASCII(&constant_bin[ 602723 ], 31, 0);
    const_str_digest_fe0740ea6f5308d7e1b3f22eff165a3c = UNSTREAM_STRING_ASCII(&constant_bin[ 606067 ], 12, 0);
    const_str_digest_8e9f262240f32f6727dab4cb6fe61480 = UNSTREAM_STRING_ASCII(&constant_bin[ 606079 ], 8, 0);
    const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple, 0, const_int_pos_429); Py_INCREF(const_int_pos_429);
    PyTuple_SET_ITEM(const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple, 1, const_int_pos_500); Py_INCREF(const_int_pos_500);
    const_int_pos_502 = PyLong_FromUnsignedLong(502ul);
    PyTuple_SET_ITEM(const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple, 2, const_int_pos_502); Py_INCREF(const_int_pos_502);
    PyTuple_SET_ITEM(const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple, 3, const_int_pos_503); Py_INCREF(const_int_pos_503);
    PyTuple_SET_ITEM(const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple, 4, const_int_pos_504); Py_INCREF(const_int_pos_504);
    const_tuple_str_digest_5ecac5642f7e480103d36531036f6532_tuple = PyTuple_New(1);
    const_str_digest_5ecac5642f7e480103d36531036f6532 = UNSTREAM_STRING_ASCII(&constant_bin[ 602026 ], 8, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_5ecac5642f7e480103d36531036f6532_tuple, 0, const_str_digest_5ecac5642f7e480103d36531036f6532); Py_INCREF(const_str_digest_5ecac5642f7e480103d36531036f6532);
    const_str_digest_7d03408a0919929aa3016cec79244567 = UNSTREAM_STRING_ASCII(&constant_bin[ 606087 ], 14, 0);
    const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_plain_playlist_owner_id = UNSTREAM_STRING_ASCII(&constant_bin[ 601698 ], 17, 1);
    PyTuple_SET_ITEM(const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple, 1, const_str_plain_playlist_owner_id); Py_INCREF(const_str_plain_playlist_owner_id);
    PyTuple_SET_ITEM(const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    const_str_plain_user_ids = UNSTREAM_STRING_ASCII(&constant_bin[ 601817 ], 8, 1);
    PyTuple_SET_ITEM(const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple, 3, const_str_plain_user_ids); Py_INCREF(const_str_plain_user_ids);
    PyTuple_SET_ITEM(const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple, 4, const_str_plain_endpoint); Py_INCREF(const_str_plain_endpoint);
    const_str_digest_aca4116a97710d2d33f68f95d3da0496 = UNSTREAM_STRING_ASCII(&constant_bin[ 606101 ], 1389, 0);
    const_str_plain_position = UNSTREAM_STRING_ASCII(&constant_bin[ 19312 ], 8, 1);
    const_str_digest_5ffaaf10b0544615d3c06b06a2628169 = UNSTREAM_STRING_ASCII(&constant_bin[ 607490 ], 32, 0);
    const_tuple_str_plain_self_str_plain_auth_manager_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_auth_manager_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_auth_manager_tuple, 1, const_str_plain_auth_manager); Py_INCREF(const_str_plain_auth_manager);
    const_str_digest_16e376831744b80c309abc0ab80ac512 = UNSTREAM_STRING_ASCII(&constant_bin[ 607522 ], 15, 0);
    const_str_digest_709f5323a138435d167ad8ffaa8e9e75 = UNSTREAM_STRING_ASCII(&constant_bin[ 607537 ], 27, 0);
    const_tuple_int_pos_10_int_0_str_plain_track_none_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_int_pos_10_int_0_str_plain_track_none_tuple, 0, const_int_pos_10); Py_INCREF(const_int_pos_10);
    PyTuple_SET_ITEM(const_tuple_int_pos_10_int_0_str_plain_track_none_tuple, 1, const_int_0); Py_INCREF(const_int_0);
    PyTuple_SET_ITEM(const_tuple_int_pos_10_int_0_str_plain_track_none_tuple, 2, const_str_plain_track); Py_INCREF(const_str_plain_track);
    PyTuple_SET_ITEM(const_tuple_int_pos_10_int_0_str_plain_track_none_tuple, 3, Py_None); Py_INCREF(Py_None);
    const_str_plain_playlist_cover_image = UNSTREAM_STRING_ASCII(&constant_bin[ 607564 ], 20, 1);
    const_str_digest_921be7d0436af20df73b917a524de443 = UNSTREAM_STRING_ASCII(&constant_bin[ 607584 ], 45, 0);
    const_tuple_str_digest_da2afbbf6793907933f5ecd26dc790fb_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_da2afbbf6793907933f5ecd26dc790fb_tuple, 0, const_str_digest_da2afbbf6793907933f5ecd26dc790fb); Py_INCREF(const_str_digest_da2afbbf6793907933f5ecd26dc790fb);
    const_str_digest_5fffeb0d87cae7fe6ec23be661f2fd69 = UNSTREAM_STRING_ASCII(&constant_bin[ 607629 ], 27, 0);
    const_str_plain_devices = UNSTREAM_STRING_ASCII(&constant_bin[ 598943 ], 7, 1);
    const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple, 1, const_str_plain_artist_id); Py_INCREF(const_str_plain_artist_id);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple, 2, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_digest_fcd3a7c6c8bc32050163417ad987af39 = UNSTREAM_STRING_ASCII(&constant_bin[ 607656 ], 15, 0);
    const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple, 1, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple, 2, const_str_plain_after); Py_INCREF(const_str_plain_after);
    const_str_plain_before = UNSTREAM_STRING_ASCII(&constant_bin[ 90964 ], 6, 1);
    PyTuple_SET_ITEM(const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple, 3, const_str_plain_before); Py_INCREF(const_str_plain_before);
    const_str_digest_5b506f304dd8229333e7f1c8eeb8465b = UNSTREAM_STRING_ASCII(&constant_bin[ 602457 ], 12, 0);
    const_str_digest_848b05d9873b21f3410831cc56f1f4f0 = UNSTREAM_STRING_ASCII(&constant_bin[ 607671 ], 280, 0);
    const_str_digest_ad1b0c6365dc3c25056e3014de5caa7d = UNSTREAM_STRING_ASCII(&constant_bin[ 607951 ], 27, 0);
    const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple, 3, const_str_plain_fields); Py_INCREF(const_str_plain_fields);
    PyTuple_SET_ITEM(const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple, 4, const_str_plain_market); Py_INCREF(const_str_plain_market);
    const_str_plain_user_playlist_replace_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 607978 ], 28, 1);
    const_str_plain__delete = UNSTREAM_STRING_ASCII(&constant_bin[ 598918 ], 7, 1);
    const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41 = UNSTREAM_STRING_ASCII(&constant_bin[ 608006 ], 28, 0);
    const_str_digest_c8dd3e40bf7394768822193fde87cb0c = UNSTREAM_STRING_ASCII(&constant_bin[ 608034 ], 12, 0);
    const_str_digest_0e6e939b250c1a8ba18da5e85aa91db2 = UNSTREAM_STRING_ASCII(&constant_bin[ 608046 ], 16, 0);
    const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 1, const_str_plain_show_id); Py_INCREF(const_str_plain_show_id);
    PyTuple_SET_ITEM(const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 2, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 3, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 4, const_str_plain_market); Py_INCREF(const_str_plain_market);
    PyTuple_SET_ITEM(const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 5, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_plain_current_user_saved_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 598893 ], 25, 1);
    const_tuple_str_plain_self_str_plain_user_str_plain_playlist_id_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_user_str_plain_playlist_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_user_str_plain_playlist_id_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_user_str_plain_playlist_id_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    const_tuple_type_ValueError_type_KeyError_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_type_ValueError_type_KeyError_tuple, 0, (PyObject *)PyExc_ValueError); Py_INCREF((PyObject *)PyExc_ValueError);
    PyTuple_SET_ITEM(const_tuple_type_ValueError_type_KeyError_tuple, 1, (PyObject *)PyExc_KeyError); Py_INCREF((PyObject *)PyExc_KeyError);
    const_str_plain_current_user_top_artists = UNSTREAM_STRING_ASCII(&constant_bin[ 607498 ], 24, 1);
    const_str_plain_instrumentalness = UNSTREAM_STRING_ASCII(&constant_bin[ 608062 ], 16, 1);
    const_str_digest_6e473efda59bed328f388eb28cfe5f4e = UNSTREAM_STRING_ASCII(&constant_bin[ 608078 ], 29, 0);
    const_str_digest_e96964f806da53ae36961b93a992dcdc = UNSTREAM_STRING_ASCII(&constant_bin[ 608107 ], 21, 0);
    const_tuple_str_plain_self_str_plain_device_id_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_device_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_device_id_tuple, 1, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_str_plain_valence = UNSTREAM_STRING_ASCII(&constant_bin[ 608128 ], 7, 1);
    const_str_digest_8db972dc902d3ee7ab11dac29db55dce = UNSTREAM_STRING_ASCII(&constant_bin[ 608135 ], 129, 0);
    const_str_digest_391f9f64704d3a7c47cf625eccafc7c0 = UNSTREAM_STRING_ASCII(&constant_bin[ 608264 ], 18, 0);
    const_str_digest_8a674a9696fb048c8df9608719462515 = UNSTREAM_STRING_ASCII(&constant_bin[ 608282 ], 22, 0);
    const_tuple_str_digest_8921f974345d80799e10e01caa480348_tuple = PyTuple_New(1);
    const_str_digest_8921f974345d80799e10e01caa480348 = UNSTREAM_STRING_ASCII(&constant_bin[ 608304 ], 27, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_8921f974345d80799e10e01caa480348_tuple, 0, const_str_digest_8921f974345d80799e10e01caa480348); Py_INCREF(const_str_digest_8921f974345d80799e10e01caa480348);
    const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 3, const_str_plain_range_start); Py_INCREF(const_str_plain_range_start);
    const_str_plain_insert_before = UNSTREAM_STRING_ASCII(&constant_bin[ 608331 ], 13, 1);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 4, const_str_plain_insert_before); Py_INCREF(const_str_plain_insert_before);
    const_str_plain_range_length = UNSTREAM_STRING_ASCII(&constant_bin[ 608344 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 5, const_str_plain_range_length); Py_INCREF(const_str_plain_range_length);
    const_str_plain_snapshot_id = UNSTREAM_STRING_ASCII(&constant_bin[ 604103 ], 11, 1);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 6, const_str_plain_snapshot_id); Py_INCREF(const_str_plain_snapshot_id);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 7, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    PyTuple_SET_ITEM(const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 8, const_str_plain_payload); Py_INCREF(const_str_plain_payload);
    const_tuple_str_plain_self_str_plain_market_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_market_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_market_tuple, 1, const_str_plain_market); Py_INCREF(const_str_plain_market);
    const_str_digest_a0a94d59c8ae6f19fa06528cbb359dd0 = UNSTREAM_STRING_ASCII(&constant_bin[ 602711 ], 12, 0);
    const_str_plain__post = UNSTREAM_STRING_ASCII(&constant_bin[ 26410 ], 5, 1);
    const_str_digest_fc25e5cf6e0b48aa9d408ea60121013f = UNSTREAM_STRING_ASCII(&constant_bin[ 608356 ], 36, 0);
    const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple, 1, const_str_plain_artist_id); Py_INCREF(const_str_plain_artist_id);
    PyTuple_SET_ITEM(const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple, 2, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple, 3, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_digest_3e78615d7227579781094c3c19b67451 = UNSTREAM_STRING_ASCII(&constant_bin[ 608392 ], 22, 0);
    const_tuple_str_digest_c7224164f58b9974744c1a8795894870_tuple = PyTuple_New(1);
    const_str_digest_c7224164f58b9974744c1a8795894870 = UNSTREAM_STRING_ASCII(&constant_bin[ 608414 ], 13, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_c7224164f58b9974744c1a8795894870_tuple, 0, const_str_digest_c7224164f58b9974744c1a8795894870); Py_INCREF(const_str_digest_c7224164f58b9974744c1a8795894870);
    const_tuple_str_digest_35f78d818bb0285af39fbe7dbc808b01_tuple = PyTuple_New(1);
    const_str_digest_35f78d818bb0285af39fbe7dbc808b01 = UNSTREAM_STRING_ASCII(&constant_bin[ 608427 ], 23, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_35f78d818bb0285af39fbe7dbc808b01_tuple, 0, const_str_digest_35f78d818bb0285af39fbe7dbc808b01); Py_INCREF(const_str_digest_35f78d818bb0285af39fbe7dbc808b01);
    const_str_digest_5ea519055b607b7c1ff94d353137ea59 = UNSTREAM_STRING_ASCII(&constant_bin[ 608450 ], 30, 0);
    const_str_digest_9a029006dffa7d97b13721aeb2f78406 = UNSTREAM_STRING_ASCII(&constant_bin[ 602194 ], 33, 0);
    const_str_digest_276fb866df82e86eb69e538ba8a0f638 = UNSTREAM_STRING_ASCII(&constant_bin[ 608480 ], 256, 0);
    const_tuple_e154c21abc67708aeafc1bb2f6712757_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_e154c21abc67708aeafc1bb2f6712757_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_e154c21abc67708aeafc1bb2f6712757_tuple, 1, const_str_plain_playlist_owner_id); Py_INCREF(const_str_plain_playlist_owner_id);
    PyTuple_SET_ITEM(const_tuple_e154c21abc67708aeafc1bb2f6712757_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    const_str_plain_user_playlist = UNSTREAM_STRING_ASCII(&constant_bin[ 599289 ], 13, 1);
    const_str_plain_liveness = UNSTREAM_STRING_ASCII(&constant_bin[ 608736 ], 8, 1);
    const_str_digest_223709650aeac13928929205a42f7ef5 = UNSTREAM_STRING_ASCII(&constant_bin[ 608744 ], 14, 0);
    const_str_digest_9dc62dec5d04c5eb8a17c90c45485f89 = UNSTREAM_STRING_ASCII(&constant_bin[ 608758 ], 26, 0);
    const_str_digest_a2dd6239923e72eabb819f2d368b274b = UNSTREAM_STRING_ASCII(&constant_bin[ 608015 ], 19, 0);
    const_tuple_92627fe8b33459c81955bb22182b44fc_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 1, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 2, const_str_plain_fields); Py_INCREF(const_str_plain_fields);
    PyTuple_SET_ITEM(const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 3, const_str_plain_market); Py_INCREF(const_str_plain_market);
    PyTuple_SET_ITEM(const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 4, const_str_plain_additional_types); Py_INCREF(const_str_plain_additional_types);
    PyTuple_SET_ITEM(const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 5, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    const_str_digest_bc9ddd864c719d358505256c02db1172 = UNSTREAM_STRING_ASCII(&constant_bin[ 608784 ], 20, 0);
    const_str_digest_4b32f198f6de09ec1a43edf661b1c6e4 = UNSTREAM_STRING_ASCII(&constant_bin[ 608804 ], 46, 1);
    const_str_digest_54e4b558d0d0cb3a69eebc739356fc4d = UNSTREAM_STRING_ASCII(&constant_bin[ 608850 ], 25, 0);
    const_str_digest_bd964b21b4b89004df13ec1af48482be = UNSTREAM_STRING_ASCII(&constant_bin[ 608875 ], 16, 0);
    const_str_digest_07e7f9ec031b8623c28ffb0538000243 = UNSTREAM_STRING_ASCII(&constant_bin[ 608891 ], 74, 0);
    const_str_digest_19a37dfa2366a4f037bdcf195f572705 = UNSTREAM_STRING_ASCII(&constant_bin[ 608965 ], 14, 0);
    const_str_plain_previous_track = UNSTREAM_STRING_ASCII(&constant_bin[ 598958 ], 14, 1);
    const_str_digest_00b8f5f56af562fc9d94296f9e2775bc = UNSTREAM_STRING_ASCII(&constant_bin[ 608979 ], 25, 0);
    const_str_digest_57bce8905b9357b4bbbeafff3c64bd6a = UNSTREAM_STRING_ASCII(&constant_bin[ 601095 ], 32, 0);
    const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple, 1, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    const_str_plain_image_b64 = UNSTREAM_STRING_ASCII(&constant_bin[ 609004 ], 9, 1);
    PyTuple_SET_ITEM(const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple, 2, const_str_plain_image_b64); Py_INCREF(const_str_plain_image_b64);
    PyTuple_SET_ITEM(const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple, 3, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    const_str_digest_a9b9b45a6cb5971d9dde9506256891bd = UNSTREAM_STRING_ASCII(&constant_bin[ 609013 ], 22, 0);
    const_str_digest_589d9c66020624c5607b648b0706e668 = UNSTREAM_STRING_ASCII(&constant_bin[ 609035 ], 26, 0);
    const_str_digest_c837bee036dd14c3f093d35248327022 = UNSTREAM_STRING_ASCII(&constant_bin[ 609061 ], 37, 0);
    const_str_digest_9a89b14ef9f9031019bb64544b058eba = UNSTREAM_STRING_ASCII(&constant_bin[ 609098 ], 15, 0);
    const_str_digest_8d3d887854fd55e6c944eb78e0e51acb = UNSTREAM_STRING_ASCII(&constant_bin[ 609113 ], 518, 0);
    const_str_plain_user_unfollow_artists = UNSTREAM_STRING_ASCII(&constant_bin[ 608086 ], 21, 1);
    const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple, 1, const_str_plain_category_id); Py_INCREF(const_str_plain_category_id);
    PyTuple_SET_ITEM(const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple, 2, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple, 3, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple, 4, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_str_digest_ab8a4dee974a2c8d40c89f0c65db03e5 = UNSTREAM_STRING_ASCII(&constant_bin[ 609631 ], 22, 0);
    const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 3, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 4, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    const_str_plain_ftracks = UNSTREAM_STRING_ASCII(&constant_bin[ 609653 ], 7, 1);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 5, const_str_plain_ftracks); Py_INCREF(const_str_plain_ftracks);
    PyTuple_SET_ITEM(const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 6, const_str_plain_payload); Py_INCREF(const_str_plain_payload);
    const_str_plain_category_playlists = UNSTREAM_STRING_ASCII(&constant_bin[ 609043 ], 18, 1);
    const_str_digest_7b4aeedd2d02cc6c175e110c0bda8734 = UNSTREAM_STRING_ASCII(&constant_bin[ 609660 ], 18, 0);
    const_str_digest_e0de147f27f355d47023f4e16df331f0 = UNSTREAM_STRING_ASCII(&constant_bin[ 609678 ], 59, 0);
    const_str_digest_a98e8b7de683f2bff160c84779fead57 = UNSTREAM_STRING_ASCII(&constant_bin[ 609737 ], 20, 0);
    const_str_digest_a5475341d16ac442212eca2ae5ce481c = UNSTREAM_STRING_ASCII(&constant_bin[ 609757 ], 42, 0);
    const_str_digest_86b299db541ebe8d4a030a5cb6ee08ca = UNSTREAM_STRING_ASCII(&constant_bin[ 609799 ], 37, 0);
    const_str_plain_default_retry_codes = UNSTREAM_STRING_ASCII(&constant_bin[ 609836 ], 19, 1);
    const_tuple_str_plain_self_str_plain_path_str_plain_device_id_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_path_str_plain_device_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_path_str_plain_device_id_tuple, 1, const_str_plain_path); Py_INCREF(const_str_plain_path);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_path_str_plain_device_id_tuple, 2, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_str_digest_a4092bb382602ef0ef001894fe04bc08 = UNSTREAM_STRING_ASCII(&constant_bin[ 609855 ], 46, 0);
    const_str_plain_seed_genres = UNSTREAM_STRING_ASCII(&constant_bin[ 609901 ], 11, 1);
    const_str_digest_2053fcde6598069e7f533c9fe817316c = UNSTREAM_STRING_ASCII(&constant_bin[ 609912 ], 118, 0);
    const_str_digest_453d9a13f190051d0fb607026b4faf41 = UNSTREAM_STRING_ASCII(&constant_bin[ 604422 ], 14, 0);
    const_str_plain_medium_term = UNSTREAM_STRING_ASCII(&constant_bin[ 610030 ], 11, 1);
    const_str_digest_af8a59ee158f81b27a541e29aa6b044e = UNSTREAM_STRING_ASCII(&constant_bin[ 610041 ], 22, 0);
    const_tuple_str_digest_f072b674dcd223579507c51d0df33d44_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_f072b674dcd223579507c51d0df33d44_tuple, 0, const_str_digest_f072b674dcd223579507c51d0df33d44); Py_INCREF(const_str_digest_f072b674dcd223579507c51d0df33d44);
    const_str_digest_88f8614620997a7b7c5450e0473e6487 = UNSTREAM_STRING_ASCII(&constant_bin[ 610063 ], 16, 0);
    const_tuple_str_digest_453d9a13f190051d0fb607026b4faf41_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_453d9a13f190051d0fb607026b4faf41_tuple, 0, const_str_digest_453d9a13f190051d0fb607026b4faf41); Py_INCREF(const_str_digest_453d9a13f190051d0fb607026b4faf41);
    const_str_plain_user_playlist_create = UNSTREAM_STRING_ASCII(&constant_bin[ 610079 ], 20, 1);
    const_str_digest_5d829d81793681107bd9dec71adcd753 = UNSTREAM_STRING_ASCII(&constant_bin[ 610099 ], 19, 0);
    const_tuple_str_plain_self_str_plain_user_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_user_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_user_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    const_str_digest_ea7d6548ef37d4b0632c164c6b7bea7c = UNSTREAM_STRING_ASCII(&constant_bin[ 610118 ], 170, 0);
    const_tuple_6367be7db62c8846531c10fec757318e_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 3, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 4, const_str_plain_public); Py_INCREF(const_str_plain_public);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 5, const_str_plain_collaborative); Py_INCREF(const_str_plain_collaborative);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 6, const_str_plain_description); Py_INCREF(const_str_plain_description);
    PyTuple_SET_ITEM(const_tuple_6367be7db62c8846531c10fec757318e_tuple, 7, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_str_digest_51b7dd8ac0216ff3eefb41eb4578f977 = UNSTREAM_STRING_ASCII(&constant_bin[ 610288 ], 23, 0);
    const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple = PyTuple_New(9);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 3, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 4, const_str_plain_snapshot_id); Py_INCREF(const_str_plain_snapshot_id);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 5, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 6, const_str_plain_ftracks); Py_INCREF(const_str_plain_ftracks);
    const_str_plain_tr = UNSTREAM_STRING_ASCII(&constant_bin[ 31 ], 2, 1);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 7, const_str_plain_tr); Py_INCREF(const_str_plain_tr);
    PyTuple_SET_ITEM(const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 8, const_str_plain_payload); Py_INCREF(const_str_plain_payload);
    const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 3, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 4, const_str_plain_position); Py_INCREF(const_str_plain_position);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 5, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    PyTuple_SET_ITEM(const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 6, const_str_plain_ftracks); Py_INCREF(const_str_plain_ftracks);
    const_str_digest_ca1b89362262296b98ca23da8d1a4747 = UNSTREAM_STRING_ASCII(&constant_bin[ 602723 ], 6, 0);
    const_str_digest_96a41717fe5579fbdcb4a2aecebaef20 = UNSTREAM_STRING_ASCII(&constant_bin[ 610311 ], 16, 0);
    const_str_digest_a3911b6aa4c898878e39b3942a493b69 = UNSTREAM_STRING_ASCII(&constant_bin[ 610327 ], 15, 0);
    const_str_digest_0607b1eabf6f75dc0f138641d9491d4d = UNSTREAM_STRING_ASCII(&constant_bin[ 610342 ], 12, 0);
    const_str_plain_acousticness = UNSTREAM_STRING_ASCII(&constant_bin[ 610354 ], 12, 1);
    const_int_pos_599 = PyLong_FromUnsignedLong(599ul);
    const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple = PyTuple_New(10);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 1, const_str_plain_method); Py_INCREF(const_str_plain_method);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 2, const_str_plain_url); Py_INCREF(const_str_plain_url);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 3, const_str_plain_payload); Py_INCREF(const_str_plain_payload);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 4, const_str_plain_params); Py_INCREF(const_str_plain_params);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 5, const_str_plain_args); Py_INCREF(const_str_plain_args);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 6, const_str_plain_headers); Py_INCREF(const_str_plain_headers);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 7, const_str_plain_response); Py_INCREF(const_str_plain_response);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 8, const_str_plain_results); Py_INCREF(const_str_plain_results);
    PyTuple_SET_ITEM(const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 9, const_str_plain_msg); Py_INCREF(const_str_plain_msg);
    const_str_plain_popularity = UNSTREAM_STRING_ASCII(&constant_bin[ 610366 ], 10, 1);
    const_tuple_4886489b19733e5c89d8dc50502d893b_tuple = PyTuple_New(11);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 1, const_str_plain_seed_artists); Py_INCREF(const_str_plain_seed_artists);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 2, const_str_plain_seed_genres); Py_INCREF(const_str_plain_seed_genres);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 3, const_str_plain_seed_tracks); Py_INCREF(const_str_plain_seed_tracks);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 4, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 5, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 6, const_str_plain_kwargs); Py_INCREF(const_str_plain_kwargs);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 7, const_str_plain_params); Py_INCREF(const_str_plain_params);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 8, const_str_plain_attribute); Py_INCREF(const_str_plain_attribute);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 9, const_str_plain_prefix); Py_INCREF(const_str_plain_prefix);
    PyTuple_SET_ITEM(const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 10, const_str_plain_param); Py_INCREF(const_str_plain_param);
    const_str_digest_c6869dc60b510805e792b2878f36c2bb = UNSTREAM_STRING_ASCII(&constant_bin[ 608006 ], 21, 0);
    const_tuple_true_str_empty_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_true_str_empty_tuple, 0, Py_True); Py_INCREF(Py_True);
    PyTuple_SET_ITEM(const_tuple_true_str_empty_tuple, 1, const_str_empty); Py_INCREF(const_str_empty);
    const_str_digest_b3ea5a61b9afb9d8e21446f8f679560f = UNSTREAM_STRING_ASCII(&constant_bin[ 610376 ], 101, 0);
    const_str_digest_1668a40f9d67d62504803c85c35ad2c7 = UNSTREAM_STRING_ASCII(&constant_bin[ 610477 ], 172, 0);
    const_str_plain_album_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 609745 ], 12, 1);
    const_str_digest_b53a9225f95dfacd53de288eb49849b4 = UNSTREAM_STRING_ASCII(&constant_bin[ 610649 ], 548, 0);
    const_str_digest_dc236d8b13fa2bcf6bf5c872ea44aaa2 = UNSTREAM_STRING_ASCII(&constant_bin[ 611197 ], 949, 0);
    const_tuple_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19_tuple, 0, const_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19); Py_INCREF(const_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19);
    const_str_plain__internal_call = UNSTREAM_STRING_ASCII(&constant_bin[ 609639 ], 14, 1);
    const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 3, const_str_plain_fields); Py_INCREF(const_str_plain_fields);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 4, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 5, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 6, const_str_plain_market); Py_INCREF(const_str_plain_market);
    const_str_digest_bac177f6409c0163a72de93274bfcfda = UNSTREAM_STRING_ASCII(&constant_bin[ 601095 ], 20, 0);
    const_tuple_str_digest_437745d19c2123e6ab1318a417676e2d_tuple = PyTuple_New(1);
    const_str_digest_437745d19c2123e6ab1318a417676e2d = UNSTREAM_STRING_ASCII(&constant_bin[ 612146 ], 25, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_437745d19c2123e6ab1318a417676e2d_tuple, 0, const_str_digest_437745d19c2123e6ab1318a417676e2d); Py_INCREF(const_str_digest_437745d19c2123e6ab1318a417676e2d);
    const_tuple_str_plain_self_str_plain_limit_str_plain_after_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_limit_str_plain_after_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_limit_str_plain_after_tuple, 1, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_limit_str_plain_after_tuple, 2, const_str_plain_after); Py_INCREF(const_str_plain_after);
    const_str_plain_audio_analysis = UNSTREAM_STRING_ASCII(&constant_bin[ 612171 ], 14, 1);
    const_str_digest_eca0f059baf41471e999a751e560bd50 = UNSTREAM_STRING_ASCII(&constant_bin[ 612185 ], 145, 0);
    const_tuple_str_digest_1e8042c594f592682be42de584406334_tuple = PyTuple_New(1);
    const_str_digest_1e8042c594f592682be42de584406334 = UNSTREAM_STRING_ASCII(&constant_bin[ 612330 ], 13, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_1e8042c594f592682be42de584406334_tuple, 0, const_str_digest_1e8042c594f592682be42de584406334); Py_INCREF(const_str_digest_1e8042c594f592682be42de584406334);
    const_str_digest_06ce06e2e0ca5ed295843a89172ce4cf = UNSTREAM_STRING_ASCII(&constant_bin[ 612343 ], 277, 0);
    const_str_digest_c4e4d6ee79b254fd0456272a4368eceb = UNSTREAM_STRING_ASCII(&constant_bin[ 612620 ], 108, 0);
    const_str_digest_aac40a8551d6102f0d2c30ca4a15eac4 = UNSTREAM_STRING(&constant_bin[ 612728 ], 210, 0);
    const_str_plain_current_user_playlists = UNSTREAM_STRING_ASCII(&constant_bin[ 608458 ], 22, 1);
    const_str_digest_6c9e8a9e157453a28103d4c0f15c86e1 = UNSTREAM_STRING_ASCII(&constant_bin[ 612938 ], 19, 0);
    const_str_plain_energy = UNSTREAM_STRING_ASCII(&constant_bin[ 612957 ], 6, 1);
    const_str_digest_72b0d4f925b9f004a6696b8da7844b76 = UNSTREAM_STRING_ASCII(&constant_bin[ 612963 ], 14, 0);
    const_str_digest_cf0e60aeef8b8fd92f93cc4479500be7 = UNSTREAM_STRING_ASCII(&constant_bin[ 612977 ], 25, 0);
    const_str_digest_7c5b74be3ada649b49557a7869eb03b9 = UNSTREAM_STRING_ASCII(&constant_bin[ 613002 ], 20, 0);
    const_str_digest_9ea71127940e425419165c8e7548f59f = UNSTREAM_STRING_ASCII(&constant_bin[ 613022 ], 29, 0);
    const_str_digest_bb9045d588645f6e09401dc640cbacf2 = UNSTREAM_STRING_ASCII(&constant_bin[ 613051 ], 37, 0);
    const_str_digest_ab6127a399e734894254eb9c80531bea = UNSTREAM_STRING_ASCII(&constant_bin[ 613088 ], 28, 0);
    const_str_digest_dfc401f7f4274ac522480928076aa127 = UNSTREAM_STRING_ASCII(&constant_bin[ 613116 ], 25, 0);
    const_str_digest_24c4dd15df6ed2447b60cca67615bd7b = UNSTREAM_STRING_ASCII(&constant_bin[ 613141 ], 18, 0);
    const_tuple_str_plain_self_str_plain_album_id_str_plain_trid_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_album_id_str_plain_trid_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_album_id_str_plain_trid_tuple, 1, const_str_plain_album_id); Py_INCREF(const_str_plain_album_id);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_album_id_str_plain_trid_tuple, 2, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_digest_3a6be6041bbd3413cb3fb03eb5d525c3 = UNSTREAM_STRING_ASCII(&constant_bin[ 610330 ], 12, 0);
    const_str_digest_43e37e636612ec263698913cfae18f8d = UNSTREAM_STRING_ASCII(&constant_bin[ 599349 ], 7, 0);
    const_str_digest_fce8e7d40ad236922eb432562db251e4 = UNSTREAM_STRING_ASCII(&constant_bin[ 613159 ], 24, 0);
    const_str_plain_current_user_saved_tracks_contains = UNSTREAM_STRING_ASCII(&constant_bin[ 609765 ], 34, 1);
    const_tuple_str_plain_search_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_search_tuple, 0, const_str_plain_search); Py_INCREF(const_str_plain_search);
    const_str_digest_22f5858d3d743416f99b1d8706361486 = UNSTREAM_STRING_ASCII(&constant_bin[ 613183 ], 147, 0);
    const_str_digest_56394365e919e0b53cf3c29c5a7817fb = UNSTREAM_STRING_ASCII(&constant_bin[ 613330 ], 23, 0);
    const_str_plain_current_user_followed_artists = UNSTREAM_STRING_ASCII(&constant_bin[ 609069 ], 29, 1);
    const_str_digest_764f11a6df082195a71078a86865117a = UNSTREAM_STRING_ASCII(&constant_bin[ 613353 ], 252, 0);
    const_str_digest_fbe05da63d91a0174ef8bf2a7a18534f = UNSTREAM_STRING_ASCII(&constant_bin[ 613605 ], 14, 0);
    const_str_digest_13b574c3ba7ad6187b88b6911cadbc9a = UNSTREAM_STRING_ASCII(&constant_bin[ 613619 ], 411, 0);
    const_str_digest_9edb48669a614c3726ceb81da3fc4901 = UNSTREAM_STRING_ASCII(&constant_bin[ 614030 ], 19, 0);
    const_tuple_str_digest_182a5343dd2556daa4702ebff5e2a31b_tuple = PyTuple_New(1);
    const_str_digest_182a5343dd2556daa4702ebff5e2a31b = UNSTREAM_STRING_ASCII(&constant_bin[ 599346 ], 9, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_182a5343dd2556daa4702ebff5e2a31b_tuple, 0, const_str_digest_182a5343dd2556daa4702ebff5e2a31b); Py_INCREF(const_str_digest_182a5343dd2556daa4702ebff5e2a31b);
    const_str_plain_new_releases = UNSTREAM_STRING_ASCII(&constant_bin[ 613010 ], 12, 1);
    const_str_digest_1e8919abc0a68df77aed3737901ad587 = UNSTREAM_STRING_ASCII(&constant_bin[ 614049 ], 7, 0);
    const_str_digest_14d6f4175da676c87e845226510aa004 = UNSTREAM_STRING_ASCII(&constant_bin[ 614056 ], 21, 0);
    const_tuple_str_plain_US_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_US_tuple, 0, const_str_plain_US); Py_INCREF(const_str_plain_US);
    const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple = PyTuple_New(8);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 2, const_str_plain_playlist_id); Py_INCREF(const_str_plain_playlist_id);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 3, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 4, const_str_plain_snapshot_id); Py_INCREF(const_str_plain_snapshot_id);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 5, const_str_plain_plid); Py_INCREF(const_str_plain_plid);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 6, const_str_plain_ftracks); Py_INCREF(const_str_plain_ftracks);
    PyTuple_SET_ITEM(const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 7, const_str_plain_payload); Py_INCREF(const_str_plain_payload);
    const_str_digest_93fcca36131047b95019094338820d2f = UNSTREAM_STRING_ASCII(&constant_bin[ 614077 ], 156, 0);
    const_str_digest_df5e9278827652f7a7b9ebd1b7a18fde = UNSTREAM_STRING_ASCII(&constant_bin[ 609757 ], 33, 0);
    const_str_digest_b3ecf44f109d34b3e52af7f2f5b62594 = UNSTREAM_STRING_ASCII(&constant_bin[ 614233 ], 103, 0);
    const_str_digest_304ab7a50291c9fae677bb6cb2a9f8c4 = UNSTREAM_STRING_ASCII(&constant_bin[ 614336 ], 35, 0);
    const_str_plain_user_playlist_reorder_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 600440 ], 28, 1);
    const_str_digest_6bda413d1a4d6e15ff4de52373c1a00e = UNSTREAM_STRING_ASCII(&constant_bin[ 614371 ], 18, 0);
    const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple, 1, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple, 2, const_str_plain_id); Py_INCREF(const_str_plain_id);
    PyTuple_SET_ITEM(const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple, 3, const_str_plain_fields); Py_INCREF(const_str_plain_fields);
    const_str_plain_itype = UNSTREAM_STRING_ASCII(&constant_bin[ 614389 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple, 4, const_str_plain_itype); Py_INCREF(const_str_plain_itype);
    const_str_plain_target_ = UNSTREAM_STRING_ASCII(&constant_bin[ 614394 ], 7, 1);
    const_str_digest_704bea8878314747d972920e0987e163 = UNSTREAM_STRING_ASCII(&constant_bin[ 614401 ], 30, 0);
    const_str_digest_41fba648edc091dc1004ac663d8aecf4 = UNSTREAM_STRING_ASCII(&constant_bin[ 614431 ], 144, 0);
    const_str_plain_recommendation_genre_seeds = UNSTREAM_STRING_ASCII(&constant_bin[ 602494 ], 26, 1);
    const_str_plain__get_uri = UNSTREAM_STRING_ASCII(&constant_bin[ 614575 ], 8, 1);
    const_str_digest_147b8574c689a39dd3e1208a7a6f7a89 = UNSTREAM_STRING_ASCII(&constant_bin[ 614583 ], 244, 0);
    const_str_digest_d50c5bd1c8d54069535879650ef443a5 = UNSTREAM_STRING_ASCII(&constant_bin[ 614827 ], 222, 0);
    const_str_digest_066f6638a3c907c0e5cd1174d5ace6b8 = UNSTREAM_STRING_ASCII(&constant_bin[ 615049 ], 266, 0);
    const_str_digest_4b2c8ed8fa5094614f7604f6c34e95fa = UNSTREAM_STRING_ASCII(&constant_bin[ 615315 ], 16, 0);
    const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple = PyTuple_New(7);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 1, const_str_plain_artist_id); Py_INCREF(const_str_plain_artist_id);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 2, const_str_plain_album_type); Py_INCREF(const_str_plain_album_type);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 3, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 4, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 5, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 6, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_plain_current_user_saved_albums = UNSTREAM_STRING_ASCII(&constant_bin[ 598851 ], 25, 1);
    const_str_digest_188a1166bacfa060b47e8694a15a3090 = UNSTREAM_STRING_ASCII(&constant_bin[ 615331 ], 526, 0);
    const_tuple_str_plain_min__str_plain_max__str_plain_target__tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_min__str_plain_max__str_plain_target__tuple, 0, const_str_plain_min_); Py_INCREF(const_str_plain_min_);
    const_str_plain_max_ = UNSTREAM_STRING_ASCII(&constant_bin[ 16906 ], 4, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_min__str_plain_max__str_plain_target__tuple, 1, const_str_plain_max_); Py_INCREF(const_str_plain_max_);
    PyTuple_SET_ITEM(const_tuple_str_plain_min__str_plain_max__str_plain_target__tuple, 2, const_str_plain_target_); Py_INCREF(const_str_plain_target_);
    const_str_digest_461572c4c90bffa6a73b81c05396465c = UNSTREAM_STRING_ASCII(&constant_bin[ 615857 ], 554, 0);
    const_str_digest_01799024cb32c197cee13a1245d6fb67 = UNSTREAM_STRING_ASCII(&constant_bin[ 598950 ], 16, 0);
    const_str_digest_131c4d8f12787eb624dbe9d8626d17ce = UNSTREAM_STRING_ASCII(&constant_bin[ 616411 ], 114, 0);
    const_str_plain_audio_features = UNSTREAM_STRING_ASCII(&constant_bin[ 608290 ], 14, 1);
    const_str_plain_previous = UNSTREAM_STRING_ASCII(&constant_bin[ 92262 ], 8, 1);
    const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 1, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 2, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_str_digest_5a0f1de4f1f7388aa7e656e8bcb182b9 = UNSTREAM_STRING_ASCII(&constant_bin[ 616525 ], 21, 0);
    const_str_digest_52a058966bc59abea536c1108c5ed4b1 = UNSTREAM_STRING_ASCII(&constant_bin[ 616546 ], 355, 0);
    const_str_digest_b44ed5b039ecf981522aec07f6a4ce6f = UNSTREAM_STRING_ASCII(&constant_bin[ 616901 ], 42, 0);
    const_tuple_682b992cd17b43443c5763aa401a1636_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_682b992cd17b43443c5763aa401a1636_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_682b992cd17b43443c5763aa401a1636_tuple, 1, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_682b992cd17b43443c5763aa401a1636_tuple, 2, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_682b992cd17b43443c5763aa401a1636_tuple, 3, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_tuple_str_plain_recommendations_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_plain_recommendations_tuple, 0, const_str_plain_recommendations); Py_INCREF(const_str_plain_recommendations);
    const_tuple_str_digest_5787669024b1126d33f548eee9dfba27_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_5787669024b1126d33f548eee9dfba27_tuple, 0, const_str_digest_5787669024b1126d33f548eee9dfba27); Py_INCREF(const_str_digest_5787669024b1126d33f548eee9dfba27);
    const_str_plain__build_session = UNSTREAM_STRING_ASCII(&constant_bin[ 609021 ], 14, 1);
    const_str_digest_f0e0d92a883a0d37afc5c36db66989d0 = UNSTREAM_STRING_ASCII(&constant_bin[ 616943 ], 25, 0);
    const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 1, const_str_plain_q); Py_INCREF(const_str_plain_q);
    PyTuple_SET_ITEM(const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 2, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 3, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 4, const_str_plain_type); Py_INCREF(const_str_plain_type);
    PyTuple_SET_ITEM(const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 5, const_str_plain_market); Py_INCREF(const_str_plain_market);
    const_str_digest_bd0f2b232e10978ffc7d0f9d3001ad87 = UNSTREAM_STRING_ASCII(&constant_bin[ 616968 ], 277, 0);
    const_str_digest_7a15e76af9258d39e881ccef235c8981 = UNSTREAM_STRING_ASCII(&constant_bin[ 617245 ], 36, 0);
    const_str_digest_2a2c2ba43f4eedfd2d13747c6caa8b25 = UNSTREAM_STRING_ASCII(&constant_bin[ 617281 ], 141, 0);
    const_str_digest_ec2e7cf9c1786efb908b0c0f264590c3 = UNSTREAM_STRING_ASCII(&constant_bin[ 617422 ], 74, 0);
    const_str_digest_2973be41c7df6ecef1d423c6cbae5728 = UNSTREAM_STRING_ASCII(&constant_bin[ 617496 ], 1020, 0);
    const_str_digest_f73af7c71e1dcd5503718d51f23de060 = UNSTREAM_STRING_ASCII(&constant_bin[ 608107 ], 14, 0);
    const_str_plain_device_ids = UNSTREAM_STRING_ASCII(&constant_bin[ 618516 ], 10, 1);
    const_str_digest_f3bd18c4e4dfe3b238c61f74d4197ffd = UNSTREAM_STRING_ASCII(&constant_bin[ 609686 ], 51, 1);
    const_str_digest_5be1b56c4c0b8911c4aba922d20a0188 = UNSTREAM_STRING_ASCII(&constant_bin[ 618526 ], 25, 0);
    const_str_plain_current_user_playing_track = UNSTREAM_STRING_ASCII(&constant_bin[ 602915 ], 26, 1);
    const_tuple_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9_tuple, 0, const_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9); Py_INCREF(const_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9);
    const_str_digest_1edf7ef291a6d2f13ad21e7a038ba6db = UNSTREAM_STRING_ASCII(&constant_bin[ 618551 ], 575, 0);
    const_str_digest_0a31963364057b0f70b283146476706a = UNSTREAM_STRING_ASCII(&constant_bin[ 619126 ], 18, 0);
    const_str_digest_a3c47fe9db46a4cbfc5719fa2ef262a7 = UNSTREAM_STRING_ASCII(&constant_bin[ 619144 ], 194, 0);
    const_str_plain_current_user_saved_albums_contains = UNSTREAM_STRING_ASCII(&constant_bin[ 616909 ], 34, 1);
    const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple, 1, const_str_plain_country); Py_INCREF(const_str_plain_country);
    PyTuple_SET_ITEM(const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple, 2, const_str_plain_locale); Py_INCREF(const_str_plain_locale);
    PyTuple_SET_ITEM(const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple, 3, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple, 4, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    const_str_digest_d8013f6ad51769ccfee3dd58bb3f0652 = UNSTREAM_STRING_ASCII(&constant_bin[ 619338 ], 451, 0);
    const_str_digest_4c586604e0e933a3b0da727a9d982d51 = UNSTREAM_STRING_ASCII(&constant_bin[ 619789 ], 348, 0);
    const_str_plain_speechiness = UNSTREAM_STRING_ASCII(&constant_bin[ 620137 ], 11, 1);
    const_str_digest_00fb433b6c8f8c4e9d59bd70cd5fee15 = UNSTREAM_STRING_ASCII(&constant_bin[ 620148 ], 179, 0);
    const_tuple_2c14864855545e1854bee3fef626583e_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_2c14864855545e1854bee3fef626583e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_2c14864855545e1854bee3fef626583e_tuple, 1, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_str_plain_force_play = UNSTREAM_STRING_ASCII(&constant_bin[ 616794 ], 10, 1);
    PyTuple_SET_ITEM(const_tuple_2c14864855545e1854bee3fef626583e_tuple, 2, const_str_plain_force_play); Py_INCREF(const_str_plain_force_play);
    PyTuple_SET_ITEM(const_tuple_2c14864855545e1854bee3fef626583e_tuple, 3, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_str_digest_8778ffeefebf38a1b121e70d438be59e = UNSTREAM_STRING_ASCII(&constant_bin[ 620327 ], 13, 0);
    const_tuple_str_plain_self_str_plain_token_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_token_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_token_tuple, 1, const_str_plain_token); Py_INCREF(const_str_plain_token);
    const_str_digest_1e83f61e759b7fbea9a801cec29b5024 = UNSTREAM_STRING(&constant_bin[ 620340 ], 207, 0);
    const_str_digest_143a93a582706d71ac985cd217d846c8 = UNSTREAM_STRING_ASCII(&constant_bin[ 620547 ], 53, 0);
    const_tuple_str_plain_t_str_plain_self_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_t_str_plain_self_tuple, 0, const_str_plain_t); Py_INCREF(const_str_plain_t);
    PyTuple_SET_ITEM(const_tuple_str_plain_t_str_plain_self_tuple, 1, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_tuple_str_digest_12c7255d70fc5dcdbef99c54e18933c6_tuple = PyTuple_New(1);
    const_str_digest_12c7255d70fc5dcdbef99c54e18933c6 = UNSTREAM_STRING_ASCII(&constant_bin[ 599449 ], 9, 0);
    PyTuple_SET_ITEM(const_tuple_str_digest_12c7255d70fc5dcdbef99c54e18933c6_tuple, 0, const_str_digest_12c7255d70fc5dcdbef99c54e18933c6); Py_INCREF(const_str_digest_12c7255d70fc5dcdbef99c54e18933c6);
    const_str_plain__append_device_id = UNSTREAM_STRING_ASCII(&constant_bin[ 608858 ], 17, 1);
    const_str_digest_787903cd874d847847a2eb2ef416f6c3 = UNSTREAM_STRING_ASCII(&constant_bin[ 620600 ], 131, 0);
    const_str_digest_329cc980f9b9d0864824ea93bbfb8a73 = UNSTREAM_STRING_ASCII(&constant_bin[ 620731 ], 534, 0);
    const_tuple_149384ac75bf30697541a03a2af20cf7_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_149384ac75bf30697541a03a2af20cf7_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_149384ac75bf30697541a03a2af20cf7_tuple, 1, const_str_plain_limit); Py_INCREF(const_str_plain_limit);
    PyTuple_SET_ITEM(const_tuple_149384ac75bf30697541a03a2af20cf7_tuple, 2, const_str_plain_offset); Py_INCREF(const_str_plain_offset);
    PyTuple_SET_ITEM(const_tuple_149384ac75bf30697541a03a2af20cf7_tuple, 3, const_str_plain_time_range); Py_INCREF(const_str_plain_time_range);
    const_str_digest_32a4ae71788e298e6b9dd987b7a52688 = UNSTREAM_STRING_ASCII(&constant_bin[ 621265 ], 253, 0);
    const_str_plain_pause_playback = UNSTREAM_STRING_ASCII(&constant_bin[ 621518 ], 14, 1);
    const_str_digest_f79216834977c09ad46a369d9c09854c = UNSTREAM_STRING_ASCII(&constant_bin[ 621532 ], 280, 0);
    const_tuple_str_plain_self_str_plain_artists_str_plain_tlist_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_artists_str_plain_tlist_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_artists_str_plain_tlist_tuple, 1, const_str_plain_artists); Py_INCREF(const_str_plain_artists);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_artists_str_plain_tlist_tuple, 2, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_str_digest_51757cba85587a91188620a63866ff3b = UNSTREAM_STRING_ASCII(&constant_bin[ 621812 ], 31, 0);
    const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple = PyTuple_New(14);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 0, const_str_plain_acousticness); Py_INCREF(const_str_plain_acousticness);
    const_str_plain_danceability = UNSTREAM_STRING_ASCII(&constant_bin[ 621843 ], 12, 1);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 1, const_str_plain_danceability); Py_INCREF(const_str_plain_danceability);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 2, const_str_plain_duration_ms); Py_INCREF(const_str_plain_duration_ms);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 3, const_str_plain_energy); Py_INCREF(const_str_plain_energy);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 4, const_str_plain_instrumentalness); Py_INCREF(const_str_plain_instrumentalness);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 5, const_str_plain_key); Py_INCREF(const_str_plain_key);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 6, const_str_plain_liveness); Py_INCREF(const_str_plain_liveness);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 7, const_str_plain_loudness); Py_INCREF(const_str_plain_loudness);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 8, const_str_plain_mode); Py_INCREF(const_str_plain_mode);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 9, const_str_plain_popularity); Py_INCREF(const_str_plain_popularity);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 10, const_str_plain_speechiness); Py_INCREF(const_str_plain_speechiness);
    const_str_plain_tempo = UNSTREAM_STRING_ASCII(&constant_bin[ 585097 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 11, const_str_plain_tempo); Py_INCREF(const_str_plain_tempo);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 12, const_str_plain_time_signature); Py_INCREF(const_str_plain_time_signature);
    PyTuple_SET_ITEM(const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple, 13, const_str_plain_valence); Py_INCREF(const_str_plain_valence);
    const_str_digest_d8a87e891106f59734dd2f86091ec954 = UNSTREAM_STRING_ASCII(&constant_bin[ 621855 ], 571, 0);
    const_str_plain_user_playlist_is_following = UNSTREAM_STRING_ASCII(&constant_bin[ 599289 ], 26, 1);
    const_tuple_none_none_none_int_pos_20_int_0_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_int_0_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_int_0_tuple, 1, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_int_0_tuple, 2, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_int_0_tuple, 3, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_20_int_0_tuple, 4, const_int_0); Py_INCREF(const_int_0);
    const_tuple_str_digest_7475ac184a2aa6f3857bca677c46863f_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_7475ac184a2aa6f3857bca677c46863f_tuple, 0, const_str_digest_7475ac184a2aa6f3857bca677c46863f); Py_INCREF(const_str_digest_7475ac184a2aa6f3857bca677c46863f);
    const_tuple_none_none_int_pos_20_int_0_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_none_none_int_pos_20_int_0_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_int_pos_20_int_0_tuple, 1, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_int_pos_20_int_0_tuple, 2, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_none_none_int_pos_20_int_0_tuple, 3, const_int_0); Py_INCREF(const_int_0);
    const_str_digest_1a4d1829bf809cce5d46da7256560962 = UNSTREAM_STRING_ASCII(&constant_bin[ 599348 ], 7, 0);
    const_str_digest_1efba7d43fe6a9ddb536f5135ef1050e = UNSTREAM_STRING_ASCII(&constant_bin[ 622426 ], 176, 0);
    const_tuple_fe00d07b498f378d886063a767afe437_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_fe00d07b498f378d886063a767afe437_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_fe00d07b498f378d886063a767afe437_tuple, 1, const_str_plain_episodes); Py_INCREF(const_str_plain_episodes);
    PyTuple_SET_ITEM(const_tuple_fe00d07b498f378d886063a767afe437_tuple, 2, const_str_plain_market); Py_INCREF(const_str_plain_market);
    PyTuple_SET_ITEM(const_tuple_fe00d07b498f378d886063a767afe437_tuple, 3, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_str_plain_user_playlist_follow_playlist = UNSTREAM_STRING_ASCII(&constant_bin[ 613059 ], 29, 1);
    const_str_digest_7af1b86e99338fd4edc6b03cce965252 = UNSTREAM_STRING_ASCII(&constant_bin[ 622602 ], 13, 0);
    const_str_plain_playlist_upload_cover_image = UNSTREAM_STRING_ASCII(&constant_bin[ 614344 ], 27, 1);
    const_str_digest_32e139cf9c005363a7161616e92f1a08 = UNSTREAM_STRING_ASCII(&constant_bin[ 622615 ], 47, 0);
    const_str_plain_set_auth = UNSTREAM_STRING_ASCII(&constant_bin[ 610319 ], 8, 1);
    const_str_digest_c756b049a62b03e8fe36ada60a54a03e = UNSTREAM_STRING_ASCII(&constant_bin[ 622662 ], 12, 0);
    const_str_digest_beb9b463b31c02c01059bbfe0eabf6bb = UNSTREAM_STRING_ASCII(&constant_bin[ 622674 ], 14, 0);
    const_tuple_str_plain_self_str_plain_position_ms_str_plain_device_id_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_position_ms_str_plain_device_id_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_position_ms_str_plain_device_id_tuple, 1, const_str_plain_position_ms); Py_INCREF(const_str_plain_position_ms);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_position_ms_str_plain_device_id_tuple, 2, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    const_tuple_none_none_none_int_pos_100_int_0_none_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_100_int_0_none_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_100_int_0_none_tuple, 1, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_100_int_0_none_tuple, 2, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_100_int_0_none_tuple, 3, const_int_pos_100); Py_INCREF(const_int_pos_100);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_100_int_0_none_tuple, 4, const_int_0); Py_INCREF(const_int_0);
    PyTuple_SET_ITEM(const_tuple_none_none_none_int_pos_100_int_0_none_tuple, 5, Py_None); Py_INCREF(Py_None);
    const_tuple_int_pos_50_int_0_none_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_int_0_none_tuple, 0, const_int_pos_50); Py_INCREF(const_int_pos_50);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_int_0_none_tuple, 1, const_int_0); Py_INCREF(const_int_0);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_int_0_none_tuple, 2, Py_None); Py_INCREF(Py_None);
    const_str_digest_43404de583c5367e36ea771b97f2561a = UNSTREAM_STRING_ASCII(&constant_bin[ 622688 ], 13, 0);
    const_str_plain_current_user_saved_tracks_add = UNSTREAM_STRING_ASCII(&constant_bin[ 609807 ], 29, 1);
    const_str_plain_current_user_saved_shows_delete = UNSTREAM_STRING_ASCII(&constant_bin[ 602949 ], 31, 1);
    const_str_plain_artist_related_artists = UNSTREAM_STRING_ASCII(&constant_bin[ 622701 ], 22, 1);
    const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple, 1, const_str_plain_shows); Py_INCREF(const_str_plain_shows);
    const_str_plain_slist = UNSTREAM_STRING_ASCII(&constant_bin[ 622723 ], 5, 1);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple, 2, const_str_plain_slist); Py_INCREF(const_str_plain_slist);
    const_str_digest_1a1f42c161bd7332ead3228a329cb87a = UNSTREAM_STRING_ASCII(&constant_bin[ 622728 ], 219, 0);
    const_str_digest_b21dca84fcf4e8562e492b36f54e621b = UNSTREAM_STRING_ASCII(&constant_bin[ 622947 ], 40, 0);
    const_str_digest_b89a24c0a3cc4571b4b02536ba3d2fd4 = UNSTREAM_STRING_ASCII(&constant_bin[ 622987 ], 22, 0);
    const_str_digest_8162ab5fc511821afe1608ebaabcc365 = UNSTREAM_STRING_ASCII(&constant_bin[ 623009 ], 560, 0);
    const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple, 1, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple, 2, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_tuple_int_pos_50_int_0_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_int_0_tuple, 0, const_int_pos_50); Py_INCREF(const_int_pos_50);
    PyTuple_SET_ITEM(const_tuple_int_pos_50_int_0_tuple, 1, const_int_0); Py_INCREF(const_int_0);
    const_str_digest_231f278518e15360f0e83a2b4f233662 = UNSTREAM_STRING_ASCII(&constant_bin[ 623569 ], 10, 0);
    const_str_digest_e58eec2a5ea585c2c4db40f39721d451 = UNSTREAM_STRING_ASCII(&constant_bin[ 595683 ], 10, 0);
    const_str_digest_cd1fee3b799518143086c98a6701773c = UNSTREAM_STRING_ASCII(&constant_bin[ 623579 ], 342, 0);
    const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple, 1, const_str_plain_uri); Py_INCREF(const_str_plain_uri);
    PyTuple_SET_ITEM(const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple, 2, const_str_plain_device_id); Py_INCREF(const_str_plain_device_id);
    PyTuple_SET_ITEM(const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple, 3, const_str_plain_endpoint); Py_INCREF(const_str_plain_endpoint);
    const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple, 1, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple, 2, const_str_plain_market); Py_INCREF(const_str_plain_market);
    PyTuple_SET_ITEM(const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple, 3, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_str_plain_start_playback = UNSTREAM_STRING_ASCII(&constant_bin[ 623921 ], 14, 1);
    const_str_plain_user_unfollow_users = UNSTREAM_STRING_ASCII(&constant_bin[ 607959 ], 19, 1);
    const_str_digest_b2eef765f8c5abb067a011988de44235 = UNSTREAM_STRING_ASCII(&constant_bin[ 623935 ], 160, 0);
    const_str_digest_c2cb8cbc6b1b5e281950e97a3fe1622b = UNSTREAM_STRING_ASCII(&constant_bin[ 602029 ], 11, 0);
    const_str_digest_c9db8737dfcddf87703a20dae86d6cc6 = UNSTREAM_STRING_ASCII(&constant_bin[ 624095 ], 13, 0);
    const_str_plain_current_user_saved_shows_add = UNSTREAM_STRING_ASCII(&constant_bin[ 602680 ], 28, 1);
    const_str_digest_4cd2fe7e56ff8b75b38406398ccf5849 = UNSTREAM_STRING_ASCII(&constant_bin[ 624108 ], 22, 0);
    const_str_digest_3fad55d9b16e5e6483c31abe09170773 = UNSTREAM_STRING_ASCII(&constant_bin[ 624130 ], 256, 0);
    const_str_plain_current_user_top_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 624386 ], 23, 1);
    const_str_digest_ba8367de31b2273f9e2a709972d2a97c = UNSTREAM_STRING_ASCII(&constant_bin[ 624409 ], 22, 0);
    const_str_digest_fce43981ff247be47ab0a78bb306a831 = UNSTREAM_STRING_ASCII(&constant_bin[ 624431 ], 31, 0);
    const_str_digest_7a2c470ea5f10c23533f984d841d174e = UNSTREAM_STRING_ASCII(&constant_bin[ 602029 ], 6, 0);
    const_str_plain_positions = UNSTREAM_STRING_ASCII(&constant_bin[ 603866 ], 9, 1);
    const_str_digest_a9e497a69e6698a5ac0200bc3be01588 = UNSTREAM_STRING_ASCII(&constant_bin[ 624462 ], 92, 0);
    const_tuple_int_pos_20_none_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_none_tuple, 0, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_none_tuple, 1, Py_None); Py_INCREF(Py_None);
    const_float_0_3 = UNSTREAM_FLOAT(&constant_bin[ 624554 ]);
    const_str_digest_85b964c01ed70f92a87af7b95815e594 = UNSTREAM_STRING_ASCII(&constant_bin[ 624562 ], 142, 0);
    const_tuple_str_digest_5090487500dd71ff8ac64eb8e9322d70_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_5090487500dd71ff8ac64eb8e9322d70_tuple, 0, const_str_digest_5090487500dd71ff8ac64eb8e9322d70); Py_INCREF(const_str_digest_5090487500dd71ff8ac64eb8e9322d70);
    const_str_plain_user_playlist_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 613096 ], 20, 1);
    const_str_digest_ffa0992fc3e937316133dc1511c1babb = UNSTREAM_STRING_ASCII(&constant_bin[ 624704 ], 20, 0);
    const_tuple_none_none_tuple_str_plain_track_tuple_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_none_none_tuple_str_plain_track_tuple_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_tuple_str_plain_track_tuple_tuple, 1, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_none_tuple_str_plain_track_tuple_tuple, 2, const_tuple_str_plain_track_tuple); Py_INCREF(const_tuple_str_plain_track_tuple);
    const_str_digest_ddf63d8e67c74433202126d85f63720d = UNSTREAM_STRING_ASCII(&constant_bin[ 624724 ], 32, 0);
    const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 1, const_str_plain_user); Py_INCREF(const_str_plain_user);
    PyTuple_SET_ITEM(const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 2, const_str_plain_name); Py_INCREF(const_str_plain_name);
    PyTuple_SET_ITEM(const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 3, const_str_plain_public); Py_INCREF(const_str_plain_public);
    PyTuple_SET_ITEM(const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 4, const_str_plain_description); Py_INCREF(const_str_plain_description);
    PyTuple_SET_ITEM(const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 5, const_str_plain_data); Py_INCREF(const_str_plain_data);
    const_tuple_str_plain_a_str_plain_self_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_a_str_plain_self_tuple, 0, const_str_plain_a); Py_INCREF(const_str_plain_a);
    PyTuple_SET_ITEM(const_tuple_str_plain_a_str_plain_self_tuple, 1, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_digest_08fa1fbd4fd8fbd433259816d4c0fd80 = UNSTREAM_STRING_ASCII(&constant_bin[ 614371 ], 12, 0);
    const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 1, const_str_plain_url); Py_INCREF(const_str_plain_url);
    PyTuple_SET_ITEM(const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 2, const_str_plain_args); Py_INCREF(const_str_plain_args);
    PyTuple_SET_ITEM(const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 3, const_str_plain_payload); Py_INCREF(const_str_plain_payload);
    PyTuple_SET_ITEM(const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 4, const_str_plain_kwargs); Py_INCREF(const_str_plain_kwargs);
    const_str_digest_f416654f39bbd99bbde9721618eb36fd = UNSTREAM_STRING_ASCII(&constant_bin[ 624756 ], 49, 0);
    const_tuple_str_digest_5b506f304dd8229333e7f1c8eeb8465b_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_5b506f304dd8229333e7f1c8eeb8465b_tuple, 0, const_str_digest_5b506f304dd8229333e7f1c8eeb8465b); Py_INCREF(const_str_digest_5b506f304dd8229333e7f1c8eeb8465b);
    const_str_digest_14aa8f39ae92cdfa19768e4e257f6ad7 = UNSTREAM_STRING_ASCII(&constant_bin[ 624805 ], 11, 0);
    const_tuple_str_digest_5d829d81793681107bd9dec71adcd753_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_5d829d81793681107bd9dec71adcd753_tuple, 0, const_str_digest_5d829d81793681107bd9dec71adcd753); Py_INCREF(const_str_digest_5d829d81793681107bd9dec71adcd753);
    const_str_digest_eef54eb775249e83f1addd1b51ffa30a = UNSTREAM_STRING_ASCII(&constant_bin[ 624816 ], 28, 0);
    const_str_digest_22b1054355e50899c6bf88a5e7c14b90 = UNSTREAM_STRING_ASCII(&constant_bin[ 624844 ], 15, 0);
    const_str_plain_add_to_queue = UNSTREAM_STRING_ASCII(&constant_bin[ 608792 ], 12, 1);
    const_str_digest_bb4c36c3f1ee6d15e5217090585577d5 = UNSTREAM_STRING_ASCII(&constant_bin[ 624859 ], 675, 0);
    const_str_digest_f309ed4485e7bd297d91d86c0feee8f3 = UNSTREAM_STRING_ASCII(&constant_bin[ 625534 ], 114, 0);
    const_str_plain_current_playback = UNSTREAM_STRING_ASCII(&constant_bin[ 613167 ], 16, 1);
    const_str_digest_72c39d9a88a6b461c157aee4ce2cc943 = UNSTREAM_STRING_ASCII(&constant_bin[ 625648 ], 40, 0);
    const_str_digest_1e1ba398d96e94b69ce683dfb2e1f429 = UNSTREAM_STRING_ASCII(&constant_bin[ 625688 ], 16, 0);
    const_str_digest_410a71fafeb675394fe1eff0fefe1fca = UNSTREAM_STRING_ASCII(&constant_bin[ 599281 ], 12, 0);
    const_str_digest_2eaee9335e32606751b873994e96fd80 = UNSTREAM_STRING_ASCII(&constant_bin[ 625704 ], 145, 0);
    const_str_digest_e20746e27b808631c68a7de73dcbf7e4 = UNSTREAM_STRING_ASCII(&constant_bin[ 609737 ], 13, 0);
    const_str_digest_7b3c05a139c5aea99aa8643803da85a9 = UNSTREAM_STRING_ASCII(&constant_bin[ 625849 ], 174, 0);
    const_str_digest_5a23bff0529b8d304971c75ac5c0c642 = UNSTREAM_STRING_ASCII(&constant_bin[ 626023 ], 158, 0);
    const_str_digest_19eeb686661d8ef9861c731891632dbe = UNSTREAM_STRING_ASCII(&constant_bin[ 626181 ], 43, 0);
    const_str_digest_66a2e17c5d838acae507a0388b923c91 = UNSTREAM_STRING_ASCII(&constant_bin[ 626224 ], 676, 0);
    const_tuple_str_digest_6c9e8a9e157453a28103d4c0f15c86e1_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_6c9e8a9e157453a28103d4c0f15c86e1_tuple, 0, const_str_digest_6c9e8a9e157453a28103d4c0f15c86e1); Py_INCREF(const_str_digest_6c9e8a9e157453a28103d4c0f15c86e1);
    const_str_digest_13224bc18feb1ba01c2cde37d88d6b18 = UNSTREAM_STRING_ASCII(&constant_bin[ 626900 ], 13, 0);
    const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple, 1, const_str_plain_episode_id); Py_INCREF(const_str_plain_episode_id);
    PyTuple_SET_ITEM(const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple, 2, const_str_plain_market); Py_INCREF(const_str_plain_market);
    PyTuple_SET_ITEM(const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple, 3, const_str_plain_trid); Py_INCREF(const_str_plain_trid);
    const_str_digest_424fcad737c334bc0999dd054930c345 = UNSTREAM_STRING_ASCII(&constant_bin[ 626913 ], 10, 0);
    const_tuple_069764dd8c1ec01972656675304328c5_tuple = PyTuple_New(4);
    PyTuple_SET_ITEM(const_tuple_069764dd8c1ec01972656675304328c5_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_069764dd8c1ec01972656675304328c5_tuple, 1, const_str_plain_shows); Py_INCREF(const_str_plain_shows);
    PyTuple_SET_ITEM(const_tuple_069764dd8c1ec01972656675304328c5_tuple, 2, const_str_plain_market); Py_INCREF(const_str_plain_market);
    PyTuple_SET_ITEM(const_tuple_069764dd8c1ec01972656675304328c5_tuple, 3, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_str_digest_bf9d8f637e1f805885861297c4fd2e7b = UNSTREAM_STRING_ASCII(&constant_bin[ 626923 ], 15, 0);
    const_str_digest_2426d2d37163dd769cdef1fa7ba0a966 = UNSTREAM_STRING_ASCII(&constant_bin[ 610063 ], 15, 0);
    const_str_digest_9254db74895e65fc859713643b2ed8ae = UNSTREAM_STRING_ASCII(&constant_bin[ 626938 ], 25, 0);
    const_list_str_plain_track_str_plain_context_str_plain_off_list = PyList_New(3);
    PyList_SET_ITEM(const_list_str_plain_track_str_plain_context_str_plain_off_list, 0, const_str_plain_track); Py_INCREF(const_str_plain_track);
    PyList_SET_ITEM(const_list_str_plain_track_str_plain_context_str_plain_off_list, 1, const_str_plain_context); Py_INCREF(const_str_plain_context);
    PyList_SET_ITEM(const_list_str_plain_track_str_plain_context_str_plain_off_list, 2, const_str_plain_off); Py_INCREF(const_str_plain_off);
    const_tuple_str_digest_c8dd3e40bf7394768822193fde87cb0c_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_c8dd3e40bf7394768822193fde87cb0c_tuple, 0, const_str_digest_c8dd3e40bf7394768822193fde87cb0c); Py_INCREF(const_str_digest_c8dd3e40bf7394768822193fde87cb0c);
    const_str_digest_f82a2299550c18805d7c9a6deebb5f8b = UNSTREAM_STRING_ASCII(&constant_bin[ 626963 ], 20, 0);
    const_str_digest_5e2d0d309d6799d2b2500c57eb38e379 = UNSTREAM_STRING_ASCII(&constant_bin[ 599281 ], 21, 0);
    const_str_digest_7bdf7f5f2cee1538c772082d0885025f = UNSTREAM_STRING_ASCII(&constant_bin[ 626983 ], 443, 0);
    const_str_digest_19ca16d6b65b3385e7e95a982e32ddeb = UNSTREAM_STRING_ASCII(&constant_bin[ 627426 ], 133, 0);
    const_tuple_str_digest_dfc401f7f4274ac522480928076aa127_tuple = PyTuple_New(1);
    PyTuple_SET_ITEM(const_tuple_str_digest_dfc401f7f4274ac522480928076aa127_tuple, 0, const_str_digest_dfc401f7f4274ac522480928076aa127); Py_INCREF(const_str_digest_dfc401f7f4274ac522480928076aa127);
    const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple, 0, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple, 1, const_int_pos_100); Py_INCREF(const_int_pos_100);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple, 2, const_int_0); Py_INCREF(const_int_0);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple, 3, Py_None); Py_INCREF(Py_None);
    PyTuple_SET_ITEM(const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple, 4, const_tuple_str_plain_track_tuple); Py_INCREF(const_tuple_str_plain_track_tuple);
    const_str_digest_fcff0159a761cd6996e868984e5eb286 = UNSTREAM_STRING_ASCII(&constant_bin[ 627559 ], 14, 0);
    const_str_digest_98b1ec6a4ee97b8abcc611c4f94337a4 = UNSTREAM_STRING_ASCII(&constant_bin[ 627573 ], 58, 0);
    const_tuple_11a6319e07aa050aed810c998ea37058_tuple = PyTuple_New(5);
    PyTuple_SET_ITEM(const_tuple_11a6319e07aa050aed810c998ea37058_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_11a6319e07aa050aed810c998ea37058_tuple, 1, const_str_plain_tracks); Py_INCREF(const_str_plain_tracks);
    PyTuple_SET_ITEM(const_tuple_11a6319e07aa050aed810c998ea37058_tuple, 2, const_str_plain_trackid); Py_INCREF(const_str_plain_trackid);
    PyTuple_SET_ITEM(const_tuple_11a6319e07aa050aed810c998ea37058_tuple, 3, const_str_plain_results); Py_INCREF(const_str_plain_results);
    PyTuple_SET_ITEM(const_tuple_11a6319e07aa050aed810c998ea37058_tuple, 4, const_str_plain_tlist); Py_INCREF(const_str_plain_tlist);
    const_str_plain_user_playlist_add_tracks = UNSTREAM_STRING_ASCII(&constant_bin[ 624732 ], 24, 1);
    const_str_digest_879242dc41bf721b411af8e2247307b4 = UNSTREAM_STRING_ASCII(&constant_bin[ 627631 ], 341, 0);
    const_str_digest_d7ab0864ba2818d4a280416965102e06 = UNSTREAM_STRING_ASCII(&constant_bin[ 627972 ], 30, 0);
    const_str_plain__auth_headers = UNSTREAM_STRING_ASCII(&constant_bin[ 616533 ], 13, 1);
    const_str_plain_show_episodes = UNSTREAM_STRING_ASCII(&constant_bin[ 614064 ], 13, 1);
    const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple = PyTuple_New(3);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple, 0, const_int_pos_20); Py_INCREF(const_int_pos_20);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple, 1, const_int_0); Py_INCREF(const_int_0);
    PyTuple_SET_ITEM(const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple, 2, const_str_plain_medium_term); Py_INCREF(const_str_plain_medium_term);
    const_str_digest_d8d7e79085a29dc1ccf4d3c139ad694e = UNSTREAM_STRING_ASCII(&constant_bin[ 628002 ], 54, 0);
    const_tuple_str_plain_tid_str_plain_self_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_tid_str_plain_self_tuple, 0, const_str_plain_tid); Py_INCREF(const_str_plain_tid);
    PyTuple_SET_ITEM(const_tuple_str_plain_tid_str_plain_self_tuple, 1, const_str_plain_self); Py_INCREF(const_str_plain_self);
    const_str_digest_875010cc3f8d07790f010cc5f17820c8 = UNSTREAM_STRING_ASCII(&constant_bin[ 628056 ], 171, 0);
    const_str_digest_e778dc668e45ddcafe4d67d943148e2d = UNSTREAM_STRING_ASCII(&constant_bin[ 628227 ], 28, 0);
    const_str_digest_2774574c30cb390537d18eadfb6194c4 = UNSTREAM_STRING_ASCII(&constant_bin[ 628255 ], 423, 0);
    const_tuple_str_plain_self_str_plain_auth_tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_auth_tuple, 0, const_str_plain_self); Py_INCREF(const_str_plain_self);
    PyTuple_SET_ITEM(const_tuple_str_plain_self_str_plain_auth_tuple, 1, const_str_plain_auth); Py_INCREF(const_str_plain_auth);

    constants_created = true;
}

/* Function to verify module private constants for non-corruption. */
#ifndef __NUITKA_NO_ASSERT__
void checkModuleConstants_spotipy$client(void) {
    // The module may not have been used at all, then ignore this.
    if (constants_created == false) return;


}
#endif

// The module code objects.
static PyCodeObject *codeobj_6fbd9f0268750b41e458dd0b93defaa8;
static PyCodeObject *codeobj_12b493fa58299085ea49015dfa1e4296;
static PyCodeObject *codeobj_dc46bea2e1fc1b5ddb719d7050173072;
static PyCodeObject *codeobj_efe41bc1c089bb53bb12793c18870fbd;
static PyCodeObject *codeobj_dfa67eee91fa81af058566081de7dad5;
static PyCodeObject *codeobj_ff403a14643d9f44c988823fbe0ecdaf;
static PyCodeObject *codeobj_0c896c01aacc838fc67aa18df394c175;
static PyCodeObject *codeobj_2f0e82d85089746fa7bf708e34483a0f;
static PyCodeObject *codeobj_b4e5fc01de25d83cb1f9b8c6e90e2392;
static PyCodeObject *codeobj_fe241e4894e4a0c9becdd4bc6600c26d;
static PyCodeObject *codeobj_2e404164e29148f30f48039278898bad;
static PyCodeObject *codeobj_ccb5f13133b0dfbba91f076d61030295;
static PyCodeObject *codeobj_8f657b6a02f36cc5275fe109975cdb9f;
static PyCodeObject *codeobj_e9748f74fbae27652dd60c784d716940;
static PyCodeObject *codeobj_b5fd4ac062544087b6a9ddde81164b51;
static PyCodeObject *codeobj_a73a4c372e34cc67c4020017d925c212;
static PyCodeObject *codeobj_e8e0aef170bf84feeacf8ba1c883ecbc;
static PyCodeObject *codeobj_b8a3c8eb6d0cfed599a0ebaf4228cb7e;
static PyCodeObject *codeobj_21a98671647d4c490602b522a14698c5;
static PyCodeObject *codeobj_9c2f0b6ba6c67834b6917d8d37ef1b06;
static PyCodeObject *codeobj_faef31ac41c50554a2c87cdc350362bb;
static PyCodeObject *codeobj_73c68707901485c856bd6798b6ebb929;
static PyCodeObject *codeobj_624df6905d3bc9676105aeac478b5f31;
static PyCodeObject *codeobj_5ba07520ccb205f02209ae0d2350fdfc;
static PyCodeObject *codeobj_40d458b7161fec50b845f57874bd45d9;
static PyCodeObject *codeobj_e3c0461f1c8bf2eb2a8c340eb6135f8c;
static PyCodeObject *codeobj_719e84962d68d77f7a035970f69e1a9a;
static PyCodeObject *codeobj_3aea55e6c7de9115dae8ec0ba396670e;
static PyCodeObject *codeobj_fdd326dca52447a788f24431430bb6ad;
static PyCodeObject *codeobj_2ca5dd22ca3a8bc538a80cd11b80d295;
static PyCodeObject *codeobj_419205c4be40b315ea5fe17707529d4d;
static PyCodeObject *codeobj_302c0a2001e73a2f203141af602952e7;
static PyCodeObject *codeobj_495194454ffc762d87d48093ed2144a7;
static PyCodeObject *codeobj_19ef0cc82fd641b32820effcb6b76808;
static PyCodeObject *codeobj_0549faef48236c7d313fa9148d7f2f51;
static PyCodeObject *codeobj_5a1a0089bd1a7cb13169e5d9f0339c3b;
static PyCodeObject *codeobj_3d5ba4d98fb2a674e58851f68e9ece08;
static PyCodeObject *codeobj_b1c87682ae63b69b7d39c8f7d942d1f0;
static PyCodeObject *codeobj_715a641a572181e14e9adaab487920f4;
static PyCodeObject *codeobj_5197084aa1655fcba879d05a0d251a83;
static PyCodeObject *codeobj_7c852edbba3637af02ee8ae23c132a9c;
static PyCodeObject *codeobj_9853ca544245558a309841b61c647a9d;
static PyCodeObject *codeobj_ca158fa9659faea697996b8861fbac5b;
static PyCodeObject *codeobj_84fc0dd7e3204da2c5289a919d64f506;
static PyCodeObject *codeobj_d9e89bd634fe62a085eca6d7aa03162b;
static PyCodeObject *codeobj_408b682245f176e23a2c4ef692a9a3d6;
static PyCodeObject *codeobj_732a0999f6a8d395b9c177f40b3df467;
static PyCodeObject *codeobj_eb387851309ccb53c81037c3614740f6;
static PyCodeObject *codeobj_2831de19996274756f58b6426de83d52;
static PyCodeObject *codeobj_147fb4f7b72cbe42d6cc16a449aa37f2;
static PyCodeObject *codeobj_930beb42264bc52c118db28d3d84c5e2;
static PyCodeObject *codeobj_53030939b146cc9d42e6d4f1be43e88c;
static PyCodeObject *codeobj_76dad211ce06eefadd08e6fe6a2ec222;
static PyCodeObject *codeobj_807d4878b190acac94f898107f81fe18;
static PyCodeObject *codeobj_ab1272eb3da49e1319b67cd0d702382e;
static PyCodeObject *codeobj_965440f565182c6598dbf33c10541c66;
static PyCodeObject *codeobj_451a8011f44bd9fb715fc33536be8eaf;
static PyCodeObject *codeobj_a4377935b5e1079fffa83973e17dd07e;
static PyCodeObject *codeobj_c8c71ecff826f1d926365130265beaa0;
static PyCodeObject *codeobj_ac03c002d6c914734a0ab63039d24303;
static PyCodeObject *codeobj_91fb653747c37e13f8b2d9e64801a04b;
static PyCodeObject *codeobj_e3486177e75618a26bbf2b5cd6036d4e;
static PyCodeObject *codeobj_f52a04d1a853156b6ca0927a29e3e304;
static PyCodeObject *codeobj_eb56fe42c9d4a9e33251b43172c33420;
static PyCodeObject *codeobj_e234381f83cd62c5730033d0a983bd87;
static PyCodeObject *codeobj_c802e26f9455ae469522a70187683133;
static PyCodeObject *codeobj_b62f655676fb2fb2ac69760ff8894e32;
static PyCodeObject *codeobj_efd3c2b04e65a2e7494c99d633f9af5b;
static PyCodeObject *codeobj_beb81c8ff6f3724b3c8798c4c515daca;
static PyCodeObject *codeobj_1350fb0c9dc013e11cfe4743a442a947;
static PyCodeObject *codeobj_f5900a135869b2c725abedc03985587c;
static PyCodeObject *codeobj_c8e859882515ed15aeb5b23f99d36210;
static PyCodeObject *codeobj_2f6e2042220007e67e1f735a62a30ac8;
static PyCodeObject *codeobj_09f8314dcf36acecb4822e17d6367093;
static PyCodeObject *codeobj_32675116669130ce76980bf99d864bad;
static PyCodeObject *codeobj_00663836178c09119ca59370dbc4f5ea;
static PyCodeObject *codeobj_8056a8f22b2faed7ea2b76e6f43dd588;
static PyCodeObject *codeobj_8643aa3a9324f9355635999f00ad57d9;
static PyCodeObject *codeobj_94ab4af3524bbcdc411d25898f593b22;
static PyCodeObject *codeobj_1fa718cf358c88654ca12b337f3c6d81;
static PyCodeObject *codeobj_bb873134d02b7ab21991d824dee68309;
static PyCodeObject *codeobj_81ae924ff3013530f1205e18ea0fb9cd;
static PyCodeObject *codeobj_8ee16325e7b90b2b674e1b2dda8fbb1d;
static PyCodeObject *codeobj_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9;
static PyCodeObject *codeobj_cb5e9701bc67a8bc731fc27811cda79b;
static PyCodeObject *codeobj_96b38d14a37200870473c9c6e70b2bbc;
static PyCodeObject *codeobj_efc1505ed87c663bcff91271fe296d91;
static PyCodeObject *codeobj_89b4b5423ea0ab4a62a22ab266feaff6;
static PyCodeObject *codeobj_ea0bda7a95b207898acca58f06ef419f;
static PyCodeObject *codeobj_b8b8b2a680fcba242b884f880392c9d6;
static PyCodeObject *codeobj_68970f99ee773eb7d9442246d4c73a29;
static PyCodeObject *codeobj_c7dae76b69bbb3064292f499d2086aba;
static PyCodeObject *codeobj_f9b069c262ea13b460c89d859872c039;
static PyCodeObject *codeobj_a6d47ed3f0819257d542d41da7816cf0;
static PyCodeObject *codeobj_6bdc0596686dfc0b462deed4239e76c7;
static PyCodeObject *codeobj_06b012069081bb35b69567ff4444dae3;
static PyCodeObject *codeobj_d05adab5b849556bfc3129c4f25b24f3;
static PyCodeObject *codeobj_20dd0dc6cd05131a2d53502a9508f1ee;
static PyCodeObject *codeobj_cea786226d325130b78da7385f8f8ba9;
static PyCodeObject *codeobj_fbf262121f91f3804d33b3044803566e;
static PyCodeObject *codeobj_1992bb674c115730c3d7ca787dcfc79c;
static PyCodeObject *codeobj_2ae85457f5c0b77074e133a648deb12f;
static PyCodeObject *codeobj_aca315e566868c59fcac8a4c130784fa;
static PyCodeObject *codeobj_11ebf3160087fe2851050075a57a707d;
static PyCodeObject *codeobj_0b02fe1bf74fa2e8f3be10e4fea252d1;
static PyCodeObject *codeobj_c9af8615d8b382ab25d387a4ae2144bc;
static PyCodeObject *codeobj_06fc7afb37bb590954770ef5cc01bd68;
static PyCodeObject *codeobj_2c52ecf04878c5e07b5a9352531b27fd;
static PyCodeObject *codeobj_5e5a263fa0cb9631492a4fffaa6bde27;
static PyCodeObject *codeobj_b3c4b5edc4fdbdc86e95e400aff5eb12;
static PyCodeObject *codeobj_65974833a3df4d178e6a07b93e7b2058;
static PyCodeObject *codeobj_461ef44fe0103cf3dcb9bc48cf4045fa;
static PyCodeObject *codeobj_2d651ca3de79d85f11fde11a7e7de8a4;
static PyCodeObject *codeobj_2c79586a1ed1d017b86e3b8a016ef4f9;
static PyCodeObject *codeobj_e88bbbf696a76c8d25dfac8c1b201a35;
static PyCodeObject *codeobj_48d6590f132aac7ab0ed4bc6f937525b;
static PyCodeObject *codeobj_195f6802c28d1d62bcec0d77580932c9;
static PyCodeObject *codeobj_6d428aa80f9c6f7f05fa23513004f374;
static PyCodeObject *codeobj_efc2fdaf980f974e85adba56eab74e1d;

static void createModuleCodeObjects(void) {
    module_filename_obj = const_str_digest_a9e497a69e6698a5ac0200bc3be01588;
    codeobj_6fbd9f0268750b41e458dd0b93defaa8 = MAKE_CODEOBJECT(module_filename_obj, 284, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_a_str_plain_self_tuple, 1, 0, 0);
    codeobj_12b493fa58299085ea49015dfa1e4296 = MAKE_CODEOBJECT(module_filename_obj, 363, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_a_str_plain_self_tuple, 1, 0, 0);
    codeobj_dc46bea2e1fc1b5ddb719d7050173072 = MAKE_CODEOBJECT(module_filename_obj, 967, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_a_str_plain_self_tuple, 1, 0, 0);
    codeobj_efe41bc1c089bb53bb12793c18870fbd = MAKE_CODEOBJECT(module_filename_obj, 976, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_a_str_plain_self_tuple, 1, 0, 0);
    codeobj_dfa67eee91fa81af058566081de7dad5 = MAKE_CODEOBJECT(module_filename_obj, 986, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_a_str_plain_self_tuple, 1, 0, 0);
    codeobj_ff403a14643d9f44c988823fbe0ecdaf = MAKE_CODEOBJECT(module_filename_obj, 1188, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_a_str_plain_self_tuple, 1, 0, 0);
    codeobj_0c896c01aacc838fc67aa18df394c175 = MAKE_CODEOBJECT(module_filename_obj, 442, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_e_str_plain_self_tuple, 1, 0, 0);
    codeobj_2f0e82d85089746fa7bf708e34483a0f = MAKE_CODEOBJECT(module_filename_obj, 393, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_s_str_plain_self_tuple, 1, 0, 0);
    codeobj_b4e5fc01de25d83cb1f9b8c6e90e2392 = MAKE_CODEOBJECT(module_filename_obj, 1007, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_s_str_plain_self_tuple, 1, 0, 0);
    codeobj_fe241e4894e4a0c9becdd4bc6600c26d = MAKE_CODEOBJECT(module_filename_obj, 1016, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_s_str_plain_self_tuple, 1, 0, 0);
    codeobj_2e404164e29148f30f48039278898bad = MAKE_CODEOBJECT(module_filename_obj, 1026, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_s_str_plain_self_tuple, 1, 0, 0);
    codeobj_ccb5f13133b0dfbba91f076d61030295 = MAKE_CODEOBJECT(module_filename_obj, 264, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_t_str_plain_self_tuple, 1, 0, 0);
    codeobj_8f657b6a02f36cc5275fe109975cdb9f = MAKE_CODEOBJECT(module_filename_obj, 873, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_t_str_plain_self_tuple, 1, 0, 0);
    codeobj_e9748f74fbae27652dd60c784d716940 = MAKE_CODEOBJECT(module_filename_obj, 885, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_t_str_plain_self_tuple, 1, 0, 0);
    codeobj_b5fd4ac062544087b6a9ddde81164b51 = MAKE_CODEOBJECT(module_filename_obj, 897, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_t_str_plain_self_tuple, 1, 0, 0);
    codeobj_a73a4c372e34cc67c4020017d925c212 = MAKE_CODEOBJECT(module_filename_obj, 1194, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_t_str_plain_self_tuple, 1, 0, 0);
    codeobj_e8e0aef170bf84feeacf8ba1c883ecbc = MAKE_CODEOBJECT(module_filename_obj, 1243, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_t_str_plain_self_tuple, 1, 0, 0);
    codeobj_b8a3c8eb6d0cfed599a0ebaf4228cb7e = MAKE_CODEOBJECT(module_filename_obj, 681, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_tid_str_plain_self_tuple, 1, 0, 0);
    codeobj_21a98671647d4c490602b522a14698c5 = MAKE_CODEOBJECT(module_filename_obj, 697, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_tid_str_plain_self_tuple, 1, 0, 0);
    codeobj_9c2f0b6ba6c67834b6917d8d37ef1b06 = MAKE_CODEOBJECT(module_filename_obj, 750, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_tid_str_plain_self_tuple, 1, 0, 0);
    codeobj_faef31ac41c50554a2c87cdc350362bb = MAKE_CODEOBJECT(module_filename_obj, 751, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_angle_listcomp, const_tuple_str_plain_track_tuple, 1, 0, 0);
    codeobj_73c68707901485c856bd6798b6ebb929 = MAKE_CODEOBJECT(module_filename_obj, 1, CO_NOFREE, const_str_digest_839a8c1f15a51259ddc0a84ae73da1ee, const_tuple_empty, 0, 0, 0);
    codeobj_624df6905d3bc9676105aeac478b5f31 = MAKE_CODEOBJECT(module_filename_obj, 20, CO_NOFREE, const_str_plain_Spotify, const_tuple_str_plain___class___tuple, 0, 0, 0);
    codeobj_5ba07520ccb205f02209ae0d2350fdfc = MAKE_CODEOBJECT(module_filename_obj, 119, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___del__, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_40d458b7161fec50b845f57874bd45d9 = MAKE_CODEOBJECT(module_filename_obj, 38, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain___init__, const_tuple_8cc3613134194fa97627fa253dd27832_tuple, 12, 0, 0);
    codeobj_e3c0461f1c8bf2eb2a8c340eb6135f8c = MAKE_CODEOBJECT(module_filename_obj, 1448, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__append_device_id, const_tuple_str_plain_self_str_plain_path_str_plain_device_id_tuple, 3, 0, 0);
    codeobj_719e84962d68d77f7a035970f69e1a9a = MAKE_CODEOBJECT(module_filename_obj, 138, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__auth_headers, const_tuple_str_plain_self_str_plain_token_tuple, 1, 0, 0);
    codeobj_3aea55e6c7de9115dae8ec0ba396670e = MAKE_CODEOBJECT(module_filename_obj, 124, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__build_session, const_tuple_str_plain_self_str_plain_retry_str_plain_adapter_tuple, 1, 0, 0);
    codeobj_fdd326dca52447a788f24431430bb6ad = MAKE_CODEOBJECT(module_filename_obj, 214, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain__delete, const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 4, 0, 0);
    codeobj_2ca5dd22ca3a8bc538a80cd11b80d295 = MAKE_CODEOBJECT(module_filename_obj, 203, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain__get, const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 4, 0, 0);
    codeobj_419205c4be40b315ea5fe17707529d4d = MAKE_CODEOBJECT(module_filename_obj, 1461, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_id, const_tuple_eefa0cd5c1a6e9f5065e120ffba1043c_tuple, 3, 0, 0);
    codeobj_302c0a2001e73a2f203141af602952e7 = MAKE_CODEOBJECT(module_filename_obj, 1477, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__get_uri, const_tuple_str_plain_self_str_plain_type_str_plain_id_tuple, 3, 0, 0);
    codeobj_495194454ffc762d87d48093ed2144a7 = MAKE_CODEOBJECT(module_filename_obj, 147, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain__internal_call, const_tuple_afd00523c6c1afd1fac8352bfa55fedc_tuple, 5, 0, 0);
    codeobj_19ef0cc82fd641b32820effcb6b76808 = MAKE_CODEOBJECT(module_filename_obj, 209, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain__post, const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 4, 0, 0);
    codeobj_0549faef48236c7d313fa9148d7f2f51 = MAKE_CODEOBJECT(module_filename_obj, 219, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain__put, const_tuple_85cfd88dd040aecac7982d4fb8c59e65_tuple, 4, 0, 0);
    codeobj_5a1a0089bd1a7cb13169e5d9f0339c3b = MAKE_CODEOBJECT(module_filename_obj, 1424, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_add_to_queue, const_tuple_4013a80e77aff1d83eab2a301d105cdc_tuple, 3, 0, 0);
    codeobj_3d5ba4d98fb2a674e58851f68e9ece08 = MAKE_CODEOBJECT(module_filename_obj, 332, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_album, const_tuple_str_plain_self_str_plain_album_id_str_plain_trid_tuple, 2, 0, 0);
    codeobj_b1c87682ae63b69b7d39c8f7d942d1f0 = MAKE_CODEOBJECT(module_filename_obj, 342, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_album_tracks, const_tuple_e07c966da3a73f0cf6a6cdaf01bd7de8_tuple, 4, 0, 0);
    codeobj_715a641a572181e14e9adaab487920f4 = MAKE_CODEOBJECT(module_filename_obj, 356, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_albums, const_tuple_str_plain_self_str_plain_albums_str_plain_tlist_tuple, 2, 0, 0);
    codeobj_5197084aa1655fcba879d05a0d251a83 = MAKE_CODEOBJECT(module_filename_obj, 267, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_artist, const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple, 2, 0, 0);
    codeobj_7c852edbba3637af02ee8ae23c132a9c = MAKE_CODEOBJECT(module_filename_obj, 287, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_artist_albums, const_tuple_63d339eab0f4b783c640d3e4c6645c2d_tuple, 6, 0, 0);
    codeobj_9853ca544245558a309841b61c647a9d = MAKE_CODEOBJECT(module_filename_obj, 321, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_artist_related_artists, const_tuple_str_plain_self_str_plain_artist_id_str_plain_trid_tuple, 2, 0, 0);
    codeobj_ca158fa9659faea697996b8861fbac5b = MAKE_CODEOBJECT(module_filename_obj, 309, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_artist_top_tracks, const_tuple_cc4f7ba3bf15ba5d9bdf894a1121c78e_tuple, 3, 0, 0);
    codeobj_84fc0dd7e3204da2c5289a919d64f506 = MAKE_CODEOBJECT(module_filename_obj, 277, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_artists, const_tuple_str_plain_self_str_plain_artists_str_plain_tlist_tuple, 2, 0, 0);
    codeobj_d9e89bd634fe62a085eca6d7aa03162b = MAKE_CODEOBJECT(module_filename_obj, 1226, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_audio_analysis, const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple, 2, 0, 0);
    codeobj_408b682245f176e23a2c4ef692a9a3d6 = MAKE_CODEOBJECT(module_filename_obj, 1234, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_audio_features, const_tuple_11a6319e07aa050aed810c998ea37058_tuple, 2, 0, 0);
    codeobj_732a0999f6a8d395b9c177f40b3df467 = MAKE_CODEOBJECT(module_filename_obj, 106, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_auth_manager, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_eb387851309ccb53c81037c3614740f6 = MAKE_CODEOBJECT(module_filename_obj, 110, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_auth_manager, const_tuple_str_plain_self_str_plain_auth_manager_tuple, 2, 0, 0);
    codeobj_2831de19996274756f58b6426de83d52 = MAKE_CODEOBJECT(module_filename_obj, 1107, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_categories, const_tuple_bf3eaef7ee511ae90328baaa39f70dc5_tuple, 5, 0, 0);
    codeobj_147fb4f7b72cbe42d6cc16a449aa37f2 = MAKE_CODEOBJECT(module_filename_obj, 1131, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_category_playlists, const_tuple_17b6b284794594e104aa2bdbbe24b267_tuple, 5, 0, 0);
    codeobj_930beb42264bc52c118db28d3d84c5e2 = MAKE_CODEOBJECT(module_filename_obj, 1257, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_playback, const_tuple_str_plain_self_str_plain_market_tuple, 2, 0, 0);
    codeobj_53030939b146cc9d42e6d4f1be43e88c = MAKE_CODEOBJECT(module_filename_obj, 829, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_76dad211ce06eefadd08e6fe6a2ec222 = MAKE_CODEOBJECT(module_filename_obj, 851, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_followed_artists, const_tuple_str_plain_self_str_plain_limit_str_plain_after_tuple, 3, 0, 0);
    codeobj_807d4878b190acac94f898107f81fe18 = MAKE_CODEOBJECT(module_filename_obj, 835, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_playing_track, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_ab1272eb3da49e1319b67cd0d702382e = MAKE_CODEOBJECT(module_filename_obj, 470, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_playlists, const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 3, 0, 0);
    codeobj_965440f565182c6598dbf33c10541c66 = MAKE_CODEOBJECT(module_filename_obj, 930, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_recently_played, const_tuple_081af9adfafad22f783d98b6edb46e6b_tuple, 4, 0, 0);
    codeobj_451a8011f44bd9fb715fc33536be8eaf = MAKE_CODEOBJECT(module_filename_obj, 949, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_albums, const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 3, 0, 0);
    codeobj_a4377935b5e1079fffa83973e17dd07e = MAKE_CODEOBJECT(module_filename_obj, 970, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_albums_add, const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple, 2, 0, 0);
    codeobj_c8c71ecff826f1d926365130265beaa0 = MAKE_CODEOBJECT(module_filename_obj, 960, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_albums_contains, const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple, 2, 0, 0);
    codeobj_ac03c002d6c914734a0ab63039d24303 = MAKE_CODEOBJECT(module_filename_obj, 979, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_albums_delete, const_tuple_str_plain_self_str_plain_albums_str_plain_alist_tuple, 2, 0, 0);
    codeobj_91fb653747c37e13f8b2d9e64801a04b = MAKE_CODEOBJECT(module_filename_obj, 989, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_shows, const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 3, 0, 0);
    codeobj_e3486177e75618a26bbf2b5cd6036d4e = MAKE_CODEOBJECT(module_filename_obj, 1010, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_shows_add, const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple, 2, 0, 0);
    codeobj_f52a04d1a853156b6ca0927a29e3e304 = MAKE_CODEOBJECT(module_filename_obj, 1000, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_shows_contains, const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple, 2, 0, 0);
    codeobj_eb56fe42c9d4a9e33251b43172c33420 = MAKE_CODEOBJECT(module_filename_obj, 1019, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_shows_delete, const_tuple_str_plain_self_str_plain_shows_str_plain_slist_tuple, 2, 0, 0);
    codeobj_e234381f83cd62c5730033d0a983bd87 = MAKE_CODEOBJECT(module_filename_obj, 840, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_tracks, const_tuple_str_plain_self_str_plain_limit_str_plain_offset_tuple, 3, 0, 0);
    codeobj_c802e26f9455ae469522a70187683133 = MAKE_CODEOBJECT(module_filename_obj, 888, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_tracks_add, const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple, 2, 0, 0);
    codeobj_b62f655676fb2fb2ac69760ff8894e32 = MAKE_CODEOBJECT(module_filename_obj, 876, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_tracks_contains, const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple, 2, 0, 0);
    codeobj_efd3c2b04e65a2e7494c99d633f9af5b = MAKE_CODEOBJECT(module_filename_obj, 864, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_saved_tracks_delete, const_tuple_str_plain_self_str_plain_tracks_str_plain_tlist_tuple, 2, 0, 0);
    codeobj_beb81c8ff6f3724b3c8798c4c515daca = MAKE_CODEOBJECT(module_filename_obj, 900, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_top_artists, const_tuple_149384ac75bf30697541a03a2af20cf7_tuple, 4, 0, 0);
    codeobj_1350fb0c9dc013e11cfe4743a442a947 = MAKE_CODEOBJECT(module_filename_obj, 915, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_current_user_top_tracks, const_tuple_149384ac75bf30697541a03a2af20cf7_tuple, 4, 0, 0);
    codeobj_f5900a135869b2c725abedc03985587c = MAKE_CODEOBJECT(module_filename_obj, 1265, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_currently_playing, const_tuple_str_plain_self_str_plain_market_tuple, 2, 0, 0);
    codeobj_c8e859882515ed15aeb5b23f99d36210 = MAKE_CODEOBJECT(module_filename_obj, 1252, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_devices, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_2f6e2042220007e67e1f735a62a30ac8 = MAKE_CODEOBJECT(module_filename_obj, 415, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_episode, const_tuple_6c047a436b5123630a3f4d707dc092ac_tuple, 3, 0, 0);
    codeobj_09f8314dcf36acecb4822e17d6367093 = MAKE_CODEOBJECT(module_filename_obj, 430, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_episodes, const_tuple_fe00d07b498f378d886063a767afe437_tuple, 3, 0, 0);
    codeobj_32675116669130ce76980bf99d864bad = MAKE_CODEOBJECT(module_filename_obj, 1057, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_featured_playlists, const_tuple_a0f52a45426fafc84e775c2b57d86682_tuple, 6, 0, 0);
    codeobj_00663836178c09119ca59370dbc4f5ea = MAKE_CODEOBJECT(module_filename_obj, 823, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_me, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_8056a8f22b2faed7ea2b76e6f43dd588 = MAKE_CODEOBJECT(module_filename_obj, 1090, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_new_releases, const_tuple_682b992cd17b43443c5763aa401a1636_tuple, 4, 0, 0);
    codeobj_8643aa3a9324f9355635999f00ad57d9 = MAKE_CODEOBJECT(module_filename_obj, 224, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_next, const_tuple_str_plain_self_str_plain_result_tuple, 2, 0, 0);
    codeobj_94ab4af3524bbcdc411d25898f593b22 = MAKE_CODEOBJECT(module_filename_obj, 1337, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_next_track, const_tuple_str_plain_self_str_plain_device_id_tuple, 2, 0, 0);
    codeobj_1fa718cf358c88654ca12b337f3c6d81 = MAKE_CODEOBJECT(module_filename_obj, 1329, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_pause_playback, const_tuple_str_plain_self_str_plain_device_id_tuple, 2, 0, 0);
    codeobj_bb873134d02b7ab21991d824dee68309 = MAKE_CODEOBJECT(module_filename_obj, 478, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_playlist, const_tuple_92627fe8b33459c81955bb22182b44fc_tuple, 5, 0, 0);
    codeobj_81ae924ff3013530f1205e18ea0fb9cd = MAKE_CODEOBJECT(module_filename_obj, 527, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_playlist_cover_image, const_tuple_str_plain_self_str_plain_playlist_id_str_plain_plid_tuple, 2, 0, 0);
    codeobj_8ee16325e7b90b2b674e1b2dda8fbb1d = MAKE_CODEOBJECT(module_filename_obj, 497, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_playlist_tracks, const_tuple_931a773d91816f6c21c0ccf65e4e61f3_tuple, 7, 0, 0);
    codeobj_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 = MAKE_CODEOBJECT(module_filename_obj, 536, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_playlist_upload_cover_image, const_tuple_240444d8ccde4d776e90d3cfd2fda720_tuple, 3, 0, 0);
    codeobj_cb5e9701bc67a8bc731fc27811cda79b = MAKE_CODEOBJECT(module_filename_obj, 235, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_previous, const_tuple_str_plain_self_str_plain_result_tuple, 2, 0, 0);
    codeobj_96b38d14a37200870473c9c6e70b2bbc = MAKE_CODEOBJECT(module_filename_obj, 1345, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_previous_track, const_tuple_str_plain_self_str_plain_device_id_tuple, 2, 0, 0);
    codeobj_efc1505ed87c663bcff91271fe296d91 = MAKE_CODEOBJECT(module_filename_obj, 1221, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_recommendation_genre_seeds, const_tuple_str_plain_self_tuple, 1, 0, 0);
    codeobj_89b4b5423ea0ab4a62a22ab266feaff6 = MAKE_CODEOBJECT(module_filename_obj, 1155, CO_OPTIMIZED | CO_NEWLOCALS | CO_VARKEYWORDS | CO_NOFREE, const_str_plain_recommendations, const_tuple_4886489b19733e5c89d8dc50502d893b_tuple, 6, 0, 0);
    codeobj_ea0bda7a95b207898acca58f06ef419f = MAKE_CODEOBJECT(module_filename_obj, 1371, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_repeat, const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple, 3, 0, 0);
    codeobj_b8b8b2a680fcba242b884f880392c9d6 = MAKE_CODEOBJECT(module_filename_obj, 445, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_search, const_tuple_ad8068e0aec9d33fa50a0072ded3ef4e_tuple, 6, 0, 0);
    codeobj_68970f99ee773eb7d9442246d4c73a29 = MAKE_CODEOBJECT(module_filename_obj, 1355, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_seek_track, const_tuple_str_plain_self_str_plain_position_ms_str_plain_device_id_tuple, 3, 0, 0);
    codeobj_c7dae76b69bbb3064292f499d2086aba = MAKE_CODEOBJECT(module_filename_obj, 103, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_set_auth, const_tuple_str_plain_self_str_plain_auth_tuple, 2, 0, 0);
    codeobj_f9b069c262ea13b460c89d859872c039 = MAKE_CODEOBJECT(module_filename_obj, 366, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_show, const_tuple_bd3dd83b379822a35a9da74a1ac27b22_tuple, 3, 0, 0);
    codeobj_a6d47ed3f0819257d542d41da7816cf0 = MAKE_CODEOBJECT(module_filename_obj, 396, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_show_episodes, const_tuple_a14db1d1295321c6abfacd2b483d6da1_tuple, 5, 0, 0);
    codeobj_6bdc0596686dfc0b462deed4239e76c7 = MAKE_CODEOBJECT(module_filename_obj, 381, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_shows, const_tuple_069764dd8c1ec01972656675304328c5_tuple, 3, 0, 0);
    codeobj_06b012069081bb35b69567ff4444dae3 = MAKE_CODEOBJECT(module_filename_obj, 1407, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_shuffle, const_tuple_str_plain_self_str_plain_state_str_plain_device_id_tuple, 3, 0, 0);
    codeobj_d05adab5b849556bfc3129c4f25b24f3 = MAKE_CODEOBJECT(module_filename_obj, 1286, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_start_playback, const_tuple_52f5b989419359389333ac00979cfcda_tuple, 6, 0, 0);
    codeobj_20dd0dc6cd05131a2d53502a9508f1ee = MAKE_CODEOBJECT(module_filename_obj, 246, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_track, const_tuple_str_plain_self_str_plain_track_id_str_plain_trid_tuple, 2, 0, 0);
    codeobj_cea786226d325130b78da7385f8f8ba9 = MAKE_CODEOBJECT(module_filename_obj, 256, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_tracks, const_tuple_3062cc6de242c4532a27a32e8fb9853e_tuple, 3, 0, 0);
    codeobj_fbf262121f91f3804d33b3044803566e = MAKE_CODEOBJECT(module_filename_obj, 1273, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_transfer_playback, const_tuple_2c14864855545e1854bee3fef626583e_tuple, 3, 0, 0);
    codeobj_1992bb674c115730c3d7ca787dcfc79c = MAKE_CODEOBJECT(module_filename_obj, 462, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user, const_tuple_str_plain_self_str_plain_user_tuple, 2, 0, 0);
    codeobj_2ae85457f5c0b77074e133a648deb12f = MAKE_CODEOBJECT(module_filename_obj, 1029, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_follow_artists, const_tuple_str_plain_self_str_plain_ids_tuple, 2, 0, 0);
    codeobj_aca315e566868c59fcac8a4c130784fa = MAKE_CODEOBJECT(module_filename_obj, 1036, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_follow_users, const_tuple_str_plain_self_str_plain_ids_tuple, 2, 0, 0);
    codeobj_11ebf3160087fe2851050075a57a707d = MAKE_CODEOBJECT(module_filename_obj, 551, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist, const_tuple_e12e9cccb58de84fad9c81b48c1c3e6d_tuple, 5, 0, 0);
    codeobj_0b02fe1bf74fa2e8f3be10e4fea252d1 = MAKE_CODEOBJECT(module_filename_obj, 669, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_add_tracks, const_tuple_f24866834ebd2eab5a3599d0f604f1a0_tuple, 5, 0, 0);
    codeobj_c9af8615d8b382ab25d387a4ae2144bc = MAKE_CODEOBJECT(module_filename_obj, 625, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_change_details, const_tuple_6367be7db62c8846531c10fec757318e_tuple, 7, 0, 0);
    codeobj_06fc7afb37bb590954770ef5cc01bd68 = MAKE_CODEOBJECT(module_filename_obj, 612, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_create, const_tuple_ced136edbc0c3ce89b457ded0f98b9e1_tuple, 5, 0, 0);
    codeobj_2c52ecf04878c5e07b5a9352531b27fd = MAKE_CODEOBJECT(module_filename_obj, 790, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_follow_playlist, const_tuple_e154c21abc67708aeafc1bb2f6712757_tuple, 3, 0, 0);
    codeobj_5e5a263fa0cb9631492a4fffaa6bde27 = MAKE_CODEOBJECT(module_filename_obj, 805, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_is_following, const_tuple_b5f25b2a50b3d774e353dc92bec30dd2_tuple, 4, 0, 0);
    codeobj_b3c4b5edc4fdbdc86e95e400aff5eb12 = MAKE_CODEOBJECT(module_filename_obj, 736, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_digest_4b32f198f6de09ec1a43edf661b1c6e4, const_tuple_4c3dd55181a24ff6597751a72804e55d_tuple, 5, 0, 0);
    codeobj_65974833a3df4d178e6a07b93e7b2058 = MAKE_CODEOBJECT(module_filename_obj, 758, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_digest_f3bd18c4e4dfe3b238c61f74d4197ffd, const_tuple_e63b9ff1d0daf4b1099ccb037871aeb9_tuple, 5, 0, 0);
    codeobj_461ef44fe0103cf3dcb9bc48cf4045fa = MAKE_CODEOBJECT(module_filename_obj, 703, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_reorder_tracks, const_tuple_43876a40d6b8c2f3ace57c62b53d0653_tuple, 7, 0, 0);
    codeobj_2d651ca3de79d85f11fde11a7e7de8a4 = MAKE_CODEOBJECT(module_filename_obj, 688, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_replace_tracks, const_tuple_48addbdf13ad88d374bffdd4d89f8e79_tuple, 4, 0, 0);
    codeobj_2c79586a1ed1d017b86e3b8a016ef4f9 = MAKE_CODEOBJECT(module_filename_obj, 568, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_tracks, const_tuple_c6d87bd2e96bf2b4e66825ff8ed1c798_tuple, 7, 0, 0);
    codeobj_e88bbbf696a76c8d25dfac8c1b201a35 = MAKE_CODEOBJECT(module_filename_obj, 658, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlist_unfollow, const_tuple_str_plain_self_str_plain_user_str_plain_playlist_id_tuple, 3, 0, 0);
    codeobj_48d6590f132aac7ab0ed4bc6f937525b = MAKE_CODEOBJECT(module_filename_obj, 600, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_playlists, const_tuple_f6d159e1d4883398c029cc7a513fbcda_tuple, 4, 0, 0);
    codeobj_195f6802c28d1d62bcec0d77580932c9 = MAKE_CODEOBJECT(module_filename_obj, 1043, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_unfollow_artists, const_tuple_str_plain_self_str_plain_ids_tuple, 2, 0, 0);
    codeobj_6d428aa80f9c6f7f05fa23513004f374 = MAKE_CODEOBJECT(module_filename_obj, 1050, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_user_unfollow_users, const_tuple_str_plain_self_str_plain_ids_tuple, 2, 0, 0);
    codeobj_efc2fdaf980f974e85adba56eab74e1d = MAKE_CODEOBJECT(module_filename_obj, 1387, CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE, const_str_plain_volume, const_tuple_str_plain_self_str_plain_volume_percent_str_plain_device_id_tuple, 3, 0, 0);
}

// The module function declarations.
NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_4__mro_entries_conversion(PyObject **python_pars);


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_8_complex_call_helper_pos_keywords_star_dict(PyObject **python_pars);


NUITKA_CROSS_MODULE PyObject *impl___internal__$$$function_9_complex_call_helper_pos_star_dict(PyObject **python_pars);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_10__post(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_11__delete(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_12__put(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_13_next();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_14_previous();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_15_track();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_16_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_17_artist();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_18_artists();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_19_artist_albums(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_1___init__(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_20_artist_top_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_21_artist_related_artists();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_22_album();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_23_album_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_24_albums();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_25_show(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_26_shows(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_27_show_episodes(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_28_episode(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_29_episodes(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_2_set_auth();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_30_search(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_31_user();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_32_current_user_playlists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_33_playlist(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_34_playlist_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_35_playlist_cover_image();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_36_playlist_upload_cover_image();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_37_user_playlist(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_38_user_playlist_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_39_user_playlists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_3_auth_manager();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_40_user_playlist_create(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_41_user_playlist_change_details(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_42_user_playlist_unfollow();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_43_user_playlist_add_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_44_user_playlist_replace_tracks();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_45_user_playlist_reorder_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_46_user_playlist_remove_all_occurrences_of_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_47_user_playlist_remove_specific_occurrences_of_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_48_user_playlist_follow_playlist();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_49_user_playlist_is_following();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_4_auth_manager();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_50_me();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_51_current_user();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_52_current_user_playing_track();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_53_current_user_saved_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_54_current_user_followed_artists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_55_current_user_saved_tracks_delete(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_56_current_user_saved_tracks_contains(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_57_current_user_saved_tracks_add(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_58_current_user_top_artists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_59_current_user_top_tracks(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_5___del__();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_60_current_user_recently_played(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_61_current_user_saved_albums(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_62_current_user_saved_albums_contains(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_63_current_user_saved_albums_add(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_64_current_user_saved_albums_delete(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_65_current_user_saved_shows(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_66_current_user_saved_shows_contains(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_67_current_user_saved_shows_add(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_68_current_user_saved_shows_delete(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_69_user_follow_artists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_6__build_session();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_70_user_follow_users(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_71_user_unfollow_artists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_72_user_unfollow_users(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_73_featured_playlists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_74_new_releases(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_75_categories(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_76_category_playlists(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_77_recommendations(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_78_recommendation_genre_seeds();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_79_audio_analysis();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_7__auth_headers();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_80_audio_features(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_81_devices();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_82_current_playback(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_83_currently_playing(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_84_transfer_playback(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_85_start_playback(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_86_pause_playback(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_87_next_track(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_88_previous_track(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_89_seek_track(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_8__internal_call();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_90_repeat(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_91_volume(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_92_shuffle(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_93_add_to_queue(PyObject *defaults);


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_94__append_device_id();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_95__get_id();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_96__get_uri();


static PyObject *MAKE_FUNCTION_spotipy$client$$$function_9__get(PyObject *defaults);


// The module function definitions.
static PyObject *impl_spotipy$client$$$function_1___init__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_auth = python_pars[1];
    PyObject *par_requests_session = python_pars[2];
    PyObject *par_client_credentials_manager = python_pars[3];
    PyObject *par_oauth_manager = python_pars[4];
    PyObject *par_auth_manager = python_pars[5];
    PyObject *par_proxies = python_pars[6];
    PyObject *par_requests_timeout = python_pars[7];
    PyObject *par_status_forcelist = python_pars[8];
    PyObject *par_retries = python_pars[9];
    PyObject *par_status_retries = python_pars[10];
    PyObject *par_backoff_factor = python_pars[11];
    struct Nuitka_FrameObject *frame_40d458b7161fec50b845f57874bd45d9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_40d458b7161fec50b845f57874bd45d9 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_40d458b7161fec50b845f57874bd45d9)) {
        Py_XDECREF(cache_frame_40d458b7161fec50b845f57874bd45d9);

#if _DEBUG_REFCOUNTS
        if (cache_frame_40d458b7161fec50b845f57874bd45d9 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_40d458b7161fec50b845f57874bd45d9 = MAKE_FUNCTION_FRAME(codeobj_40d458b7161fec50b845f57874bd45d9, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_40d458b7161fec50b845f57874bd45d9->m_type_description == NULL);
    frame_40d458b7161fec50b845f57874bd45d9 = cache_frame_40d458b7161fec50b845f57874bd45d9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_40d458b7161fec50b845f57874bd45d9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_40d458b7161fec50b845f57874bd45d9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        tmp_assattr_name_1 = const_str_digest_5b2f21fd676ae63c8602c70b44bb1a65;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_prefix, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 83;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_auth);
        tmp_assattr_name_2 = par_auth;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__auth, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 84;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_3;
        PyObject *tmp_assattr_target_3;
        CHECK_OBJECT(par_client_credentials_manager);
        tmp_assattr_name_3 = par_client_credentials_manager;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_3 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_3, const_str_plain_client_credentials_manager, tmp_assattr_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 85;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_4;
        PyObject *tmp_assattr_target_4;
        CHECK_OBJECT(par_oauth_manager);
        tmp_assattr_name_4 = par_oauth_manager;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_4 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_4, const_str_plain_oauth_manager, tmp_assattr_name_4);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 86;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_5;
        PyObject *tmp_assattr_target_5;
        CHECK_OBJECT(par_auth_manager);
        tmp_assattr_name_5 = par_auth_manager;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_5 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_5, const_str_plain_auth_manager, tmp_assattr_name_5);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 87;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_6;
        PyObject *tmp_assattr_target_6;
        CHECK_OBJECT(par_proxies);
        tmp_assattr_name_6 = par_proxies;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_6 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_6, const_str_plain_proxies, tmp_assattr_name_6);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 88;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_7;
        PyObject *tmp_assattr_target_7;
        CHECK_OBJECT(par_requests_timeout);
        tmp_assattr_name_7 = par_requests_timeout;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_7 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_7, const_str_plain_requests_timeout, tmp_assattr_name_7);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 89;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_8;
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_assattr_target_8;
        CHECK_OBJECT(par_status_forcelist);
        tmp_or_left_value_1 = par_status_forcelist;
        tmp_or_left_truth_1 = CHECK_IF_TRUE(tmp_or_left_value_1);
        if (tmp_or_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 90;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_or_right_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_default_retry_codes);
        if (tmp_or_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 90;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_8 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        Py_INCREF(tmp_or_left_value_1);
        tmp_assattr_name_8 = tmp_or_left_value_1;
        or_end_1:;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_8 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_8, const_str_plain_status_forcelist, tmp_assattr_name_8);
        Py_DECREF(tmp_assattr_name_8);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 90;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_9;
        PyObject *tmp_assattr_target_9;
        CHECK_OBJECT(par_backoff_factor);
        tmp_assattr_name_9 = par_backoff_factor;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_9 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_9, const_str_plain_backoff_factor, tmp_assattr_name_9);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 91;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_10;
        PyObject *tmp_assattr_target_10;
        CHECK_OBJECT(par_retries);
        tmp_assattr_name_10 = par_retries;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_10 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_10, const_str_plain_retries, tmp_assattr_name_10);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 92;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_11;
        PyObject *tmp_assattr_target_11;
        CHECK_OBJECT(par_status_retries);
        tmp_assattr_name_11 = par_status_retries;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_11 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_11, const_str_plain_status_retries, tmp_assattr_name_11);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 93;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_requests_session);
        tmp_isinstance_inst_1 = par_requests_session;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 95;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_2 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_Session);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 95;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 95;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assattr_name_12;
        PyObject *tmp_assattr_target_12;
        CHECK_OBJECT(par_requests_session);
        tmp_assattr_name_12 = par_requests_session;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_12 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_12, const_str_plain__session, tmp_assattr_name_12);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 96;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    goto branch_end_1;
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_requests_session);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_requests_session);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 98;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_40d458b7161fec50b845f57874bd45d9->m_frame.f_lineno = 99;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain__build_session);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 99;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    goto branch_end_2;
    branch_no_2:;
    {
        PyObject *tmp_assattr_name_13;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_assattr_target_13;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 101;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_3 = tmp_mvar_value_2;
        tmp_assattr_name_13 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain_api);
        if (tmp_assattr_name_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 101;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_13 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_13, const_str_plain__session, tmp_assattr_name_13);
        Py_DECREF(tmp_assattr_name_13);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 101;
            type_description_1 = "oooooooooooo";
            goto frame_exception_exit_1;
        }
    }
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_40d458b7161fec50b845f57874bd45d9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_40d458b7161fec50b845f57874bd45d9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_40d458b7161fec50b845f57874bd45d9, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_40d458b7161fec50b845f57874bd45d9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_40d458b7161fec50b845f57874bd45d9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_40d458b7161fec50b845f57874bd45d9,
        type_description_1,
        par_self,
        par_auth,
        par_requests_session,
        par_client_credentials_manager,
        par_oauth_manager,
        par_auth_manager,
        par_proxies,
        par_requests_timeout,
        par_status_forcelist,
        par_retries,
        par_status_retries,
        par_backoff_factor
    );


    // Release cached frame.
    if (frame_40d458b7161fec50b845f57874bd45d9 == cache_frame_40d458b7161fec50b845f57874bd45d9) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_40d458b7161fec50b845f57874bd45d9);
    }
    cache_frame_40d458b7161fec50b845f57874bd45d9 = NULL;

    assertFrameObject(frame_40d458b7161fec50b845f57874bd45d9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_auth);
    Py_DECREF(par_auth);
    CHECK_OBJECT(par_requests_session);
    Py_DECREF(par_requests_session);
    CHECK_OBJECT(par_client_credentials_manager);
    Py_DECREF(par_client_credentials_manager);
    CHECK_OBJECT(par_oauth_manager);
    Py_DECREF(par_oauth_manager);
    CHECK_OBJECT(par_auth_manager);
    Py_DECREF(par_auth_manager);
    CHECK_OBJECT(par_proxies);
    Py_DECREF(par_proxies);
    CHECK_OBJECT(par_requests_timeout);
    Py_DECREF(par_requests_timeout);
    CHECK_OBJECT(par_status_forcelist);
    Py_DECREF(par_status_forcelist);
    CHECK_OBJECT(par_retries);
    Py_DECREF(par_retries);
    CHECK_OBJECT(par_status_retries);
    Py_DECREF(par_status_retries);
    CHECK_OBJECT(par_backoff_factor);
    Py_DECREF(par_backoff_factor);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_auth);
    Py_DECREF(par_auth);
    CHECK_OBJECT(par_requests_session);
    Py_DECREF(par_requests_session);
    CHECK_OBJECT(par_client_credentials_manager);
    Py_DECREF(par_client_credentials_manager);
    CHECK_OBJECT(par_oauth_manager);
    Py_DECREF(par_oauth_manager);
    CHECK_OBJECT(par_auth_manager);
    Py_DECREF(par_auth_manager);
    CHECK_OBJECT(par_proxies);
    Py_DECREF(par_proxies);
    CHECK_OBJECT(par_requests_timeout);
    Py_DECREF(par_requests_timeout);
    CHECK_OBJECT(par_status_forcelist);
    Py_DECREF(par_status_forcelist);
    CHECK_OBJECT(par_retries);
    Py_DECREF(par_retries);
    CHECK_OBJECT(par_status_retries);
    Py_DECREF(par_status_retries);
    CHECK_OBJECT(par_backoff_factor);
    Py_DECREF(par_backoff_factor);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_2_set_auth(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_auth = python_pars[1];
    struct Nuitka_FrameObject *frame_c7dae76b69bbb3064292f499d2086aba;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c7dae76b69bbb3064292f499d2086aba = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_c7dae76b69bbb3064292f499d2086aba)) {
        Py_XDECREF(cache_frame_c7dae76b69bbb3064292f499d2086aba);

#if _DEBUG_REFCOUNTS
        if (cache_frame_c7dae76b69bbb3064292f499d2086aba == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_c7dae76b69bbb3064292f499d2086aba = MAKE_FUNCTION_FRAME(codeobj_c7dae76b69bbb3064292f499d2086aba, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_c7dae76b69bbb3064292f499d2086aba->m_type_description == NULL);
    frame_c7dae76b69bbb3064292f499d2086aba = cache_frame_c7dae76b69bbb3064292f499d2086aba;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c7dae76b69bbb3064292f499d2086aba);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c7dae76b69bbb3064292f499d2086aba) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_auth);
        tmp_assattr_name_1 = par_auth;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__auth, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 104;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7dae76b69bbb3064292f499d2086aba);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c7dae76b69bbb3064292f499d2086aba);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c7dae76b69bbb3064292f499d2086aba, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_c7dae76b69bbb3064292f499d2086aba->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c7dae76b69bbb3064292f499d2086aba, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_c7dae76b69bbb3064292f499d2086aba,
        type_description_1,
        par_self,
        par_auth
    );


    // Release cached frame.
    if (frame_c7dae76b69bbb3064292f499d2086aba == cache_frame_c7dae76b69bbb3064292f499d2086aba) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_c7dae76b69bbb3064292f499d2086aba);
    }
    cache_frame_c7dae76b69bbb3064292f499d2086aba = NULL;

    assertFrameObject(frame_c7dae76b69bbb3064292f499d2086aba);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_auth);
    Py_DECREF(par_auth);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_auth);
    Py_DECREF(par_auth);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_3_auth_manager(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_732a0999f6a8d395b9c177f40b3df467;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_732a0999f6a8d395b9c177f40b3df467 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_732a0999f6a8d395b9c177f40b3df467)) {
        Py_XDECREF(cache_frame_732a0999f6a8d395b9c177f40b3df467);

#if _DEBUG_REFCOUNTS
        if (cache_frame_732a0999f6a8d395b9c177f40b3df467 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_732a0999f6a8d395b9c177f40b3df467 = MAKE_FUNCTION_FRAME(codeobj_732a0999f6a8d395b9c177f40b3df467, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_732a0999f6a8d395b9c177f40b3df467->m_type_description == NULL);
    frame_732a0999f6a8d395b9c177f40b3df467 = cache_frame_732a0999f6a8d395b9c177f40b3df467;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_732a0999f6a8d395b9c177f40b3df467);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_732a0999f6a8d395b9c177f40b3df467) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_expression_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_return_value = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__auth_manager);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 108;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_732a0999f6a8d395b9c177f40b3df467);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_732a0999f6a8d395b9c177f40b3df467);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_732a0999f6a8d395b9c177f40b3df467);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_732a0999f6a8d395b9c177f40b3df467, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_732a0999f6a8d395b9c177f40b3df467->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_732a0999f6a8d395b9c177f40b3df467, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_732a0999f6a8d395b9c177f40b3df467,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_732a0999f6a8d395b9c177f40b3df467 == cache_frame_732a0999f6a8d395b9c177f40b3df467) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_732a0999f6a8d395b9c177f40b3df467);
    }
    cache_frame_732a0999f6a8d395b9c177f40b3df467 = NULL;

    assertFrameObject(frame_732a0999f6a8d395b9c177f40b3df467);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_4_auth_manager(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_auth_manager = python_pars[1];
    struct Nuitka_FrameObject *frame_eb387851309ccb53c81037c3614740f6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_eb387851309ccb53c81037c3614740f6 = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_eb387851309ccb53c81037c3614740f6)) {
        Py_XDECREF(cache_frame_eb387851309ccb53c81037c3614740f6);

#if _DEBUG_REFCOUNTS
        if (cache_frame_eb387851309ccb53c81037c3614740f6 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_eb387851309ccb53c81037c3614740f6 = MAKE_FUNCTION_FRAME(codeobj_eb387851309ccb53c81037c3614740f6, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_eb387851309ccb53c81037c3614740f6->m_type_description == NULL);
    frame_eb387851309ccb53c81037c3614740f6 = cache_frame_eb387851309ccb53c81037c3614740f6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_eb387851309ccb53c81037c3614740f6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_eb387851309ccb53c81037c3614740f6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_auth_manager);
        tmp_compexpr_left_1 = par_auth_manager;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        CHECK_OBJECT(par_auth_manager);
        tmp_assattr_name_1 = par_auth_manager;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__auth_manager, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 113;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    goto branch_end_1;
    branch_no_1:;
    {
        PyObject *tmp_assattr_name_2;
        int tmp_or_left_truth_1;
        PyObject *tmp_or_left_value_1;
        PyObject *tmp_or_right_value_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_assattr_target_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_or_left_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_client_credentials_manager);
        if (tmp_or_left_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 116;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_truth_1 = CHECK_IF_TRUE(tmp_or_left_value_1);
        if (tmp_or_left_truth_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_or_left_value_1);

            exception_lineno = 116;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        Py_DECREF(tmp_or_left_value_1);
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_or_right_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_oauth_manager);
        if (tmp_or_right_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 116;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_assattr_name_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_assattr_name_2 = tmp_or_left_value_1;
        or_end_1:;
        CHECK_OBJECT(par_self);
        tmp_assattr_target_2 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain__auth_manager, tmp_assattr_name_2);
        Py_DECREF(tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 115;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
    }
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb387851309ccb53c81037c3614740f6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb387851309ccb53c81037c3614740f6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_eb387851309ccb53c81037c3614740f6, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_eb387851309ccb53c81037c3614740f6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_eb387851309ccb53c81037c3614740f6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_eb387851309ccb53c81037c3614740f6,
        type_description_1,
        par_self,
        par_auth_manager
    );


    // Release cached frame.
    if (frame_eb387851309ccb53c81037c3614740f6 == cache_frame_eb387851309ccb53c81037c3614740f6) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_eb387851309ccb53c81037c3614740f6);
    }
    cache_frame_eb387851309ccb53c81037c3614740f6 = NULL;

    assertFrameObject(frame_eb387851309ccb53c81037c3614740f6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_auth_manager);
    Py_DECREF(par_auth_manager);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_auth_manager);
    Py_DECREF(par_auth_manager);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_5___del__(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_5ba07520ccb205f02209ae0d2350fdfc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_5ba07520ccb205f02209ae0d2350fdfc = NULL;
    PyObject *tmp_return_value = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_5ba07520ccb205f02209ae0d2350fdfc)) {
        Py_XDECREF(cache_frame_5ba07520ccb205f02209ae0d2350fdfc);

#if _DEBUG_REFCOUNTS
        if (cache_frame_5ba07520ccb205f02209ae0d2350fdfc == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_5ba07520ccb205f02209ae0d2350fdfc = MAKE_FUNCTION_FRAME(codeobj_5ba07520ccb205f02209ae0d2350fdfc, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_5ba07520ccb205f02209ae0d2350fdfc->m_type_description == NULL);
    frame_5ba07520ccb205f02209ae0d2350fdfc = cache_frame_5ba07520ccb205f02209ae0d2350fdfc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5ba07520ccb205f02209ae0d2350fdfc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5ba07520ccb205f02209ae0d2350fdfc) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_isinstance_inst_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__session);
        if (tmp_isinstance_inst_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 121;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_1 == NULL) {
            Py_DECREF(tmp_isinstance_inst_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 121;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_2 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_Session);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_isinstance_inst_1);

            exception_lineno = 121;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_inst_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 121;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_call_result_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_3 = par_self;
        tmp_called_instance_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain__session);
        if (tmp_called_instance_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        frame_5ba07520ccb205f02209ae0d2350fdfc->m_frame.f_lineno = 122;
        tmp_call_result_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_close);
        Py_DECREF(tmp_called_instance_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 122;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    branch_no_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5ba07520ccb205f02209ae0d2350fdfc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5ba07520ccb205f02209ae0d2350fdfc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5ba07520ccb205f02209ae0d2350fdfc, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_5ba07520ccb205f02209ae0d2350fdfc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5ba07520ccb205f02209ae0d2350fdfc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_5ba07520ccb205f02209ae0d2350fdfc,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_5ba07520ccb205f02209ae0d2350fdfc == cache_frame_5ba07520ccb205f02209ae0d2350fdfc) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_5ba07520ccb205f02209ae0d2350fdfc);
    }
    cache_frame_5ba07520ccb205f02209ae0d2350fdfc = NULL;

    assertFrameObject(frame_5ba07520ccb205f02209ae0d2350fdfc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_6__build_session(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_retry = NULL;
    PyObject *var_adapter = NULL;
    struct Nuitka_FrameObject *frame_3aea55e6c7de9115dae8ec0ba396670e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    int tmp_res;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    static struct Nuitka_FrameObject *cache_frame_3aea55e6c7de9115dae8ec0ba396670e = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_3aea55e6c7de9115dae8ec0ba396670e)) {
        Py_XDECREF(cache_frame_3aea55e6c7de9115dae8ec0ba396670e);

#if _DEBUG_REFCOUNTS
        if (cache_frame_3aea55e6c7de9115dae8ec0ba396670e == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_3aea55e6c7de9115dae8ec0ba396670e = MAKE_FUNCTION_FRAME(codeobj_3aea55e6c7de9115dae8ec0ba396670e, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_3aea55e6c7de9115dae8ec0ba396670e->m_type_description == NULL);
    frame_3aea55e6c7de9115dae8ec0ba396670e = cache_frame_3aea55e6c7de9115dae8ec0ba396670e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3aea55e6c7de9115dae8ec0ba396670e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3aea55e6c7de9115dae8ec0ba396670e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_assattr_target_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 125;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_3aea55e6c7de9115dae8ec0ba396670e->m_frame.f_lineno = 125;
        tmp_assattr_name_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_Session);
        if (tmp_assattr_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 125;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_assattr_target_1 = par_self;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain__session, tmp_assattr_name_1);
        Py_DECREF(tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 125;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        PyObject *tmp_expression_name_4;
        PyObject *tmp_dict_key_6;
        PyObject *tmp_dict_value_6;
        PyObject *tmp_expression_name_5;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_urllib3);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_urllib3);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 8205 ], 29, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 126;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_1 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_Retry);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 126;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_1 = const_str_plain_total;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_dict_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_retries);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 127;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 6 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_connect;
        tmp_dict_value_2 = Py_None;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_read;
        tmp_dict_value_3 = Py_False;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_status;
        CHECK_OBJECT(par_self);
        tmp_expression_name_3 = par_self;
        tmp_dict_value_4 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain_status_retries);
        if (tmp_dict_value_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);

            exception_lineno = 130;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        Py_DECREF(tmp_dict_value_4);
        assert(!(tmp_res != 0));
        tmp_dict_key_5 = const_str_plain_backoff_factor;
        CHECK_OBJECT(par_self);
        tmp_expression_name_4 = par_self;
        tmp_dict_value_5 = LOOKUP_ATTRIBUTE(tmp_expression_name_4, const_str_plain_backoff_factor);
        if (tmp_dict_value_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);

            exception_lineno = 131;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5);
        Py_DECREF(tmp_dict_value_5);
        assert(!(tmp_res != 0));
        tmp_dict_key_6 = const_str_plain_status_forcelist;
        CHECK_OBJECT(par_self);
        tmp_expression_name_5 = par_self;
        tmp_dict_value_6 = LOOKUP_ATTRIBUTE(tmp_expression_name_5, const_str_plain_status_forcelist);
        if (tmp_dict_value_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_kw_name_1);

            exception_lineno = 132;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_6, tmp_dict_value_6);
        Py_DECREF(tmp_dict_value_6);
        assert(!(tmp_res != 0));
        frame_3aea55e6c7de9115dae8ec0ba396670e->m_frame.f_lineno = 126;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 126;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_retry == NULL);
        var_retry = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_6;
        PyObject *tmp_expression_name_7;
        PyObject *tmp_mvar_value_3;
        PyObject *tmp_kw_name_2;
        PyObject *tmp_dict_key_7;
        PyObject *tmp_dict_value_7;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 134;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_7 = tmp_mvar_value_3;
        tmp_expression_name_6 = LOOKUP_ATTRIBUTE(tmp_expression_name_7, const_str_plain_adapters);
        if (tmp_expression_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 134;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_6, const_str_plain_HTTPAdapter);
        Py_DECREF(tmp_expression_name_6);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 134;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_dict_key_7 = const_str_plain_max_retries;
        CHECK_OBJECT(var_retry);
        tmp_dict_value_7 = var_retry;
        tmp_kw_name_2 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_2, tmp_dict_key_7, tmp_dict_value_7);
        assert(!(tmp_res != 0));
        frame_3aea55e6c7de9115dae8ec0ba396670e->m_frame.f_lineno = 134;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_2, tmp_kw_name_2);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_kw_name_2);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 134;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_adapter == NULL);
        var_adapter = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_expression_name_8;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_8 = par_self;
        tmp_called_instance_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_8, const_str_plain__session);
        if (tmp_called_instance_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 135;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_digest_7c06a402579f6f9d9db7f3e04da983fc;
        CHECK_OBJECT(var_adapter);
        tmp_args_element_name_2 = var_adapter;
        frame_3aea55e6c7de9115dae8ec0ba396670e->m_frame.f_lineno = 135;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain_mount, call_args);
        }

        Py_DECREF(tmp_called_instance_2);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 135;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_expression_name_9;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_9 = par_self;
        tmp_called_instance_3 = LOOKUP_ATTRIBUTE(tmp_expression_name_9, const_str_plain__session);
        if (tmp_called_instance_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 136;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = const_str_digest_504b77692b694460b8c25198a52c83ba;
        CHECK_OBJECT(var_adapter);
        tmp_args_element_name_4 = var_adapter;
        frame_3aea55e6c7de9115dae8ec0ba396670e->m_frame.f_lineno = 136;
        {
            PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain_mount, call_args);
        }

        Py_DECREF(tmp_called_instance_3);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 136;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aea55e6c7de9115dae8ec0ba396670e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3aea55e6c7de9115dae8ec0ba396670e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3aea55e6c7de9115dae8ec0ba396670e, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_3aea55e6c7de9115dae8ec0ba396670e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3aea55e6c7de9115dae8ec0ba396670e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_3aea55e6c7de9115dae8ec0ba396670e,
        type_description_1,
        par_self,
        var_retry,
        var_adapter
    );


    // Release cached frame.
    if (frame_3aea55e6c7de9115dae8ec0ba396670e == cache_frame_3aea55e6c7de9115dae8ec0ba396670e) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_3aea55e6c7de9115dae8ec0ba396670e);
    }
    cache_frame_3aea55e6c7de9115dae8ec0ba396670e = NULL;

    assertFrameObject(frame_3aea55e6c7de9115dae8ec0ba396670e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_retry);
    Py_DECREF(var_retry);
    var_retry = NULL;

    CHECK_OBJECT(var_adapter);
    Py_DECREF(var_adapter);
    var_adapter = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_retry);
    var_retry = NULL;

    Py_XDECREF(var_adapter);
    var_adapter = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_7__auth_headers(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *var_token = NULL;
    struct Nuitka_FrameObject *frame_719e84962d68d77f7a035970f69e1a9a;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_719e84962d68d77f7a035970f69e1a9a = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_719e84962d68d77f7a035970f69e1a9a)) {
        Py_XDECREF(cache_frame_719e84962d68d77f7a035970f69e1a9a);

#if _DEBUG_REFCOUNTS
        if (cache_frame_719e84962d68d77f7a035970f69e1a9a == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_719e84962d68d77f7a035970f69e1a9a = MAKE_FUNCTION_FRAME(codeobj_719e84962d68d77f7a035970f69e1a9a, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_719e84962d68d77f7a035970f69e1a9a->m_type_description == NULL);
    frame_719e84962d68d77f7a035970f69e1a9a = cache_frame_719e84962d68d77f7a035970f69e1a9a;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_719e84962d68d77f7a035970f69e1a9a);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_719e84962d68d77f7a035970f69e1a9a) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_attribute_value_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_attribute_value_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__auth);
        if (tmp_attribute_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 139;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_attribute_value_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_1);

            exception_lineno = 139;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_expression_name_3;
        tmp_dict_key_1 = const_str_plain_Authorization;
        tmp_expression_name_2 = const_str_digest_424fcad737c334bc0999dd054930c345;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_format);
        assert(!(tmp_called_name_1 == NULL));
        CHECK_OBJECT(par_self);
        tmp_expression_name_3 = par_self;
        tmp_args_element_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain__auth);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 140;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_719e84962d68d77f7a035970f69e1a9a->m_frame.f_lineno = 140;
        tmp_dict_value_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 140;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_return_value, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        goto frame_return_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_expression_name_4;
        PyObject *tmp_attribute_value_2;
        int tmp_truth_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_4 = par_self;
        tmp_attribute_value_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_4, const_str_plain_auth_manager);
        if (tmp_attribute_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 141;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE(tmp_attribute_value_2);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_attribute_value_2);

            exception_lineno = 141;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_attribute_value_2);
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_5;
        PyObject *tmp_expression_name_6;
        PyObject *tmp_kw_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_6 = par_self;
        tmp_expression_name_5 = LOOKUP_ATTRIBUTE(tmp_expression_name_6, const_str_plain_auth_manager);
        if (tmp_expression_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 142;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_5, const_str_plain_get_access_token);
        Py_DECREF(tmp_expression_name_5);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 142;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_kw_name_1 = PyDict_Copy(const_dict_79c040486cc871a74ef4d9ecc0ccc16f);
        frame_719e84962d68d77f7a035970f69e1a9a->m_frame.f_lineno = 142;
        tmp_assign_source_1 = CALL_FUNCTION_WITH_KEYARGS(tmp_called_name_2, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 142;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        assert(var_token == NULL);
        var_token = tmp_assign_source_1;
    }
    {
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        tmp_dict_key_2 = const_str_plain_Authorization;
        tmp_called_instance_1 = const_str_digest_424fcad737c334bc0999dd054930c345;
        CHECK_OBJECT(var_token);
        tmp_args_element_name_2 = var_token;
        frame_719e84962d68d77f7a035970f69e1a9a->m_frame.f_lineno = 143;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_dict_value_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_dict_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 143;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_return_value, tmp_dict_key_2, tmp_dict_value_2);
        Py_DECREF(tmp_dict_value_2);
        assert(!(tmp_res != 0));
        goto frame_return_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    tmp_return_value = PyDict_New();
    goto frame_return_exit_1;
    branch_end_2:;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_719e84962d68d77f7a035970f69e1a9a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_719e84962d68d77f7a035970f69e1a9a);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_719e84962d68d77f7a035970f69e1a9a);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_719e84962d68d77f7a035970f69e1a9a, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_719e84962d68d77f7a035970f69e1a9a->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_719e84962d68d77f7a035970f69e1a9a, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_719e84962d68d77f7a035970f69e1a9a,
        type_description_1,
        par_self,
        var_token
    );


    // Release cached frame.
    if (frame_719e84962d68d77f7a035970f69e1a9a == cache_frame_719e84962d68d77f7a035970f69e1a9a) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_719e84962d68d77f7a035970f69e1a9a);
    }
    cache_frame_719e84962d68d77f7a035970f69e1a9a = NULL;

    assertFrameObject(frame_719e84962d68d77f7a035970f69e1a9a);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_token);
    var_token = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_token);
    var_token = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_8__internal_call(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_method = python_pars[1];
    PyObject *par_url = python_pars[2];
    PyObject *par_payload = python_pars[3];
    PyObject *par_params = python_pars[4];
    PyObject *var_args = NULL;
    PyObject *var_headers = NULL;
    PyObject *var_response = NULL;
    PyObject *var_results = NULL;
    PyObject *var_msg = NULL;
    int tmp_res;
    struct Nuitka_FrameObject *frame_495194454ffc762d87d48093ed2144a7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_preserved_type_2;
    PyObject *exception_preserved_value_2;
    PyTracebackObject *exception_preserved_tb_2;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_preserved_type_1;
    PyObject *exception_preserved_value_1;
    PyTracebackObject *exception_preserved_tb_1;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_495194454ffc762d87d48093ed2144a7 = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        tmp_dict_key_1 = const_str_plain_params;
        CHECK_OBJECT(par_params);
        tmp_dict_value_1 = par_params;
        tmp_assign_source_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        assert(var_args == NULL);
        var_args = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_495194454ffc762d87d48093ed2144a7)) {
        Py_XDECREF(cache_frame_495194454ffc762d87d48093ed2144a7);

#if _DEBUG_REFCOUNTS
        if (cache_frame_495194454ffc762d87d48093ed2144a7 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_495194454ffc762d87d48093ed2144a7 = MAKE_FUNCTION_FRAME(codeobj_495194454ffc762d87d48093ed2144a7, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_495194454ffc762d87d48093ed2144a7->m_type_description == NULL);
    frame_495194454ffc762d87d48093ed2144a7 = cache_frame_495194454ffc762d87d48093ed2144a7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_495194454ffc762d87d48093ed2144a7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_495194454ffc762d87d48093ed2144a7) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_url);
        tmp_called_instance_1 = par_url;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 149;
        tmp_operand_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_startswith, &PyTuple_GET_ITEM(const_tuple_str_plain_http_tuple, 0));

        if (tmp_operand_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 149;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        Py_DECREF(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 149;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_left_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_prefix);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 150;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_url);
        tmp_right_name_1 = par_url;
        tmp_assign_source_2 = BINARY_OPERATION_ADD_OBJECT_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_left_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 150;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_url;
            assert(old != NULL);
            par_url = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    branch_no_1:;
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 151;
        tmp_assign_source_3 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain__auth_headers);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 151;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_headers == NULL);
        var_headers = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_key_name_1;
        tmp_compexpr_left_1 = const_str_plain_content_type;
        CHECK_OBJECT(var_args);
        tmp_dict_name_1 = var_args;
        tmp_key_name_1 = const_str_plain_params;
        tmp_compexpr_right_1 = DICT_GET_ITEM(tmp_dict_name_1, tmp_key_name_1);
        if (tmp_compexpr_right_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 153;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 153;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_ass_subvalue_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_ass_subscribed_1;
        PyObject *tmp_ass_subscript_1;
        CHECK_OBJECT(var_args);
        tmp_dict_name_2 = var_args;
        tmp_key_name_2 = const_str_plain_params;
        tmp_expression_name_2 = DICT_GET_ITEM(tmp_dict_name_2, tmp_key_name_2);
        if (tmp_expression_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 154;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_1 = const_str_plain_content_type;
        tmp_ass_subvalue_1 = LOOKUP_SUBSCRIPT(tmp_expression_name_2, tmp_subscript_name_1);
        Py_DECREF(tmp_expression_name_2);
        if (tmp_ass_subvalue_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 154;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_headers);
        tmp_ass_subscribed_1 = var_headers;
        tmp_ass_subscript_1 = const_str_digest_6d6a615162e89eb148ba9bf8dbfc06d3;
        tmp_result = SET_SUBSCRIPT(tmp_ass_subscribed_1, tmp_ass_subscript_1, tmp_ass_subvalue_1);
        Py_DECREF(tmp_ass_subvalue_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 154;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_delsubscr_target_1;
        PyObject *tmp_dict_name_3;
        PyObject *tmp_key_name_3;
        PyObject *tmp_delsubscr_subscript_1;
        CHECK_OBJECT(var_args);
        tmp_dict_name_3 = var_args;
        tmp_key_name_3 = const_str_plain_params;
        tmp_delsubscr_target_1 = DICT_GET_ITEM(tmp_dict_name_3, tmp_key_name_3);
        if (tmp_delsubscr_target_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 155;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_delsubscr_subscript_1 = const_str_plain_content_type;
        tmp_result = DEL_SUBSCRIPT(tmp_delsubscr_target_1, tmp_delsubscr_subscript_1);
        Py_DECREF(tmp_delsubscr_target_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 155;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_payload);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_payload);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 156;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
    }
    branch_yes_3:;
    CHECK_OBJECT(par_payload);
    tmp_dictset_value = par_payload;
    CHECK_OBJECT(var_args);
    tmp_dictset_dict = var_args;
    tmp_dictset_key = const_str_plain_data;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    {
        PyObject *tmp_ass_subvalue_2;
        PyObject *tmp_ass_subscribed_2;
        PyObject *tmp_ass_subscript_2;
        tmp_ass_subvalue_2 = const_str_digest_1781891970018ef9597f363946d7327b;
        CHECK_OBJECT(var_headers);
        tmp_ass_subscribed_2 = var_headers;
        tmp_ass_subscript_2 = const_str_digest_6d6a615162e89eb148ba9bf8dbfc06d3;
        tmp_result = SET_SUBSCRIPT(tmp_ass_subscribed_2, tmp_ass_subscript_2, tmp_ass_subvalue_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 159;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
    }
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_2;
        CHECK_OBJECT(par_payload);
        tmp_truth_name_2 = CHECK_IF_TRUE(par_payload);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 160;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
    }
    branch_yes_4:;
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_args_element_name_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_json);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_json);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16783 ], 26, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 161;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_1;
        CHECK_OBJECT(par_payload);
        tmp_args_element_name_1 = par_payload;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 161;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_dumps, call_args);
        }

        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 161;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_args);
        tmp_dictset_dict = var_args;
        tmp_dictset_key = const_str_plain_data;
        tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
    }
    branch_no_4:;
    branch_end_2:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_called_instance_4;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 163;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_3 = tmp_mvar_value_2;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain_debug);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 163;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_2 = const_str_digest_32e139cf9c005363a7161616e92f1a08;
        CHECK_OBJECT(par_method);
        tmp_args_element_name_3 = par_method;
        CHECK_OBJECT(par_url);
        tmp_args_element_name_4 = par_url;
        CHECK_OBJECT(var_headers);
        tmp_args_element_name_5 = var_headers;
        CHECK_OBJECT(var_args);
        tmp_called_instance_4 = var_args;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 164;
        tmp_args_element_name_6 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_get, &PyTuple_GET_ITEM(const_tuple_str_plain_data_tuple, 0));

        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 164;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 163;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5, tmp_args_element_name_6};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS5(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 163;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_4;
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_expression_name_4;
        PyObject *tmp_expression_name_5;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_dircall_arg3_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_expression_name_6;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_expression_name_7;
        PyObject *tmp_dircall_arg4_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_5 = par_self;
        tmp_expression_name_4 = LOOKUP_ATTRIBUTE(tmp_expression_name_5, const_str_plain__session);
        if (tmp_expression_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 167;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_4, const_str_plain_request);
        Py_DECREF(tmp_expression_name_4);
        if (tmp_dircall_arg1_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 167;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        CHECK_OBJECT(par_method);
        tmp_tuple_element_1 = par_method;
        tmp_dircall_arg2_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_dircall_arg2_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_url);
        tmp_tuple_element_1 = par_url;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_dircall_arg2_1, 1, tmp_tuple_element_1);
        tmp_dict_key_2 = const_str_plain_headers;
        CHECK_OBJECT(var_headers);
        tmp_dict_value_2 = var_headers;
        tmp_dircall_arg3_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_dircall_arg3_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_proxies;
        CHECK_OBJECT(par_self);
        tmp_expression_name_6 = par_self;
        tmp_dict_value_3 = LOOKUP_ATTRIBUTE(tmp_expression_name_6, const_str_plain_proxies);
        if (tmp_dict_value_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_dircall_arg1_1);
            Py_DECREF(tmp_dircall_arg2_1);
            Py_DECREF(tmp_dircall_arg3_1);

            exception_lineno = 168;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        tmp_res = PyDict_SetItem(tmp_dircall_arg3_1, tmp_dict_key_3, tmp_dict_value_3);
        Py_DECREF(tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_timeout;
        CHECK_OBJECT(par_self);
        tmp_expression_name_7 = par_self;
        tmp_dict_value_4 = LOOKUP_ATTRIBUTE(tmp_expression_name_7, const_str_plain_requests_timeout);
        if (tmp_dict_value_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_dircall_arg1_1);
            Py_DECREF(tmp_dircall_arg2_1);
            Py_DECREF(tmp_dircall_arg3_1);

            exception_lineno = 169;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        tmp_res = PyDict_SetItem(tmp_dircall_arg3_1, tmp_dict_key_4, tmp_dict_value_4);
        Py_DECREF(tmp_dict_value_4);
        assert(!(tmp_res != 0));
        CHECK_OBJECT(var_args);
        tmp_dircall_arg4_1 = var_args;
        Py_INCREF(tmp_dircall_arg4_1);

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1, tmp_dircall_arg4_1};
            tmp_assign_source_4 = impl___internal__$$$function_8_complex_call_helper_pos_keywords_star_dict(dir_call_args);
        }
        if (tmp_assign_source_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 167;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        assert(var_response == NULL);
        var_response = tmp_assign_source_4;
    }
    {
        PyObject *tmp_called_instance_5;
        PyObject *tmp_call_result_2;
        CHECK_OBJECT(var_response);
        tmp_called_instance_5 = var_response;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 172;
        tmp_call_result_2 = CALL_METHOD_NO_ARGS(tmp_called_instance_5, const_str_plain_raise_for_status);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 172;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_2);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_called_instance_6;
        CHECK_OBJECT(var_response);
        tmp_called_instance_6 = var_response;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 173;
        tmp_assign_source_5 = CALL_METHOD_NO_ARGS(tmp_called_instance_6, const_str_plain_json);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 173;
            type_description_1 = "oooooooooo";
            goto try_except_handler_2;
        }
        assert(var_results == NULL);
        var_results = tmp_assign_source_5;
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_2 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF(exception_preserved_type_2);
    exception_preserved_value_2 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF(exception_preserved_value_2);
    exception_preserved_tb_2 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF(exception_preserved_tb_2);

    if (exception_keeper_tb_1 == NULL) {
        exception_keeper_tb_1 = MAKE_TRACEBACK(frame_495194454ffc762d87d48093ed2144a7, exception_keeper_lineno_1);
    } else if (exception_keeper_lineno_1 != 0) {
        exception_keeper_tb_1 = ADD_TRACEBACK(exception_keeper_tb_1, frame_495194454ffc762d87d48093ed2144a7, exception_keeper_lineno_1);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    PyException_SetTraceback(exception_keeper_value_1, (PyObject *)exception_keeper_tb_1);
    PUBLISH_EXCEPTION(&exception_keeper_type_1, &exception_keeper_value_1, &exception_keeper_tb_1);
    // Tried code:
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_expression_name_8;
        PyObject *tmp_expression_name_9;
        PyObject *tmp_mvar_value_3;
        tmp_compexpr_left_2 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 174;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_9 = tmp_mvar_value_3;
        tmp_expression_name_8 = LOOKUP_ATTRIBUTE(tmp_expression_name_9, const_str_plain_exceptions);
        if (tmp_expression_name_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 174;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_compexpr_right_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_8, const_str_plain_HTTPError);
        Py_DECREF(tmp_expression_name_8);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 174;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 174;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_5 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
    }
    branch_yes_5:;
    // Tried code:
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_expression_name_10;
        PyObject *tmp_expression_name_11;
        PyObject *tmp_called_instance_7;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_subscript_name_3;
        if (var_response == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 176;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }

        tmp_called_instance_7 = var_response;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 176;
        tmp_expression_name_11 = CALL_METHOD_NO_ARGS(tmp_called_instance_7, const_str_plain_json);
        if (tmp_expression_name_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 176;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        tmp_subscript_name_2 = const_str_plain_error;
        tmp_expression_name_10 = LOOKUP_SUBSCRIPT(tmp_expression_name_11, tmp_subscript_name_2);
        Py_DECREF(tmp_expression_name_11);
        if (tmp_expression_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 176;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        tmp_subscript_name_3 = const_str_plain_message;
        tmp_assign_source_6 = LOOKUP_SUBSCRIPT(tmp_expression_name_10, tmp_subscript_name_3);
        Py_DECREF(tmp_expression_name_10);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 176;
            type_description_1 = "oooooooooo";
            goto try_except_handler_4;
        }
        assert(var_msg == NULL);
        var_msg = tmp_assign_source_6;
    }
    goto try_end_2;
    // Exception handler code:
    try_except_handler_4:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Preserve existing published exception.
    exception_preserved_type_1 = EXC_TYPE(PyThreadState_GET());
    Py_XINCREF(exception_preserved_type_1);
    exception_preserved_value_1 = EXC_VALUE(PyThreadState_GET());
    Py_XINCREF(exception_preserved_value_1);
    exception_preserved_tb_1 = (PyTracebackObject *)EXC_TRACEBACK(PyThreadState_GET());
    Py_XINCREF(exception_preserved_tb_1);

    if (exception_keeper_tb_2 == NULL) {
        exception_keeper_tb_2 = MAKE_TRACEBACK(frame_495194454ffc762d87d48093ed2144a7, exception_keeper_lineno_2);
    } else if (exception_keeper_lineno_2 != 0) {
        exception_keeper_tb_2 = ADD_TRACEBACK(exception_keeper_tb_2, frame_495194454ffc762d87d48093ed2144a7, exception_keeper_lineno_2);
    }

    NORMALIZE_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    PyException_SetTraceback(exception_keeper_value_2, (PyObject *)exception_keeper_tb_2);
    PUBLISH_EXCEPTION(&exception_keeper_type_2, &exception_keeper_value_2, &exception_keeper_tb_2);
    // Tried code:
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        tmp_compexpr_left_3 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_3 = const_tuple_type_ValueError_type_KeyError_tuple;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_3, tmp_compexpr_right_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 177;
            type_description_1 = "oooooooooo";
            goto try_except_handler_5;
        }
        tmp_condition_result_6 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
    }
    branch_yes_6:;
    {
        PyObject *tmp_assign_source_7;
        tmp_assign_source_7 = const_str_plain_error;
        assert(var_msg == NULL);
        Py_INCREF(tmp_assign_source_7);
        var_msg = tmp_assign_source_7;
    }
    goto branch_end_6;
    branch_no_6:;
    tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
    if (unlikely(tmp_result == false)) {
        exception_lineno = 175;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_495194454ffc762d87d48093ed2144a7->m_frame) frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooooooo";
    goto try_except_handler_5;
    branch_end_6:;
    goto try_end_3;
    // Exception handler code:
    try_except_handler_5:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION(exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1);
    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto try_except_handler_3;
    // End of try:
    try_end_3:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION(exception_preserved_type_1, exception_preserved_value_1, exception_preserved_tb_1);
    goto try_end_2;
    NUITKA_CANNOT_GET_HERE("exception handler codes exits in all cases");
    return NULL;
    // End of try:
    try_end_2:;
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_12;
        PyObject *tmp_mvar_value_4;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        PyObject *tmp_args_element_name_9;
        PyObject *tmp_args_element_name_10;
        PyObject *tmp_expression_name_13;
        PyObject *tmp_args_element_name_11;
        tmp_mvar_value_4 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_4 == NULL)) {
            tmp_mvar_value_4 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_4 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 180;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_12 = tmp_mvar_value_4;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_12, const_str_plain_error);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 180;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_args_element_name_7 = const_str_digest_921be7d0436af20df73b917a524de443;
        CHECK_OBJECT(par_method);
        tmp_args_element_name_8 = par_method;
        CHECK_OBJECT(par_url);
        tmp_args_element_name_9 = par_url;
        if (var_response == NULL) {
            Py_DECREF(tmp_called_name_2);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 181;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_13 = var_response;
        tmp_args_element_name_10 = LOOKUP_ATTRIBUTE(tmp_expression_name_13, const_str_plain_status_code);
        if (tmp_args_element_name_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 181;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        if (var_msg == NULL) {
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_10);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "msg");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 181;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_args_element_name_11 = var_msg;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 180;
        {
            PyObject *call_args[] = {tmp_args_element_name_7, tmp_args_element_name_8, tmp_args_element_name_9, tmp_args_element_name_10, tmp_args_element_name_11};
            tmp_call_result_3 = CALL_FUNCTION_WITH_ARGS5(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_10);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 180;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        Py_DECREF(tmp_call_result_3);
    }
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_called_name_3;
        PyObject *tmp_mvar_value_5;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_expression_name_14;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_tuple_element_3;
        PyObject *tmp_expression_name_15;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        PyObject *tmp_expression_name_16;
        tmp_mvar_value_5 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_SpotifyException);

        if (unlikely(tmp_mvar_value_5 == NULL)) {
            tmp_mvar_value_5 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SpotifyException);
        }

        if (tmp_mvar_value_5 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16837 ], 38, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 183;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_name_3 = tmp_mvar_value_5;
        if (var_response == NULL) {

            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 184;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_14 = var_response;
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_14, const_str_plain_status_code);
        if (tmp_tuple_element_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 184;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_args_name_1 = PyTuple_New(3);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_2);
        tmp_tuple_element_2 = const_int_neg_1;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_args_name_1, 1, tmp_tuple_element_2);
        tmp_left_name_2 = const_str_digest_1e8919abc0a68df77aed3737901ad587;
        if (var_response == NULL) {
            Py_DECREF(tmp_args_name_1);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 186;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_15 = var_response;
        tmp_tuple_element_3 = LOOKUP_ATTRIBUTE(tmp_expression_name_15, const_str_plain_url);
        if (tmp_tuple_element_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_name_1);

            exception_lineno = 186;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_right_name_2 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_right_name_2, 0, tmp_tuple_element_3);
        if (var_msg == NULL) {
            Py_DECREF(tmp_args_name_1);
            Py_DECREF(tmp_right_name_2);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "msg");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 186;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_tuple_element_3 = var_msg;
        Py_INCREF(tmp_tuple_element_3);
        PyTuple_SET_ITEM(tmp_right_name_2, 1, tmp_tuple_element_3);
        tmp_tuple_element_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_2, tmp_right_name_2);
        Py_DECREF(tmp_right_name_2);
        if (tmp_tuple_element_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_name_1);

            exception_lineno = 186;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        PyTuple_SET_ITEM(tmp_args_name_1, 2, tmp_tuple_element_2);
        tmp_dict_key_5 = const_str_plain_headers;
        if (var_response == NULL) {
            Py_DECREF(tmp_args_name_1);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 187;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_16 = var_response;
        tmp_dict_value_5 = LOOKUP_ATTRIBUTE(tmp_expression_name_16, const_str_plain_headers);
        if (tmp_dict_value_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_name_1);

            exception_lineno = 187;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5);
        Py_DECREF(tmp_dict_value_5);
        assert(!(tmp_res != 0));
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 183;
        tmp_raise_type_1 = CALL_FUNCTION(tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_raise_type_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 183;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        exception_type = tmp_raise_type_1;
        exception_lineno = 183;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    goto branch_end_5;
    branch_no_5:;
    {
        nuitka_bool tmp_condition_result_7;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        PyObject *tmp_expression_name_17;
        PyObject *tmp_expression_name_18;
        PyObject *tmp_mvar_value_6;
        tmp_compexpr_left_4 = EXC_TYPE(PyThreadState_GET());
        tmp_mvar_value_6 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests);

        if (unlikely(tmp_mvar_value_6 == NULL)) {
            tmp_mvar_value_6 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_requests);
        }

        if (tmp_mvar_value_6 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16753 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 189;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_18 = tmp_mvar_value_6;
        tmp_expression_name_17 = LOOKUP_ATTRIBUTE(tmp_expression_name_18, const_str_plain_exceptions);
        if (tmp_expression_name_17 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 189;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_compexpr_right_4 = LOOKUP_ATTRIBUTE(tmp_expression_name_17, const_str_plain_RetryError);
        Py_DECREF(tmp_expression_name_17);
        if (tmp_compexpr_right_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 189;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_4, tmp_compexpr_right_4);
        Py_DECREF(tmp_compexpr_right_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 189;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_7 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
            goto branch_yes_7;
        } else {
            goto branch_no_7;
        }
    }
    branch_yes_7:;
    {
        PyObject *tmp_called_instance_8;
        PyObject *tmp_mvar_value_7;
        PyObject *tmp_call_result_4;
        tmp_mvar_value_7 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_7 == NULL)) {
            tmp_mvar_value_7 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_7 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 190;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_instance_8 = tmp_mvar_value_7;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 190;
        tmp_call_result_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_8, const_str_plain_error, &PyTuple_GET_ITEM(const_tuple_str_digest_5d829d81793681107bd9dec71adcd753_tuple, 0));

        if (tmp_call_result_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 190;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        Py_DECREF(tmp_call_result_4);
    }
    {
        PyObject *tmp_raise_type_2;
        PyObject *tmp_called_name_4;
        PyObject *tmp_mvar_value_8;
        PyObject *tmp_args_name_2;
        PyObject *tmp_tuple_element_4;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_3;
        PyObject *tmp_tuple_element_5;
        PyObject *tmp_expression_name_19;
        PyObject *tmp_kw_name_2;
        PyObject *tmp_dict_key_6;
        PyObject *tmp_dict_value_6;
        PyObject *tmp_expression_name_20;
        tmp_mvar_value_8 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_SpotifyException);

        if (unlikely(tmp_mvar_value_8 == NULL)) {
            tmp_mvar_value_8 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_SpotifyException);
        }

        if (tmp_mvar_value_8 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16837 ], 38, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 191;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_called_name_4 = tmp_mvar_value_8;
        tmp_tuple_element_4 = const_int_pos_599;
        tmp_args_name_2 = PyTuple_New(3);
        Py_INCREF(tmp_tuple_element_4);
        PyTuple_SET_ITEM(tmp_args_name_2, 0, tmp_tuple_element_4);
        tmp_tuple_element_4 = const_int_neg_1;
        Py_INCREF(tmp_tuple_element_4);
        PyTuple_SET_ITEM(tmp_args_name_2, 1, tmp_tuple_element_4);
        tmp_left_name_3 = const_str_digest_1e8919abc0a68df77aed3737901ad587;
        if (var_response == NULL) {
            Py_DECREF(tmp_args_name_2);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 194;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_19 = var_response;
        tmp_tuple_element_5 = LOOKUP_ATTRIBUTE(tmp_expression_name_19, const_str_plain_url);
        if (tmp_tuple_element_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_name_2);

            exception_lineno = 194;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_right_name_3 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_right_name_3, 0, tmp_tuple_element_5);
        tmp_tuple_element_5 = const_str_digest_07f46abe28b5e592c82e8deb6b13c902;
        Py_INCREF(tmp_tuple_element_5);
        PyTuple_SET_ITEM(tmp_right_name_3, 1, tmp_tuple_element_5);
        tmp_tuple_element_4 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_3, tmp_right_name_3);
        Py_DECREF(tmp_right_name_3);
        if (tmp_tuple_element_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_name_2);

            exception_lineno = 194;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        PyTuple_SET_ITEM(tmp_args_name_2, 2, tmp_tuple_element_4);
        tmp_dict_key_6 = const_str_plain_headers;
        if (var_response == NULL) {
            Py_DECREF(tmp_args_name_2);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "response");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 195;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }

        tmp_expression_name_20 = var_response;
        tmp_dict_value_6 = LOOKUP_ATTRIBUTE(tmp_expression_name_20, const_str_plain_headers);
        if (tmp_dict_value_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_args_name_2);

            exception_lineno = 195;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_kw_name_2 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_2, tmp_dict_key_6, tmp_dict_value_6);
        Py_DECREF(tmp_dict_value_6);
        assert(!(tmp_res != 0));
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 191;
        tmp_raise_type_2 = CALL_FUNCTION(tmp_called_name_4, tmp_args_name_2, tmp_kw_name_2);
        Py_DECREF(tmp_args_name_2);
        Py_DECREF(tmp_kw_name_2);
        if (tmp_raise_type_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 191;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        exception_type = tmp_raise_type_2;
        exception_lineno = 191;
        RAISE_EXCEPTION_WITH_TYPE(&exception_type, &exception_value, &exception_tb);
        type_description_1 = "oooooooooo";
        goto try_except_handler_3;
    }
    goto branch_end_7;
    branch_no_7:;
    {
        nuitka_bool tmp_condition_result_8;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        tmp_compexpr_left_5 = EXC_TYPE(PyThreadState_GET());
        tmp_compexpr_right_5 = PyExc_ValueError;
        tmp_res = EXCEPTION_MATCH_BOOL(tmp_compexpr_left_5, tmp_compexpr_right_5);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 197;
            type_description_1 = "oooooooooo";
            goto try_except_handler_3;
        }
        tmp_condition_result_8 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_8 == NUITKA_BOOL_TRUE) {
            goto branch_yes_8;
        } else {
            goto branch_no_8;
        }
    }
    branch_yes_8:;
    {
        PyObject *tmp_assign_source_8;
        tmp_assign_source_8 = Py_None;
        assert(var_results == NULL);
        Py_INCREF(tmp_assign_source_8);
        var_results = tmp_assign_source_8;
    }
    goto branch_end_8;
    branch_no_8:;
    tmp_result = RERAISE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
    if (unlikely(tmp_result == false)) {
        exception_lineno = 166;
    }

    if (exception_tb && exception_tb->tb_frame == &frame_495194454ffc762d87d48093ed2144a7->m_frame) frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = exception_tb->tb_lineno;
    type_description_1 = "oooooooooo";
    goto try_except_handler_3;
    branch_end_8:;
    branch_end_7:;
    branch_end_5:;
    goto try_end_4;
    // Exception handler code:
    try_except_handler_3:;
    exception_keeper_type_4 = exception_type;
    exception_keeper_value_4 = exception_value;
    exception_keeper_tb_4 = exception_tb;
    exception_keeper_lineno_4 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    // Restore previous exception.
    SET_CURRENT_EXCEPTION(exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2);
    // Re-raise.
    exception_type = exception_keeper_type_4;
    exception_value = exception_keeper_value_4;
    exception_tb = exception_keeper_tb_4;
    exception_lineno = exception_keeper_lineno_4;

    goto frame_exception_exit_1;
    // End of try:
    try_end_4:;
    // Restore previous exception.
    SET_CURRENT_EXCEPTION(exception_preserved_type_2, exception_preserved_value_2, exception_preserved_tb_2);
    goto try_end_1;
    NUITKA_CANNOT_GET_HERE("exception handler codes exits in all cases");
    return NULL;
    // End of try:
    try_end_1:;
    {
        PyObject *tmp_called_name_5;
        PyObject *tmp_expression_name_21;
        PyObject *tmp_mvar_value_9;
        PyObject *tmp_call_result_5;
        PyObject *tmp_args_element_name_12;
        PyObject *tmp_args_element_name_13;
        tmp_mvar_value_9 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_9 == NULL)) {
            tmp_mvar_value_9 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_9 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 200;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_21 = tmp_mvar_value_9;
        tmp_called_name_5 = LOOKUP_ATTRIBUTE(tmp_expression_name_21, const_str_plain_debug);
        if (tmp_called_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 200;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_12 = const_str_digest_14aa8f39ae92cdfa19768e4e257f6ad7;
        if (var_results == NULL) {
            Py_DECREF(tmp_called_name_5);
            exception_type = PyExc_UnboundLocalError;
            Py_INCREF(exception_type);
            exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "results");
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 200;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_13 = var_results;
        frame_495194454ffc762d87d48093ed2144a7->m_frame.f_lineno = 200;
        {
            PyObject *call_args[] = {tmp_args_element_name_12, tmp_args_element_name_13};
            tmp_call_result_5 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_5, call_args);
        }

        Py_DECREF(tmp_called_name_5);
        if (tmp_call_result_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 200;
            type_description_1 = "oooooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_5);
    }
    if (var_results == NULL) {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF(exception_type);
        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "results");
        exception_tb = NULL;
        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        CHAIN_EXCEPTION(exception_value);

        exception_lineno = 201;
        type_description_1 = "oooooooooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = var_results;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_495194454ffc762d87d48093ed2144a7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_495194454ffc762d87d48093ed2144a7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_495194454ffc762d87d48093ed2144a7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_495194454ffc762d87d48093ed2144a7, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_495194454ffc762d87d48093ed2144a7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_495194454ffc762d87d48093ed2144a7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_495194454ffc762d87d48093ed2144a7,
        type_description_1,
        par_self,
        par_method,
        par_url,
        par_payload,
        par_params,
        var_args,
        var_headers,
        var_response,
        var_results,
        var_msg
    );


    // Release cached frame.
    if (frame_495194454ffc762d87d48093ed2144a7 == cache_frame_495194454ffc762d87d48093ed2144a7) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_495194454ffc762d87d48093ed2144a7);
    }
    cache_frame_495194454ffc762d87d48093ed2144a7 = NULL;

    assertFrameObject(frame_495194454ffc762d87d48093ed2144a7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    par_url = NULL;

    CHECK_OBJECT(var_args);
    Py_DECREF(var_args);
    var_args = NULL;

    CHECK_OBJECT(var_headers);
    Py_DECREF(var_headers);
    var_headers = NULL;

    Py_XDECREF(var_response);
    var_response = NULL;

    Py_XDECREF(var_results);
    var_results = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_url);
    par_url = NULL;

    CHECK_OBJECT(var_args);
    Py_DECREF(var_args);
    var_args = NULL;

    Py_XDECREF(var_headers);
    var_headers = NULL;

    Py_XDECREF(var_response);
    var_response = NULL;

    Py_XDECREF(var_results);
    var_results = NULL;

    Py_XDECREF(var_msg);
    var_msg = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_method);
    Py_DECREF(par_method);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_params);
    Py_DECREF(par_params);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_method);
    Py_DECREF(par_method);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_params);
    Py_DECREF(par_params);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_9__get(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_url = python_pars[1];
    PyObject *par_args = python_pars[2];
    PyObject *par_payload = python_pars[3];
    PyObject *par_kwargs = python_pars[4];
    struct Nuitka_FrameObject *frame_2ca5dd22ca3a8bc538a80cd11b80d295;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295)) {
        Py_XDECREF(cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295 = MAKE_FUNCTION_FRAME(codeobj_2ca5dd22ca3a8bc538a80cd11b80d295, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295->m_type_description == NULL);
    frame_2ca5dd22ca3a8bc538a80cd11b80d295 = cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2ca5dd22ca3a8bc538a80cd11b80d295);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2ca5dd22ca3a8bc538a80cd11b80d295) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_args);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_args);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 204;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_kwargs);
        tmp_called_instance_1 = par_kwargs;
        CHECK_OBJECT(par_args);
        tmp_args_element_name_1 = par_args;
        frame_2ca5dd22ca3a8bc538a80cd11b80d295->m_frame.f_lineno = 205;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_update, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 205;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    branch_no_1:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        tmp_args_element_name_2 = const_str_plain_GET;
        CHECK_OBJECT(par_url);
        tmp_args_element_name_3 = par_url;
        CHECK_OBJECT(par_payload);
        tmp_args_element_name_4 = par_payload;
        CHECK_OBJECT(par_kwargs);
        tmp_args_element_name_5 = par_kwargs;
        frame_2ca5dd22ca3a8bc538a80cd11b80d295->m_frame.f_lineno = 207;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_return_value = CALL_METHOD_WITH_ARGS4(tmp_called_instance_2, const_str_plain__internal_call, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 207;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ca5dd22ca3a8bc538a80cd11b80d295);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ca5dd22ca3a8bc538a80cd11b80d295);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ca5dd22ca3a8bc538a80cd11b80d295);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2ca5dd22ca3a8bc538a80cd11b80d295, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2ca5dd22ca3a8bc538a80cd11b80d295->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2ca5dd22ca3a8bc538a80cd11b80d295, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2ca5dd22ca3a8bc538a80cd11b80d295,
        type_description_1,
        par_self,
        par_url,
        par_args,
        par_payload,
        par_kwargs
    );


    // Release cached frame.
    if (frame_2ca5dd22ca3a8bc538a80cd11b80d295 == cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2ca5dd22ca3a8bc538a80cd11b80d295);
    }
    cache_frame_2ca5dd22ca3a8bc538a80cd11b80d295 = NULL;

    assertFrameObject(frame_2ca5dd22ca3a8bc538a80cd11b80d295);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_10__post(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_url = python_pars[1];
    PyObject *par_args = python_pars[2];
    PyObject *par_payload = python_pars[3];
    PyObject *par_kwargs = python_pars[4];
    struct Nuitka_FrameObject *frame_19ef0cc82fd641b32820effcb6b76808;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_19ef0cc82fd641b32820effcb6b76808 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_19ef0cc82fd641b32820effcb6b76808)) {
        Py_XDECREF(cache_frame_19ef0cc82fd641b32820effcb6b76808);

#if _DEBUG_REFCOUNTS
        if (cache_frame_19ef0cc82fd641b32820effcb6b76808 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_19ef0cc82fd641b32820effcb6b76808 = MAKE_FUNCTION_FRAME(codeobj_19ef0cc82fd641b32820effcb6b76808, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_19ef0cc82fd641b32820effcb6b76808->m_type_description == NULL);
    frame_19ef0cc82fd641b32820effcb6b76808 = cache_frame_19ef0cc82fd641b32820effcb6b76808;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_19ef0cc82fd641b32820effcb6b76808);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_19ef0cc82fd641b32820effcb6b76808) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_args);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_args);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 210;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_kwargs);
        tmp_called_instance_1 = par_kwargs;
        CHECK_OBJECT(par_args);
        tmp_args_element_name_1 = par_args;
        frame_19ef0cc82fd641b32820effcb6b76808->m_frame.f_lineno = 211;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_update, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 211;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    branch_no_1:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        tmp_args_element_name_2 = const_str_plain_POST;
        CHECK_OBJECT(par_url);
        tmp_args_element_name_3 = par_url;
        CHECK_OBJECT(par_payload);
        tmp_args_element_name_4 = par_payload;
        CHECK_OBJECT(par_kwargs);
        tmp_args_element_name_5 = par_kwargs;
        frame_19ef0cc82fd641b32820effcb6b76808->m_frame.f_lineno = 212;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_return_value = CALL_METHOD_WITH_ARGS4(tmp_called_instance_2, const_str_plain__internal_call, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 212;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_19ef0cc82fd641b32820effcb6b76808);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_19ef0cc82fd641b32820effcb6b76808);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_19ef0cc82fd641b32820effcb6b76808);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_19ef0cc82fd641b32820effcb6b76808, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_19ef0cc82fd641b32820effcb6b76808->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_19ef0cc82fd641b32820effcb6b76808, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_19ef0cc82fd641b32820effcb6b76808,
        type_description_1,
        par_self,
        par_url,
        par_args,
        par_payload,
        par_kwargs
    );


    // Release cached frame.
    if (frame_19ef0cc82fd641b32820effcb6b76808 == cache_frame_19ef0cc82fd641b32820effcb6b76808) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_19ef0cc82fd641b32820effcb6b76808);
    }
    cache_frame_19ef0cc82fd641b32820effcb6b76808 = NULL;

    assertFrameObject(frame_19ef0cc82fd641b32820effcb6b76808);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_11__delete(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_url = python_pars[1];
    PyObject *par_args = python_pars[2];
    PyObject *par_payload = python_pars[3];
    PyObject *par_kwargs = python_pars[4];
    struct Nuitka_FrameObject *frame_fdd326dca52447a788f24431430bb6ad;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_fdd326dca52447a788f24431430bb6ad = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_fdd326dca52447a788f24431430bb6ad)) {
        Py_XDECREF(cache_frame_fdd326dca52447a788f24431430bb6ad);

#if _DEBUG_REFCOUNTS
        if (cache_frame_fdd326dca52447a788f24431430bb6ad == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_fdd326dca52447a788f24431430bb6ad = MAKE_FUNCTION_FRAME(codeobj_fdd326dca52447a788f24431430bb6ad, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_fdd326dca52447a788f24431430bb6ad->m_type_description == NULL);
    frame_fdd326dca52447a788f24431430bb6ad = cache_frame_fdd326dca52447a788f24431430bb6ad;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fdd326dca52447a788f24431430bb6ad);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fdd326dca52447a788f24431430bb6ad) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_args);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_args);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 215;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_kwargs);
        tmp_called_instance_1 = par_kwargs;
        CHECK_OBJECT(par_args);
        tmp_args_element_name_1 = par_args;
        frame_fdd326dca52447a788f24431430bb6ad->m_frame.f_lineno = 216;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_update, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 216;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    branch_no_1:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        tmp_args_element_name_2 = const_str_plain_DELETE;
        CHECK_OBJECT(par_url);
        tmp_args_element_name_3 = par_url;
        CHECK_OBJECT(par_payload);
        tmp_args_element_name_4 = par_payload;
        CHECK_OBJECT(par_kwargs);
        tmp_args_element_name_5 = par_kwargs;
        frame_fdd326dca52447a788f24431430bb6ad->m_frame.f_lineno = 217;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_return_value = CALL_METHOD_WITH_ARGS4(tmp_called_instance_2, const_str_plain__internal_call, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 217;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fdd326dca52447a788f24431430bb6ad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fdd326dca52447a788f24431430bb6ad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fdd326dca52447a788f24431430bb6ad);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fdd326dca52447a788f24431430bb6ad, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_fdd326dca52447a788f24431430bb6ad->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fdd326dca52447a788f24431430bb6ad, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_fdd326dca52447a788f24431430bb6ad,
        type_description_1,
        par_self,
        par_url,
        par_args,
        par_payload,
        par_kwargs
    );


    // Release cached frame.
    if (frame_fdd326dca52447a788f24431430bb6ad == cache_frame_fdd326dca52447a788f24431430bb6ad) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_fdd326dca52447a788f24431430bb6ad);
    }
    cache_frame_fdd326dca52447a788f24431430bb6ad = NULL;

    assertFrameObject(frame_fdd326dca52447a788f24431430bb6ad);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_12__put(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_url = python_pars[1];
    PyObject *par_args = python_pars[2];
    PyObject *par_payload = python_pars[3];
    PyObject *par_kwargs = python_pars[4];
    struct Nuitka_FrameObject *frame_0549faef48236c7d313fa9148d7f2f51;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0549faef48236c7d313fa9148d7f2f51 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_0549faef48236c7d313fa9148d7f2f51)) {
        Py_XDECREF(cache_frame_0549faef48236c7d313fa9148d7f2f51);

#if _DEBUG_REFCOUNTS
        if (cache_frame_0549faef48236c7d313fa9148d7f2f51 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_0549faef48236c7d313fa9148d7f2f51 = MAKE_FUNCTION_FRAME(codeobj_0549faef48236c7d313fa9148d7f2f51, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_0549faef48236c7d313fa9148d7f2f51->m_type_description == NULL);
    frame_0549faef48236c7d313fa9148d7f2f51 = cache_frame_0549faef48236c7d313fa9148d7f2f51;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0549faef48236c7d313fa9148d7f2f51);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0549faef48236c7d313fa9148d7f2f51) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_args);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_args);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 220;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        CHECK_OBJECT(par_kwargs);
        tmp_called_instance_1 = par_kwargs;
        CHECK_OBJECT(par_args);
        tmp_args_element_name_1 = par_args;
        frame_0549faef48236c7d313fa9148d7f2f51->m_frame.f_lineno = 221;
        {
            PyObject *call_args[] = {tmp_args_element_name_1};
            tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_update, call_args);
        }

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 221;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    branch_no_1:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        tmp_args_element_name_2 = const_str_plain_PUT;
        CHECK_OBJECT(par_url);
        tmp_args_element_name_3 = par_url;
        CHECK_OBJECT(par_payload);
        tmp_args_element_name_4 = par_payload;
        CHECK_OBJECT(par_kwargs);
        tmp_args_element_name_5 = par_kwargs;
        frame_0549faef48236c7d313fa9148d7f2f51->m_frame.f_lineno = 222;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_return_value = CALL_METHOD_WITH_ARGS4(tmp_called_instance_2, const_str_plain__internal_call, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 222;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0549faef48236c7d313fa9148d7f2f51);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0549faef48236c7d313fa9148d7f2f51);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0549faef48236c7d313fa9148d7f2f51);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0549faef48236c7d313fa9148d7f2f51, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_0549faef48236c7d313fa9148d7f2f51->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0549faef48236c7d313fa9148d7f2f51, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_0549faef48236c7d313fa9148d7f2f51,
        type_description_1,
        par_self,
        par_url,
        par_args,
        par_payload,
        par_kwargs
    );


    // Release cached frame.
    if (frame_0549faef48236c7d313fa9148d7f2f51 == cache_frame_0549faef48236c7d313fa9148d7f2f51) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_0549faef48236c7d313fa9148d7f2f51);
    }
    cache_frame_0549faef48236c7d313fa9148d7f2f51 = NULL;

    assertFrameObject(frame_0549faef48236c7d313fa9148d7f2f51);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_url);
    Py_DECREF(par_url);
    CHECK_OBJECT(par_args);
    Py_DECREF(par_args);
    CHECK_OBJECT(par_payload);
    Py_DECREF(par_payload);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_13_next(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_result = python_pars[1];
    struct Nuitka_FrameObject *frame_8643aa3a9324f9355635999f00ad57d9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_8643aa3a9324f9355635999f00ad57d9 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_8643aa3a9324f9355635999f00ad57d9)) {
        Py_XDECREF(cache_frame_8643aa3a9324f9355635999f00ad57d9);

#if _DEBUG_REFCOUNTS
        if (cache_frame_8643aa3a9324f9355635999f00ad57d9 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_8643aa3a9324f9355635999f00ad57d9 = MAKE_FUNCTION_FRAME(codeobj_8643aa3a9324f9355635999f00ad57d9, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_8643aa3a9324f9355635999f00ad57d9->m_type_description == NULL);
    frame_8643aa3a9324f9355635999f00ad57d9 = cache_frame_8643aa3a9324f9355635999f00ad57d9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8643aa3a9324f9355635999f00ad57d9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8643aa3a9324f9355635999f00ad57d9) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_subscript_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_result);
        tmp_expression_name_1 = par_result;
        tmp_subscript_name_1 = const_str_plain_next;
        tmp_subscript_result_1 = LOOKUP_SUBSCRIPT(tmp_expression_name_1, tmp_subscript_name_1);
        if (tmp_subscript_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 230;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_subscript_result_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_subscript_result_1);

            exception_lineno = 230;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_subscript_result_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_subscript_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 231;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_result);
        tmp_expression_name_3 = par_result;
        tmp_subscript_name_2 = const_str_plain_next;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT(tmp_expression_name_3, tmp_subscript_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 231;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_8643aa3a9324f9355635999f00ad57d9->m_frame.f_lineno = 231;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 231;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8643aa3a9324f9355635999f00ad57d9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8643aa3a9324f9355635999f00ad57d9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8643aa3a9324f9355635999f00ad57d9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8643aa3a9324f9355635999f00ad57d9, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_8643aa3a9324f9355635999f00ad57d9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8643aa3a9324f9355635999f00ad57d9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_8643aa3a9324f9355635999f00ad57d9,
        type_description_1,
        par_self,
        par_result
    );


    // Release cached frame.
    if (frame_8643aa3a9324f9355635999f00ad57d9 == cache_frame_8643aa3a9324f9355635999f00ad57d9) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_8643aa3a9324f9355635999f00ad57d9);
    }
    cache_frame_8643aa3a9324f9355635999f00ad57d9 = NULL;

    assertFrameObject(frame_8643aa3a9324f9355635999f00ad57d9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_14_previous(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_result = python_pars[1];
    struct Nuitka_FrameObject *frame_cb5e9701bc67a8bc731fc27811cda79b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cb5e9701bc67a8bc731fc27811cda79b = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_cb5e9701bc67a8bc731fc27811cda79b)) {
        Py_XDECREF(cache_frame_cb5e9701bc67a8bc731fc27811cda79b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_cb5e9701bc67a8bc731fc27811cda79b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_cb5e9701bc67a8bc731fc27811cda79b = MAKE_FUNCTION_FRAME(codeobj_cb5e9701bc67a8bc731fc27811cda79b, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_cb5e9701bc67a8bc731fc27811cda79b->m_type_description == NULL);
    frame_cb5e9701bc67a8bc731fc27811cda79b = cache_frame_cb5e9701bc67a8bc731fc27811cda79b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cb5e9701bc67a8bc731fc27811cda79b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cb5e9701bc67a8bc731fc27811cda79b) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_subscript_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_result);
        tmp_expression_name_1 = par_result;
        tmp_subscript_name_1 = const_str_plain_previous;
        tmp_subscript_result_1 = LOOKUP_SUBSCRIPT(tmp_expression_name_1, tmp_subscript_name_1);
        if (tmp_subscript_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 241;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_subscript_result_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_subscript_result_1);

            exception_lineno = 241;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_subscript_result_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_subscript_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_result);
        tmp_expression_name_3 = par_result;
        tmp_subscript_name_2 = const_str_plain_previous;
        tmp_args_element_name_1 = LOOKUP_SUBSCRIPT(tmp_expression_name_3, tmp_subscript_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_cb5e9701bc67a8bc731fc27811cda79b->m_frame.f_lineno = 242;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 242;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }
    goto branch_end_1;
    branch_no_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_end_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb5e9701bc67a8bc731fc27811cda79b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb5e9701bc67a8bc731fc27811cda79b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cb5e9701bc67a8bc731fc27811cda79b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cb5e9701bc67a8bc731fc27811cda79b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_cb5e9701bc67a8bc731fc27811cda79b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cb5e9701bc67a8bc731fc27811cda79b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_cb5e9701bc67a8bc731fc27811cda79b,
        type_description_1,
        par_self,
        par_result
    );


    // Release cached frame.
    if (frame_cb5e9701bc67a8bc731fc27811cda79b == cache_frame_cb5e9701bc67a8bc731fc27811cda79b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_cb5e9701bc67a8bc731fc27811cda79b);
    }
    cache_frame_cb5e9701bc67a8bc731fc27811cda79b = NULL;

    assertFrameObject(frame_cb5e9701bc67a8bc731fc27811cda79b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_result);
    Py_DECREF(par_result);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_15_track(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_track_id = python_pars[1];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_20dd0dc6cd05131a2d53502a9508f1ee;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_20dd0dc6cd05131a2d53502a9508f1ee = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_20dd0dc6cd05131a2d53502a9508f1ee)) {
        Py_XDECREF(cache_frame_20dd0dc6cd05131a2d53502a9508f1ee);

#if _DEBUG_REFCOUNTS
        if (cache_frame_20dd0dc6cd05131a2d53502a9508f1ee == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_20dd0dc6cd05131a2d53502a9508f1ee = MAKE_FUNCTION_FRAME(codeobj_20dd0dc6cd05131a2d53502a9508f1ee, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_20dd0dc6cd05131a2d53502a9508f1ee->m_type_description == NULL);
    frame_20dd0dc6cd05131a2d53502a9508f1ee = cache_frame_20dd0dc6cd05131a2d53502a9508f1ee;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_20dd0dc6cd05131a2d53502a9508f1ee);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_20dd0dc6cd05131a2d53502a9508f1ee) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_track;
        CHECK_OBJECT(par_track_id);
        tmp_args_element_name_2 = par_track_id;
        frame_20dd0dc6cd05131a2d53502a9508f1ee->m_frame.f_lineno = 253;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 253;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 254;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_63ccfd6c601861c5b2bf4382d0053b4d;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 254;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_20dd0dc6cd05131a2d53502a9508f1ee->m_frame.f_lineno = 254;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 254;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_20dd0dc6cd05131a2d53502a9508f1ee);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_20dd0dc6cd05131a2d53502a9508f1ee);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_20dd0dc6cd05131a2d53502a9508f1ee);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_20dd0dc6cd05131a2d53502a9508f1ee, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_20dd0dc6cd05131a2d53502a9508f1ee->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_20dd0dc6cd05131a2d53502a9508f1ee, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_20dd0dc6cd05131a2d53502a9508f1ee,
        type_description_1,
        par_self,
        par_track_id,
        var_trid
    );


    // Release cached frame.
    if (frame_20dd0dc6cd05131a2d53502a9508f1ee == cache_frame_20dd0dc6cd05131a2d53502a9508f1ee) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_20dd0dc6cd05131a2d53502a9508f1ee);
    }
    cache_frame_20dd0dc6cd05131a2d53502a9508f1ee = NULL;

    assertFrameObject(frame_20dd0dc6cd05131a2d53502a9508f1ee);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_track_id);
    Py_DECREF(par_track_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_track_id);
    Py_DECREF(par_track_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_16_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_tracks = python_pars[1];
    PyObject *par_market = python_pars[2];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_t = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_cea786226d325130b78da7385f8f8ba9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_ccb5f13133b0dfbba91f076d61030295_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_ccb5f13133b0dfbba91f076d61030295_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_cea786226d325130b78da7385f8f8ba9 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_cea786226d325130b78da7385f8f8ba9)) {
        Py_XDECREF(cache_frame_cea786226d325130b78da7385f8f8ba9);

#if _DEBUG_REFCOUNTS
        if (cache_frame_cea786226d325130b78da7385f8f8ba9 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_cea786226d325130b78da7385f8f8ba9 = MAKE_FUNCTION_FRAME(codeobj_cea786226d325130b78da7385f8f8ba9, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_cea786226d325130b78da7385f8f8ba9->m_type_description == NULL);
    frame_cea786226d325130b78da7385f8f8ba9 = cache_frame_cea786226d325130b78da7385f8f8ba9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_cea786226d325130b78da7385f8f8ba9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_cea786226d325130b78da7385f8f8ba9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 264;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_ccb5f13133b0dfbba91f076d61030295_2)) {
            Py_XDECREF(cache_frame_ccb5f13133b0dfbba91f076d61030295_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_ccb5f13133b0dfbba91f076d61030295_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_ccb5f13133b0dfbba91f076d61030295_2 = MAKE_FUNCTION_FRAME(codeobj_ccb5f13133b0dfbba91f076d61030295, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_ccb5f13133b0dfbba91f076d61030295_2->m_type_description == NULL);
        frame_ccb5f13133b0dfbba91f076d61030295_2 = cache_frame_ccb5f13133b0dfbba91f076d61030295_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_ccb5f13133b0dfbba91f076d61030295_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_ccb5f13133b0dfbba91f076d61030295_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 264;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_t;
                outline_0_var_t = tmp_assign_source_5;
                Py_INCREF(outline_0_var_t);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_t);
            tmp_args_element_name_2 = outline_0_var_t;
            frame_ccb5f13133b0dfbba91f076d61030295_2->m_frame.f_lineno = 264;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 264;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 264;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 264;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_ccb5f13133b0dfbba91f076d61030295_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_ccb5f13133b0dfbba91f076d61030295_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_ccb5f13133b0dfbba91f076d61030295_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_ccb5f13133b0dfbba91f076d61030295_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_ccb5f13133b0dfbba91f076d61030295_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_ccb5f13133b0dfbba91f076d61030295_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_ccb5f13133b0dfbba91f076d61030295_2,
            type_description_2,
            outline_0_var_t,
            par_self
        );


        // Release cached frame.
        if (frame_ccb5f13133b0dfbba91f076d61030295_2 == cache_frame_ccb5f13133b0dfbba91f076d61030295_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_ccb5f13133b0dfbba91f076d61030295_2);
        }
        cache_frame_ccb5f13133b0dfbba91f076d61030295_2 = NULL;

        assertFrameObject(frame_ccb5f13133b0dfbba91f076d61030295_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "oooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 264;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_a0a94d59c8ae6f19fa06528cbb359dd0;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_3 = var_tlist;
        frame_cea786226d325130b78da7385f8f8ba9->m_frame.f_lineno = 265;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 265;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 265;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_cea786226d325130b78da7385f8f8ba9->m_frame.f_lineno = 265;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 265;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cea786226d325130b78da7385f8f8ba9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_cea786226d325130b78da7385f8f8ba9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_cea786226d325130b78da7385f8f8ba9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_cea786226d325130b78da7385f8f8ba9, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_cea786226d325130b78da7385f8f8ba9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_cea786226d325130b78da7385f8f8ba9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_cea786226d325130b78da7385f8f8ba9,
        type_description_1,
        par_self,
        par_tracks,
        par_market,
        var_tlist
    );


    // Release cached frame.
    if (frame_cea786226d325130b78da7385f8f8ba9 == cache_frame_cea786226d325130b78da7385f8f8ba9) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_cea786226d325130b78da7385f8f8ba9);
    }
    cache_frame_cea786226d325130b78da7385f8f8ba9 = NULL;

    assertFrameObject(frame_cea786226d325130b78da7385f8f8ba9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_17_artist(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_artist_id = python_pars[1];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_5197084aa1655fcba879d05a0d251a83;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5197084aa1655fcba879d05a0d251a83 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_5197084aa1655fcba879d05a0d251a83)) {
        Py_XDECREF(cache_frame_5197084aa1655fcba879d05a0d251a83);

#if _DEBUG_REFCOUNTS
        if (cache_frame_5197084aa1655fcba879d05a0d251a83 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_5197084aa1655fcba879d05a0d251a83 = MAKE_FUNCTION_FRAME(codeobj_5197084aa1655fcba879d05a0d251a83, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_5197084aa1655fcba879d05a0d251a83->m_type_description == NULL);
    frame_5197084aa1655fcba879d05a0d251a83 = cache_frame_5197084aa1655fcba879d05a0d251a83;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5197084aa1655fcba879d05a0d251a83);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5197084aa1655fcba879d05a0d251a83) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_artist;
        CHECK_OBJECT(par_artist_id);
        tmp_args_element_name_2 = par_artist_id;
        frame_5197084aa1655fcba879d05a0d251a83->m_frame.f_lineno = 274;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 274;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_b105cfca3528b94b86600f9e31c46f44;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_5197084aa1655fcba879d05a0d251a83->m_frame.f_lineno = 275;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 275;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5197084aa1655fcba879d05a0d251a83);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5197084aa1655fcba879d05a0d251a83);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5197084aa1655fcba879d05a0d251a83);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5197084aa1655fcba879d05a0d251a83, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_5197084aa1655fcba879d05a0d251a83->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5197084aa1655fcba879d05a0d251a83, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_5197084aa1655fcba879d05a0d251a83,
        type_description_1,
        par_self,
        par_artist_id,
        var_trid
    );


    // Release cached frame.
    if (frame_5197084aa1655fcba879d05a0d251a83 == cache_frame_5197084aa1655fcba879d05a0d251a83) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_5197084aa1655fcba879d05a0d251a83);
    }
    cache_frame_5197084aa1655fcba879d05a0d251a83 = NULL;

    assertFrameObject(frame_5197084aa1655fcba879d05a0d251a83);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_18_artists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_artists = python_pars[1];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_a = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_84fc0dd7e3204da2c5289a919d64f506;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_6fbd9f0268750b41e458dd0b93defaa8_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_84fc0dd7e3204da2c5289a919d64f506 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_84fc0dd7e3204da2c5289a919d64f506)) {
        Py_XDECREF(cache_frame_84fc0dd7e3204da2c5289a919d64f506);

#if _DEBUG_REFCOUNTS
        if (cache_frame_84fc0dd7e3204da2c5289a919d64f506 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_84fc0dd7e3204da2c5289a919d64f506 = MAKE_FUNCTION_FRAME(codeobj_84fc0dd7e3204da2c5289a919d64f506, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_84fc0dd7e3204da2c5289a919d64f506->m_type_description == NULL);
    frame_84fc0dd7e3204da2c5289a919d64f506 = cache_frame_84fc0dd7e3204da2c5289a919d64f506;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_84fc0dd7e3204da2c5289a919d64f506);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_84fc0dd7e3204da2c5289a919d64f506) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_artists);
            tmp_iter_arg_1 = par_artists;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 284;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2)) {
            Py_XDECREF(cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2 = MAKE_FUNCTION_FRAME(codeobj_6fbd9f0268750b41e458dd0b93defaa8, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2->m_type_description == NULL);
        frame_6fbd9f0268750b41e458dd0b93defaa8_2 = cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_6fbd9f0268750b41e458dd0b93defaa8_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_6fbd9f0268750b41e458dd0b93defaa8_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 284;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_a;
                outline_0_var_a = tmp_assign_source_5;
                Py_INCREF(outline_0_var_a);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_artist;
            CHECK_OBJECT(outline_0_var_a);
            tmp_args_element_name_2 = outline_0_var_a;
            frame_6fbd9f0268750b41e458dd0b93defaa8_2->m_frame.f_lineno = 284;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 284;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 284;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 284;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_6fbd9f0268750b41e458dd0b93defaa8_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_6fbd9f0268750b41e458dd0b93defaa8_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_6fbd9f0268750b41e458dd0b93defaa8_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_6fbd9f0268750b41e458dd0b93defaa8_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_6fbd9f0268750b41e458dd0b93defaa8_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_6fbd9f0268750b41e458dd0b93defaa8_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_6fbd9f0268750b41e458dd0b93defaa8_2,
            type_description_2,
            outline_0_var_a,
            par_self
        );


        // Release cached frame.
        if (frame_6fbd9f0268750b41e458dd0b93defaa8_2 == cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_6fbd9f0268750b41e458dd0b93defaa8_2);
        }
        cache_frame_6fbd9f0268750b41e458dd0b93defaa8_2 = NULL;

        assertFrameObject(frame_6fbd9f0268750b41e458dd0b93defaa8_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 284;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 285;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_7af1b86e99338fd4edc6b03cce965252;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_4 = var_tlist;
        frame_84fc0dd7e3204da2c5289a919d64f506->m_frame.f_lineno = 285;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 285;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 285;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_84fc0dd7e3204da2c5289a919d64f506->m_frame.f_lineno = 285;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 285;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_84fc0dd7e3204da2c5289a919d64f506);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_84fc0dd7e3204da2c5289a919d64f506);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_84fc0dd7e3204da2c5289a919d64f506);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_84fc0dd7e3204da2c5289a919d64f506, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_84fc0dd7e3204da2c5289a919d64f506->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_84fc0dd7e3204da2c5289a919d64f506, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_84fc0dd7e3204da2c5289a919d64f506,
        type_description_1,
        par_self,
        par_artists,
        var_tlist
    );


    // Release cached frame.
    if (frame_84fc0dd7e3204da2c5289a919d64f506 == cache_frame_84fc0dd7e3204da2c5289a919d64f506) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_84fc0dd7e3204da2c5289a919d64f506);
    }
    cache_frame_84fc0dd7e3204da2c5289a919d64f506 = NULL;

    assertFrameObject(frame_84fc0dd7e3204da2c5289a919d64f506);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artists);
    Py_DECREF(par_artists);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artists);
    Py_DECREF(par_artists);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_19_artist_albums(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_artist_id = python_pars[1];
    PyObject *par_album_type = python_pars[2];
    PyObject *par_country = python_pars[3];
    PyObject *par_limit = python_pars[4];
    PyObject *par_offset = python_pars[5];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_7c852edbba3637af02ee8ae23c132a9c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_7c852edbba3637af02ee8ae23c132a9c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_7c852edbba3637af02ee8ae23c132a9c)) {
        Py_XDECREF(cache_frame_7c852edbba3637af02ee8ae23c132a9c);

#if _DEBUG_REFCOUNTS
        if (cache_frame_7c852edbba3637af02ee8ae23c132a9c == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_7c852edbba3637af02ee8ae23c132a9c = MAKE_FUNCTION_FRAME(codeobj_7c852edbba3637af02ee8ae23c132a9c, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_7c852edbba3637af02ee8ae23c132a9c->m_type_description == NULL);
    frame_7c852edbba3637af02ee8ae23c132a9c = cache_frame_7c852edbba3637af02ee8ae23c132a9c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_7c852edbba3637af02ee8ae23c132a9c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_7c852edbba3637af02ee8ae23c132a9c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_artist;
        CHECK_OBJECT(par_artist_id);
        tmp_args_element_name_2 = par_artist_id;
        frame_7c852edbba3637af02ee8ae23c132a9c->m_frame.f_lineno = 300;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 300;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 301;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_b105cfca3528b94b86600f9e31c46f44;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_1);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 302;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_digest_1a4d1829bf809cce5d46da7256560962;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_1, tmp_right_name_2);
        Py_DECREF(tmp_left_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 302;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_album_type;
        CHECK_OBJECT(par_album_type);
        tmp_dict_value_1 = par_album_type;
        tmp_kw_name_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_country;
        CHECK_OBJECT(par_country);
        tmp_dict_value_2 = par_country;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_3 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_4 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        frame_7c852edbba3637af02ee8ae23c132a9c->m_frame.f_lineno = 301;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 301;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c852edbba3637af02ee8ae23c132a9c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c852edbba3637af02ee8ae23c132a9c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_7c852edbba3637af02ee8ae23c132a9c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_7c852edbba3637af02ee8ae23c132a9c, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_7c852edbba3637af02ee8ae23c132a9c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_7c852edbba3637af02ee8ae23c132a9c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_7c852edbba3637af02ee8ae23c132a9c,
        type_description_1,
        par_self,
        par_artist_id,
        par_album_type,
        par_country,
        par_limit,
        par_offset,
        var_trid
    );


    // Release cached frame.
    if (frame_7c852edbba3637af02ee8ae23c132a9c == cache_frame_7c852edbba3637af02ee8ae23c132a9c) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_7c852edbba3637af02ee8ae23c132a9c);
    }
    cache_frame_7c852edbba3637af02ee8ae23c132a9c = NULL;

    assertFrameObject(frame_7c852edbba3637af02ee8ae23c132a9c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);
    CHECK_OBJECT(par_album_type);
    Py_DECREF(par_album_type);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);
    CHECK_OBJECT(par_album_type);
    Py_DECREF(par_album_type);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_20_artist_top_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_artist_id = python_pars[1];
    PyObject *par_country = python_pars[2];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_ca158fa9659faea697996b8861fbac5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_ca158fa9659faea697996b8861fbac5b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_ca158fa9659faea697996b8861fbac5b)) {
        Py_XDECREF(cache_frame_ca158fa9659faea697996b8861fbac5b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_ca158fa9659faea697996b8861fbac5b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_ca158fa9659faea697996b8861fbac5b = MAKE_FUNCTION_FRAME(codeobj_ca158fa9659faea697996b8861fbac5b, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_ca158fa9659faea697996b8861fbac5b->m_type_description == NULL);
    frame_ca158fa9659faea697996b8861fbac5b = cache_frame_ca158fa9659faea697996b8861fbac5b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ca158fa9659faea697996b8861fbac5b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ca158fa9659faea697996b8861fbac5b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_artist;
        CHECK_OBJECT(par_artist_id);
        tmp_args_element_name_2 = par_artist_id;
        frame_ca158fa9659faea697996b8861fbac5b->m_frame.f_lineno = 318;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 318;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 319;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_b105cfca3528b94b86600f9e31c46f44;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_1);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 319;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_digest_7d861053956b1ca5c8912878e2b1167a;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_1, tmp_right_name_2);
        Py_DECREF(tmp_left_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 319;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_country;
        CHECK_OBJECT(par_country);
        tmp_dict_value_1 = par_country;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_ca158fa9659faea697996b8861fbac5b->m_frame.f_lineno = 319;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 319;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ca158fa9659faea697996b8861fbac5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ca158fa9659faea697996b8861fbac5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ca158fa9659faea697996b8861fbac5b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ca158fa9659faea697996b8861fbac5b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_ca158fa9659faea697996b8861fbac5b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ca158fa9659faea697996b8861fbac5b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_ca158fa9659faea697996b8861fbac5b,
        type_description_1,
        par_self,
        par_artist_id,
        par_country,
        var_trid
    );


    // Release cached frame.
    if (frame_ca158fa9659faea697996b8861fbac5b == cache_frame_ca158fa9659faea697996b8861fbac5b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_ca158fa9659faea697996b8861fbac5b);
    }
    cache_frame_ca158fa9659faea697996b8861fbac5b = NULL;

    assertFrameObject(frame_ca158fa9659faea697996b8861fbac5b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_21_artist_related_artists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_artist_id = python_pars[1];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_9853ca544245558a309841b61c647a9d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_9853ca544245558a309841b61c647a9d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_9853ca544245558a309841b61c647a9d)) {
        Py_XDECREF(cache_frame_9853ca544245558a309841b61c647a9d);

#if _DEBUG_REFCOUNTS
        if (cache_frame_9853ca544245558a309841b61c647a9d == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_9853ca544245558a309841b61c647a9d = MAKE_FUNCTION_FRAME(codeobj_9853ca544245558a309841b61c647a9d, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_9853ca544245558a309841b61c647a9d->m_type_description == NULL);
    frame_9853ca544245558a309841b61c647a9d = cache_frame_9853ca544245558a309841b61c647a9d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_9853ca544245558a309841b61c647a9d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_9853ca544245558a309841b61c647a9d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_artist;
        CHECK_OBJECT(par_artist_id);
        tmp_args_element_name_2 = par_artist_id;
        frame_9853ca544245558a309841b61c647a9d->m_frame.f_lineno = 329;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 329;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 330;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_b105cfca3528b94b86600f9e31c46f44;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_1);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 330;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_digest_0e6e939b250c1a8ba18da5e85aa91db2;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_1, tmp_right_name_2);
        Py_DECREF(tmp_left_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 330;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_9853ca544245558a309841b61c647a9d->m_frame.f_lineno = 330;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 330;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9853ca544245558a309841b61c647a9d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_9853ca544245558a309841b61c647a9d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_9853ca544245558a309841b61c647a9d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_9853ca544245558a309841b61c647a9d, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_9853ca544245558a309841b61c647a9d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_9853ca544245558a309841b61c647a9d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_9853ca544245558a309841b61c647a9d,
        type_description_1,
        par_self,
        par_artist_id,
        var_trid
    );


    // Release cached frame.
    if (frame_9853ca544245558a309841b61c647a9d == cache_frame_9853ca544245558a309841b61c647a9d) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_9853ca544245558a309841b61c647a9d);
    }
    cache_frame_9853ca544245558a309841b61c647a9d = NULL;

    assertFrameObject(frame_9853ca544245558a309841b61c647a9d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_artist_id);
    Py_DECREF(par_artist_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_22_album(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_album_id = python_pars[1];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_3d5ba4d98fb2a674e58851f68e9ece08;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_3d5ba4d98fb2a674e58851f68e9ece08 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_3d5ba4d98fb2a674e58851f68e9ece08)) {
        Py_XDECREF(cache_frame_3d5ba4d98fb2a674e58851f68e9ece08);

#if _DEBUG_REFCOUNTS
        if (cache_frame_3d5ba4d98fb2a674e58851f68e9ece08 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_3d5ba4d98fb2a674e58851f68e9ece08 = MAKE_FUNCTION_FRAME(codeobj_3d5ba4d98fb2a674e58851f68e9ece08, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_3d5ba4d98fb2a674e58851f68e9ece08->m_type_description == NULL);
    frame_3d5ba4d98fb2a674e58851f68e9ece08 = cache_frame_3d5ba4d98fb2a674e58851f68e9ece08;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_3d5ba4d98fb2a674e58851f68e9ece08);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_3d5ba4d98fb2a674e58851f68e9ece08) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_album;
        CHECK_OBJECT(par_album_id);
        tmp_args_element_name_2 = par_album_id;
        frame_3d5ba4d98fb2a674e58851f68e9ece08->m_frame.f_lineno = 339;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 339;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_43e37e636612ec263698913cfae18f8d;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_3d5ba4d98fb2a674e58851f68e9ece08->m_frame.f_lineno = 340;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 340;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3d5ba4d98fb2a674e58851f68e9ece08);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_3d5ba4d98fb2a674e58851f68e9ece08);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_3d5ba4d98fb2a674e58851f68e9ece08);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_3d5ba4d98fb2a674e58851f68e9ece08, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_3d5ba4d98fb2a674e58851f68e9ece08->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_3d5ba4d98fb2a674e58851f68e9ece08, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_3d5ba4d98fb2a674e58851f68e9ece08,
        type_description_1,
        par_self,
        par_album_id,
        var_trid
    );


    // Release cached frame.
    if (frame_3d5ba4d98fb2a674e58851f68e9ece08 == cache_frame_3d5ba4d98fb2a674e58851f68e9ece08) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_3d5ba4d98fb2a674e58851f68e9ece08);
    }
    cache_frame_3d5ba4d98fb2a674e58851f68e9ece08 = NULL;

    assertFrameObject(frame_3d5ba4d98fb2a674e58851f68e9ece08);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_album_id);
    Py_DECREF(par_album_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_album_id);
    Py_DECREF(par_album_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_23_album_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_album_id = python_pars[1];
    PyObject *par_limit = python_pars[2];
    PyObject *par_offset = python_pars[3];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_b1c87682ae63b69b7d39c8f7d942d1f0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0)) {
        Py_XDECREF(cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0);

#if _DEBUG_REFCOUNTS
        if (cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0 = MAKE_FUNCTION_FRAME(codeobj_b1c87682ae63b69b7d39c8f7d942d1f0, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0->m_type_description == NULL);
    frame_b1c87682ae63b69b7d39c8f7d942d1f0 = cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b1c87682ae63b69b7d39c8f7d942d1f0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b1c87682ae63b69b7d39c8f7d942d1f0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_album;
        CHECK_OBJECT(par_album_id);
        tmp_args_element_name_2 = par_album_id;
        frame_b1c87682ae63b69b7d39c8f7d942d1f0->m_frame.f_lineno = 351;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 351;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_43e37e636612ec263698913cfae18f8d;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_1);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 353;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_digest_614602b0b9c0300e03c45bbfd5d983fd;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_1, tmp_right_name_2);
        Py_DECREF(tmp_left_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 353;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_b1c87682ae63b69b7d39c8f7d942d1f0->m_frame.f_lineno = 352;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 352;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1c87682ae63b69b7d39c8f7d942d1f0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1c87682ae63b69b7d39c8f7d942d1f0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b1c87682ae63b69b7d39c8f7d942d1f0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b1c87682ae63b69b7d39c8f7d942d1f0, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_b1c87682ae63b69b7d39c8f7d942d1f0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b1c87682ae63b69b7d39c8f7d942d1f0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_b1c87682ae63b69b7d39c8f7d942d1f0,
        type_description_1,
        par_self,
        par_album_id,
        par_limit,
        par_offset,
        var_trid
    );


    // Release cached frame.
    if (frame_b1c87682ae63b69b7d39c8f7d942d1f0 == cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_b1c87682ae63b69b7d39c8f7d942d1f0);
    }
    cache_frame_b1c87682ae63b69b7d39c8f7d942d1f0 = NULL;

    assertFrameObject(frame_b1c87682ae63b69b7d39c8f7d942d1f0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_album_id);
    Py_DECREF(par_album_id);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_album_id);
    Py_DECREF(par_album_id);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_24_albums(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_albums = python_pars[1];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_a = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_715a641a572181e14e9adaab487920f4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_12b493fa58299085ea49015dfa1e4296_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_12b493fa58299085ea49015dfa1e4296_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_715a641a572181e14e9adaab487920f4 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_715a641a572181e14e9adaab487920f4)) {
        Py_XDECREF(cache_frame_715a641a572181e14e9adaab487920f4);

#if _DEBUG_REFCOUNTS
        if (cache_frame_715a641a572181e14e9adaab487920f4 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_715a641a572181e14e9adaab487920f4 = MAKE_FUNCTION_FRAME(codeobj_715a641a572181e14e9adaab487920f4, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_715a641a572181e14e9adaab487920f4->m_type_description == NULL);
    frame_715a641a572181e14e9adaab487920f4 = cache_frame_715a641a572181e14e9adaab487920f4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_715a641a572181e14e9adaab487920f4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_715a641a572181e14e9adaab487920f4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_albums);
            tmp_iter_arg_1 = par_albums;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 363;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_12b493fa58299085ea49015dfa1e4296_2)) {
            Py_XDECREF(cache_frame_12b493fa58299085ea49015dfa1e4296_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_12b493fa58299085ea49015dfa1e4296_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_12b493fa58299085ea49015dfa1e4296_2 = MAKE_FUNCTION_FRAME(codeobj_12b493fa58299085ea49015dfa1e4296, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_12b493fa58299085ea49015dfa1e4296_2->m_type_description == NULL);
        frame_12b493fa58299085ea49015dfa1e4296_2 = cache_frame_12b493fa58299085ea49015dfa1e4296_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_12b493fa58299085ea49015dfa1e4296_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_12b493fa58299085ea49015dfa1e4296_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 363;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_a;
                outline_0_var_a = tmp_assign_source_5;
                Py_INCREF(outline_0_var_a);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_album;
            CHECK_OBJECT(outline_0_var_a);
            tmp_args_element_name_2 = outline_0_var_a;
            frame_12b493fa58299085ea49015dfa1e4296_2->m_frame.f_lineno = 363;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 363;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 363;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 363;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_12b493fa58299085ea49015dfa1e4296_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_12b493fa58299085ea49015dfa1e4296_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_12b493fa58299085ea49015dfa1e4296_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_12b493fa58299085ea49015dfa1e4296_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_12b493fa58299085ea49015dfa1e4296_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_12b493fa58299085ea49015dfa1e4296_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_12b493fa58299085ea49015dfa1e4296_2,
            type_description_2,
            outline_0_var_a,
            par_self
        );


        // Release cached frame.
        if (frame_12b493fa58299085ea49015dfa1e4296_2 == cache_frame_12b493fa58299085ea49015dfa1e4296_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_12b493fa58299085ea49015dfa1e4296_2);
        }
        cache_frame_12b493fa58299085ea49015dfa1e4296_2 = NULL;

        assertFrameObject(frame_12b493fa58299085ea49015dfa1e4296_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 363;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 364;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_3a6be6041bbd3413cb3fb03eb5d525c3;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_4 = var_tlist;
        frame_715a641a572181e14e9adaab487920f4->m_frame.f_lineno = 364;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 364;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 364;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_715a641a572181e14e9adaab487920f4->m_frame.f_lineno = 364;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 364;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_715a641a572181e14e9adaab487920f4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_715a641a572181e14e9adaab487920f4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_715a641a572181e14e9adaab487920f4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_715a641a572181e14e9adaab487920f4, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_715a641a572181e14e9adaab487920f4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_715a641a572181e14e9adaab487920f4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_715a641a572181e14e9adaab487920f4,
        type_description_1,
        par_self,
        par_albums,
        var_tlist
    );


    // Release cached frame.
    if (frame_715a641a572181e14e9adaab487920f4 == cache_frame_715a641a572181e14e9adaab487920f4) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_715a641a572181e14e9adaab487920f4);
    }
    cache_frame_715a641a572181e14e9adaab487920f4 = NULL;

    assertFrameObject(frame_715a641a572181e14e9adaab487920f4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_25_show(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_show_id = python_pars[1];
    PyObject *par_market = python_pars[2];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_f9b069c262ea13b460c89d859872c039;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f9b069c262ea13b460c89d859872c039 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_f9b069c262ea13b460c89d859872c039)) {
        Py_XDECREF(cache_frame_f9b069c262ea13b460c89d859872c039);

#if _DEBUG_REFCOUNTS
        if (cache_frame_f9b069c262ea13b460c89d859872c039 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_f9b069c262ea13b460c89d859872c039 = MAKE_FUNCTION_FRAME(codeobj_f9b069c262ea13b460c89d859872c039, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_f9b069c262ea13b460c89d859872c039->m_type_description == NULL);
    frame_f9b069c262ea13b460c89d859872c039 = cache_frame_f9b069c262ea13b460c89d859872c039;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f9b069c262ea13b460c89d859872c039);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f9b069c262ea13b460c89d859872c039) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_show;
        CHECK_OBJECT(par_show_id);
        tmp_args_element_name_2 = par_show_id;
        frame_f9b069c262ea13b460c89d859872c039->m_frame.f_lineno = 378;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 378;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 379;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_7a2c470ea5f10c23533f984d841d174e;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 379;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_f9b069c262ea13b460c89d859872c039->m_frame.f_lineno = 379;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 379;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f9b069c262ea13b460c89d859872c039);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f9b069c262ea13b460c89d859872c039);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f9b069c262ea13b460c89d859872c039);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f9b069c262ea13b460c89d859872c039, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_f9b069c262ea13b460c89d859872c039->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f9b069c262ea13b460c89d859872c039, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_f9b069c262ea13b460c89d859872c039,
        type_description_1,
        par_self,
        par_show_id,
        par_market,
        var_trid
    );


    // Release cached frame.
    if (frame_f9b069c262ea13b460c89d859872c039 == cache_frame_f9b069c262ea13b460c89d859872c039) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_f9b069c262ea13b460c89d859872c039);
    }
    cache_frame_f9b069c262ea13b460c89d859872c039 = NULL;

    assertFrameObject(frame_f9b069c262ea13b460c89d859872c039);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_show_id);
    Py_DECREF(par_show_id);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_show_id);
    Py_DECREF(par_show_id);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_26_shows(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_shows = python_pars[1];
    PyObject *par_market = python_pars[2];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_s = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_6bdc0596686dfc0b462deed4239e76c7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_2f0e82d85089746fa7bf708e34483a0f_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_2f0e82d85089746fa7bf708e34483a0f_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_6bdc0596686dfc0b462deed4239e76c7 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_6bdc0596686dfc0b462deed4239e76c7)) {
        Py_XDECREF(cache_frame_6bdc0596686dfc0b462deed4239e76c7);

#if _DEBUG_REFCOUNTS
        if (cache_frame_6bdc0596686dfc0b462deed4239e76c7 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_6bdc0596686dfc0b462deed4239e76c7 = MAKE_FUNCTION_FRAME(codeobj_6bdc0596686dfc0b462deed4239e76c7, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_6bdc0596686dfc0b462deed4239e76c7->m_type_description == NULL);
    frame_6bdc0596686dfc0b462deed4239e76c7 = cache_frame_6bdc0596686dfc0b462deed4239e76c7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6bdc0596686dfc0b462deed4239e76c7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6bdc0596686dfc0b462deed4239e76c7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_shows);
            tmp_iter_arg_1 = par_shows;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 393;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_2f0e82d85089746fa7bf708e34483a0f_2)) {
            Py_XDECREF(cache_frame_2f0e82d85089746fa7bf708e34483a0f_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_2f0e82d85089746fa7bf708e34483a0f_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_2f0e82d85089746fa7bf708e34483a0f_2 = MAKE_FUNCTION_FRAME(codeobj_2f0e82d85089746fa7bf708e34483a0f, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_2f0e82d85089746fa7bf708e34483a0f_2->m_type_description == NULL);
        frame_2f0e82d85089746fa7bf708e34483a0f_2 = cache_frame_2f0e82d85089746fa7bf708e34483a0f_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_2f0e82d85089746fa7bf708e34483a0f_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_2f0e82d85089746fa7bf708e34483a0f_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 393;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_s;
                outline_0_var_s = tmp_assign_source_5;
                Py_INCREF(outline_0_var_s);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_show;
            CHECK_OBJECT(outline_0_var_s);
            tmp_args_element_name_2 = outline_0_var_s;
            frame_2f0e82d85089746fa7bf708e34483a0f_2->m_frame.f_lineno = 393;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 393;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 393;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 393;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2f0e82d85089746fa7bf708e34483a0f_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_2f0e82d85089746fa7bf708e34483a0f_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2f0e82d85089746fa7bf708e34483a0f_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_2f0e82d85089746fa7bf708e34483a0f_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_2f0e82d85089746fa7bf708e34483a0f_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_2f0e82d85089746fa7bf708e34483a0f_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_2f0e82d85089746fa7bf708e34483a0f_2,
            type_description_2,
            outline_0_var_s,
            par_self
        );


        // Release cached frame.
        if (frame_2f0e82d85089746fa7bf708e34483a0f_2 == cache_frame_2f0e82d85089746fa7bf708e34483a0f_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_2f0e82d85089746fa7bf708e34483a0f_2);
        }
        cache_frame_2f0e82d85089746fa7bf708e34483a0f_2 = NULL;

        assertFrameObject(frame_2f0e82d85089746fa7bf708e34483a0f_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "oooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 393;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 394;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_c2cb8cbc6b1b5e281950e97a3fe1622b;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_3 = var_tlist;
        frame_6bdc0596686dfc0b462deed4239e76c7->m_frame.f_lineno = 394;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 394;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 394;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_6bdc0596686dfc0b462deed4239e76c7->m_frame.f_lineno = 394;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 394;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6bdc0596686dfc0b462deed4239e76c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6bdc0596686dfc0b462deed4239e76c7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6bdc0596686dfc0b462deed4239e76c7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6bdc0596686dfc0b462deed4239e76c7, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_6bdc0596686dfc0b462deed4239e76c7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6bdc0596686dfc0b462deed4239e76c7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_6bdc0596686dfc0b462deed4239e76c7,
        type_description_1,
        par_self,
        par_shows,
        par_market,
        var_tlist
    );


    // Release cached frame.
    if (frame_6bdc0596686dfc0b462deed4239e76c7 == cache_frame_6bdc0596686dfc0b462deed4239e76c7) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_6bdc0596686dfc0b462deed4239e76c7);
    }
    cache_frame_6bdc0596686dfc0b462deed4239e76c7 = NULL;

    assertFrameObject(frame_6bdc0596686dfc0b462deed4239e76c7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_27_show_episodes(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_show_id = python_pars[1];
    PyObject *par_limit = python_pars[2];
    PyObject *par_offset = python_pars[3];
    PyObject *par_market = python_pars[4];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_a6d47ed3f0819257d542d41da7816cf0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_a6d47ed3f0819257d542d41da7816cf0 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_a6d47ed3f0819257d542d41da7816cf0)) {
        Py_XDECREF(cache_frame_a6d47ed3f0819257d542d41da7816cf0);

#if _DEBUG_REFCOUNTS
        if (cache_frame_a6d47ed3f0819257d542d41da7816cf0 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_a6d47ed3f0819257d542d41da7816cf0 = MAKE_FUNCTION_FRAME(codeobj_a6d47ed3f0819257d542d41da7816cf0, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_a6d47ed3f0819257d542d41da7816cf0->m_type_description == NULL);
    frame_a6d47ed3f0819257d542d41da7816cf0 = cache_frame_a6d47ed3f0819257d542d41da7816cf0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a6d47ed3f0819257d542d41da7816cf0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a6d47ed3f0819257d542d41da7816cf0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_show;
        CHECK_OBJECT(par_show_id);
        tmp_args_element_name_2 = par_show_id;
        frame_a6d47ed3f0819257d542d41da7816cf0->m_frame.f_lineno = 410;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 410;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_7a2c470ea5f10c23533f984d841d174e;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_1);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 412;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_digest_da6c98784a359364f8b00206a371e05a;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_1, tmp_right_name_2);
        Py_DECREF(tmp_left_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 412;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_3 = par_market;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_a6d47ed3f0819257d542d41da7816cf0->m_frame.f_lineno = 411;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 411;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6d47ed3f0819257d542d41da7816cf0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6d47ed3f0819257d542d41da7816cf0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a6d47ed3f0819257d542d41da7816cf0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a6d47ed3f0819257d542d41da7816cf0, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_a6d47ed3f0819257d542d41da7816cf0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a6d47ed3f0819257d542d41da7816cf0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_a6d47ed3f0819257d542d41da7816cf0,
        type_description_1,
        par_self,
        par_show_id,
        par_limit,
        par_offset,
        par_market,
        var_trid
    );


    // Release cached frame.
    if (frame_a6d47ed3f0819257d542d41da7816cf0 == cache_frame_a6d47ed3f0819257d542d41da7816cf0) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_a6d47ed3f0819257d542d41da7816cf0);
    }
    cache_frame_a6d47ed3f0819257d542d41da7816cf0 = NULL;

    assertFrameObject(frame_a6d47ed3f0819257d542d41da7816cf0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_show_id);
    Py_DECREF(par_show_id);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_show_id);
    Py_DECREF(par_show_id);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_28_episode(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_episode_id = python_pars[1];
    PyObject *par_market = python_pars[2];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_2f6e2042220007e67e1f735a62a30ac8;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2f6e2042220007e67e1f735a62a30ac8 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_2f6e2042220007e67e1f735a62a30ac8)) {
        Py_XDECREF(cache_frame_2f6e2042220007e67e1f735a62a30ac8);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2f6e2042220007e67e1f735a62a30ac8 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2f6e2042220007e67e1f735a62a30ac8 = MAKE_FUNCTION_FRAME(codeobj_2f6e2042220007e67e1f735a62a30ac8, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2f6e2042220007e67e1f735a62a30ac8->m_type_description == NULL);
    frame_2f6e2042220007e67e1f735a62a30ac8 = cache_frame_2f6e2042220007e67e1f735a62a30ac8;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2f6e2042220007e67e1f735a62a30ac8);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2f6e2042220007e67e1f735a62a30ac8) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_episode;
        CHECK_OBJECT(par_episode_id);
        tmp_args_element_name_2 = par_episode_id;
        frame_2f6e2042220007e67e1f735a62a30ac8->m_frame.f_lineno = 427;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 427;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_bc8036c231ae7fe76f8be4f140448aca;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_2f6e2042220007e67e1f735a62a30ac8->m_frame.f_lineno = 428;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 428;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f6e2042220007e67e1f735a62a30ac8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f6e2042220007e67e1f735a62a30ac8);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2f6e2042220007e67e1f735a62a30ac8);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2f6e2042220007e67e1f735a62a30ac8, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2f6e2042220007e67e1f735a62a30ac8->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2f6e2042220007e67e1f735a62a30ac8, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2f6e2042220007e67e1f735a62a30ac8,
        type_description_1,
        par_self,
        par_episode_id,
        par_market,
        var_trid
    );


    // Release cached frame.
    if (frame_2f6e2042220007e67e1f735a62a30ac8 == cache_frame_2f6e2042220007e67e1f735a62a30ac8) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2f6e2042220007e67e1f735a62a30ac8);
    }
    cache_frame_2f6e2042220007e67e1f735a62a30ac8 = NULL;

    assertFrameObject(frame_2f6e2042220007e67e1f735a62a30ac8);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_episode_id);
    Py_DECREF(par_episode_id);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_episode_id);
    Py_DECREF(par_episode_id);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_29_episodes(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_episodes = python_pars[1];
    PyObject *par_market = python_pars[2];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_e = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_09f8314dcf36acecb4822e17d6367093;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_0c896c01aacc838fc67aa18df394c175_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_0c896c01aacc838fc67aa18df394c175_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_09f8314dcf36acecb4822e17d6367093 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_09f8314dcf36acecb4822e17d6367093)) {
        Py_XDECREF(cache_frame_09f8314dcf36acecb4822e17d6367093);

#if _DEBUG_REFCOUNTS
        if (cache_frame_09f8314dcf36acecb4822e17d6367093 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_09f8314dcf36acecb4822e17d6367093 = MAKE_FUNCTION_FRAME(codeobj_09f8314dcf36acecb4822e17d6367093, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_09f8314dcf36acecb4822e17d6367093->m_type_description == NULL);
    frame_09f8314dcf36acecb4822e17d6367093 = cache_frame_09f8314dcf36acecb4822e17d6367093;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_09f8314dcf36acecb4822e17d6367093);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_09f8314dcf36acecb4822e17d6367093) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_episodes);
            tmp_iter_arg_1 = par_episodes;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 442;
                type_description_1 = "oooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_0c896c01aacc838fc67aa18df394c175_2)) {
            Py_XDECREF(cache_frame_0c896c01aacc838fc67aa18df394c175_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_0c896c01aacc838fc67aa18df394c175_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_0c896c01aacc838fc67aa18df394c175_2 = MAKE_FUNCTION_FRAME(codeobj_0c896c01aacc838fc67aa18df394c175, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_0c896c01aacc838fc67aa18df394c175_2->m_type_description == NULL);
        frame_0c896c01aacc838fc67aa18df394c175_2 = cache_frame_0c896c01aacc838fc67aa18df394c175_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_0c896c01aacc838fc67aa18df394c175_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_0c896c01aacc838fc67aa18df394c175_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 442;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_e;
                outline_0_var_e = tmp_assign_source_5;
                Py_INCREF(outline_0_var_e);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_episode;
            CHECK_OBJECT(outline_0_var_e);
            tmp_args_element_name_2 = outline_0_var_e;
            frame_0c896c01aacc838fc67aa18df394c175_2->m_frame.f_lineno = 442;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 442;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 442;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 442;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_0c896c01aacc838fc67aa18df394c175_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_0c896c01aacc838fc67aa18df394c175_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_0c896c01aacc838fc67aa18df394c175_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_0c896c01aacc838fc67aa18df394c175_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_0c896c01aacc838fc67aa18df394c175_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_0c896c01aacc838fc67aa18df394c175_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_0c896c01aacc838fc67aa18df394c175_2,
            type_description_2,
            outline_0_var_e,
            par_self
        );


        // Release cached frame.
        if (frame_0c896c01aacc838fc67aa18df394c175_2 == cache_frame_0c896c01aacc838fc67aa18df394c175_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_0c896c01aacc838fc67aa18df394c175_2);
        }
        cache_frame_0c896c01aacc838fc67aa18df394c175_2 = NULL;

        assertFrameObject(frame_0c896c01aacc838fc67aa18df394c175_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "oooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_e);
        outline_0_var_e = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_e);
        outline_0_var_e = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 442;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 443;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_223709650aeac13928929205a42f7ef5;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_3 = var_tlist;
        frame_09f8314dcf36acecb4822e17d6367093->m_frame.f_lineno = 443;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 443;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 443;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_09f8314dcf36acecb4822e17d6367093->m_frame.f_lineno = 443;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 443;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_09f8314dcf36acecb4822e17d6367093);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_09f8314dcf36acecb4822e17d6367093);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_09f8314dcf36acecb4822e17d6367093);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_09f8314dcf36acecb4822e17d6367093, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_09f8314dcf36acecb4822e17d6367093->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_09f8314dcf36acecb4822e17d6367093, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_09f8314dcf36acecb4822e17d6367093,
        type_description_1,
        par_self,
        par_episodes,
        par_market,
        var_tlist
    );


    // Release cached frame.
    if (frame_09f8314dcf36acecb4822e17d6367093 == cache_frame_09f8314dcf36acecb4822e17d6367093) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_09f8314dcf36acecb4822e17d6367093);
    }
    cache_frame_09f8314dcf36acecb4822e17d6367093 = NULL;

    assertFrameObject(frame_09f8314dcf36acecb4822e17d6367093);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_episodes);
    Py_DECREF(par_episodes);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_episodes);
    Py_DECREF(par_episodes);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_30_search(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_q = python_pars[1];
    PyObject *par_limit = python_pars[2];
    PyObject *par_offset = python_pars[3];
    PyObject *par_type = python_pars[4];
    PyObject *par_market = python_pars[5];
    struct Nuitka_FrameObject *frame_b8b8b2a680fcba242b884f880392c9d6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_b8b8b2a680fcba242b884f880392c9d6 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_b8b8b2a680fcba242b884f880392c9d6)) {
        Py_XDECREF(cache_frame_b8b8b2a680fcba242b884f880392c9d6);

#if _DEBUG_REFCOUNTS
        if (cache_frame_b8b8b2a680fcba242b884f880392c9d6 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_b8b8b2a680fcba242b884f880392c9d6 = MAKE_FUNCTION_FRAME(codeobj_b8b8b2a680fcba242b884f880392c9d6, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_b8b8b2a680fcba242b884f880392c9d6->m_type_description == NULL);
    frame_b8b8b2a680fcba242b884f880392c9d6 = cache_frame_b8b8b2a680fcba242b884f880392c9d6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b8b8b2a680fcba242b884f880392c9d6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b8b8b2a680fcba242b884f880392c9d6) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 458;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_plain_search_tuple;
        tmp_dict_key_1 = const_str_plain_q;
        CHECK_OBJECT(par_q);
        tmp_dict_value_1 = par_q;
        tmp_kw_name_1 = _PyDict_NewPresized( 5 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_2 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_3 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_type;
        CHECK_OBJECT(par_type);
        tmp_dict_value_4 = par_type;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        tmp_dict_key_5 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_5 = par_market;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5);
        assert(!(tmp_res != 0));
        frame_b8b8b2a680fcba242b884f880392c9d6->m_frame.f_lineno = 458;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 458;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b8b8b2a680fcba242b884f880392c9d6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b8b8b2a680fcba242b884f880392c9d6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b8b8b2a680fcba242b884f880392c9d6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b8b8b2a680fcba242b884f880392c9d6, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_b8b8b2a680fcba242b884f880392c9d6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b8b8b2a680fcba242b884f880392c9d6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_b8b8b2a680fcba242b884f880392c9d6,
        type_description_1,
        par_self,
        par_q,
        par_limit,
        par_offset,
        par_type,
        par_market
    );


    // Release cached frame.
    if (frame_b8b8b2a680fcba242b884f880392c9d6 == cache_frame_b8b8b2a680fcba242b884f880392c9d6) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_b8b8b2a680fcba242b884f880392c9d6);
    }
    cache_frame_b8b8b2a680fcba242b884f880392c9d6 = NULL;

    assertFrameObject(frame_b8b8b2a680fcba242b884f880392c9d6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_q);
    Py_DECREF(par_q);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_q);
    Py_DECREF(par_q);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_31_user(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    struct Nuitka_FrameObject *frame_1992bb674c115730c3d7ca787dcfc79c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1992bb674c115730c3d7ca787dcfc79c = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_1992bb674c115730c3d7ca787dcfc79c)) {
        Py_XDECREF(cache_frame_1992bb674c115730c3d7ca787dcfc79c);

#if _DEBUG_REFCOUNTS
        if (cache_frame_1992bb674c115730c3d7ca787dcfc79c == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_1992bb674c115730c3d7ca787dcfc79c = MAKE_FUNCTION_FRAME(codeobj_1992bb674c115730c3d7ca787dcfc79c, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_1992bb674c115730c3d7ca787dcfc79c->m_type_description == NULL);
    frame_1992bb674c115730c3d7ca787dcfc79c = cache_frame_1992bb674c115730c3d7ca787dcfc79c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1992bb674c115730c3d7ca787dcfc79c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1992bb674c115730c3d7ca787dcfc79c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_ca1b89362262296b98ca23da8d1a4747;
        CHECK_OBJECT(par_user);
        tmp_right_name_1 = par_user;
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_1992bb674c115730c3d7ca787dcfc79c->m_frame.f_lineno = 468;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 468;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1992bb674c115730c3d7ca787dcfc79c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1992bb674c115730c3d7ca787dcfc79c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1992bb674c115730c3d7ca787dcfc79c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1992bb674c115730c3d7ca787dcfc79c, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_1992bb674c115730c3d7ca787dcfc79c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1992bb674c115730c3d7ca787dcfc79c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_1992bb674c115730c3d7ca787dcfc79c,
        type_description_1,
        par_self,
        par_user
    );


    // Release cached frame.
    if (frame_1992bb674c115730c3d7ca787dcfc79c == cache_frame_1992bb674c115730c3d7ca787dcfc79c) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_1992bb674c115730c3d7ca787dcfc79c);
    }
    cache_frame_1992bb674c115730c3d7ca787dcfc79c = NULL;

    assertFrameObject(frame_1992bb674c115730c3d7ca787dcfc79c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_32_current_user_playlists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_offset = python_pars[2];
    struct Nuitka_FrameObject *frame_ab1272eb3da49e1319b67cd0d702382e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_ab1272eb3da49e1319b67cd0d702382e = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_ab1272eb3da49e1319b67cd0d702382e)) {
        Py_XDECREF(cache_frame_ab1272eb3da49e1319b67cd0d702382e);

#if _DEBUG_REFCOUNTS
        if (cache_frame_ab1272eb3da49e1319b67cd0d702382e == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_ab1272eb3da49e1319b67cd0d702382e = MAKE_FUNCTION_FRAME(codeobj_ab1272eb3da49e1319b67cd0d702382e, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_ab1272eb3da49e1319b67cd0d702382e->m_type_description == NULL);
    frame_ab1272eb3da49e1319b67cd0d702382e = cache_frame_ab1272eb3da49e1319b67cd0d702382e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ab1272eb3da49e1319b67cd0d702382e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ab1272eb3da49e1319b67cd0d702382e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 476;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_c8dd3e40bf7394768822193fde87cb0c_tuple;
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_ab1272eb3da49e1319b67cd0d702382e->m_frame.f_lineno = 476;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 476;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab1272eb3da49e1319b67cd0d702382e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab1272eb3da49e1319b67cd0d702382e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ab1272eb3da49e1319b67cd0d702382e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ab1272eb3da49e1319b67cd0d702382e, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_ab1272eb3da49e1319b67cd0d702382e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ab1272eb3da49e1319b67cd0d702382e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_ab1272eb3da49e1319b67cd0d702382e,
        type_description_1,
        par_self,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_ab1272eb3da49e1319b67cd0d702382e == cache_frame_ab1272eb3da49e1319b67cd0d702382e) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_ab1272eb3da49e1319b67cd0d702382e);
    }
    cache_frame_ab1272eb3da49e1319b67cd0d702382e = NULL;

    assertFrameObject(frame_ab1272eb3da49e1319b67cd0d702382e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_33_playlist(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_playlist_id = python_pars[1];
    PyObject *par_fields = python_pars[2];
    PyObject *par_market = python_pars[3];
    PyObject *par_additional_types = python_pars[4];
    PyObject *var_plid = NULL;
    struct Nuitka_FrameObject *frame_bb873134d02b7ab21991d824dee68309;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_bb873134d02b7ab21991d824dee68309 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_bb873134d02b7ab21991d824dee68309)) {
        Py_XDECREF(cache_frame_bb873134d02b7ab21991d824dee68309);

#if _DEBUG_REFCOUNTS
        if (cache_frame_bb873134d02b7ab21991d824dee68309 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_bb873134d02b7ab21991d824dee68309 = MAKE_FUNCTION_FRAME(codeobj_bb873134d02b7ab21991d824dee68309, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_bb873134d02b7ab21991d824dee68309->m_type_description == NULL);
    frame_bb873134d02b7ab21991d824dee68309 = cache_frame_bb873134d02b7ab21991d824dee68309;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_bb873134d02b7ab21991d824dee68309);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_bb873134d02b7ab21991d824dee68309) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_bb873134d02b7ab21991d824dee68309->m_frame.f_lineno = 489;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 489;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 490;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_fe0740ea6f5308d7e1b3f22eff165a3c;
        CHECK_OBJECT(var_plid);
        tmp_right_name_1 = var_plid;
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 491;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_fields;
        CHECK_OBJECT(par_fields);
        tmp_dict_value_1 = par_fields;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_2 = par_market;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_additional_types;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(par_additional_types);
        tmp_args_element_name_3 = par_additional_types;
        frame_bb873134d02b7ab21991d824dee68309->m_frame.f_lineno = 494;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_dict_value_3 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_dict_value_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_name_1);
            Py_DECREF(tmp_kw_name_1);

            exception_lineno = 494;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        Py_DECREF(tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_bb873134d02b7ab21991d824dee68309->m_frame.f_lineno = 490;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 490;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bb873134d02b7ab21991d824dee68309);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_bb873134d02b7ab21991d824dee68309);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_bb873134d02b7ab21991d824dee68309);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_bb873134d02b7ab21991d824dee68309, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_bb873134d02b7ab21991d824dee68309->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_bb873134d02b7ab21991d824dee68309, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_bb873134d02b7ab21991d824dee68309,
        type_description_1,
        par_self,
        par_playlist_id,
        par_fields,
        par_market,
        par_additional_types,
        var_plid
    );


    // Release cached frame.
    if (frame_bb873134d02b7ab21991d824dee68309 == cache_frame_bb873134d02b7ab21991d824dee68309) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_bb873134d02b7ab21991d824dee68309);
    }
    cache_frame_bb873134d02b7ab21991d824dee68309 = NULL;

    assertFrameObject(frame_bb873134d02b7ab21991d824dee68309);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);
    CHECK_OBJECT(par_additional_types);
    Py_DECREF(par_additional_types);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);
    CHECK_OBJECT(par_additional_types);
    Py_DECREF(par_additional_types);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_34_playlist_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_playlist_id = python_pars[1];
    PyObject *par_fields = python_pars[2];
    PyObject *par_limit = python_pars[3];
    PyObject *par_offset = python_pars[4];
    PyObject *par_market = python_pars[5];
    PyObject *par_additional_types = python_pars[6];
    PyObject *var_plid = NULL;
    struct Nuitka_FrameObject *frame_8ee16325e7b90b2b674e1b2dda8fbb1d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d)) {
        Py_XDECREF(cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d);

#if _DEBUG_REFCOUNTS
        if (cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d = MAKE_FUNCTION_FRAME(codeobj_8ee16325e7b90b2b674e1b2dda8fbb1d, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d->m_type_description == NULL);
    frame_8ee16325e7b90b2b674e1b2dda8fbb1d = cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8ee16325e7b90b2b674e1b2dda8fbb1d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8ee16325e7b90b2b674e1b2dda8fbb1d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_8ee16325e7b90b2b674e1b2dda8fbb1d->m_frame.f_lineno = 517;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 517;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 518;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_a2dd6239923e72eabb819f2d368b274b;
        CHECK_OBJECT(var_plid);
        tmp_right_name_1 = var_plid;
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 519;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 5 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_fields;
        CHECK_OBJECT(par_fields);
        tmp_dict_value_3 = par_fields;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_4 = par_market;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        tmp_dict_key_5 = const_str_plain_additional_types;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(par_additional_types);
        tmp_args_element_name_3 = par_additional_types;
        frame_8ee16325e7b90b2b674e1b2dda8fbb1d->m_frame.f_lineno = 524;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_dict_value_5 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_dict_value_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_name_1);
            Py_DECREF(tmp_kw_name_1);

            exception_lineno = 524;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5);
        Py_DECREF(tmp_dict_value_5);
        assert(!(tmp_res != 0));
        frame_8ee16325e7b90b2b674e1b2dda8fbb1d->m_frame.f_lineno = 518;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 518;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8ee16325e7b90b2b674e1b2dda8fbb1d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8ee16325e7b90b2b674e1b2dda8fbb1d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8ee16325e7b90b2b674e1b2dda8fbb1d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8ee16325e7b90b2b674e1b2dda8fbb1d, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_8ee16325e7b90b2b674e1b2dda8fbb1d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8ee16325e7b90b2b674e1b2dda8fbb1d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_8ee16325e7b90b2b674e1b2dda8fbb1d,
        type_description_1,
        par_self,
        par_playlist_id,
        par_fields,
        par_limit,
        par_offset,
        par_market,
        par_additional_types,
        var_plid
    );


    // Release cached frame.
    if (frame_8ee16325e7b90b2b674e1b2dda8fbb1d == cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_8ee16325e7b90b2b674e1b2dda8fbb1d);
    }
    cache_frame_8ee16325e7b90b2b674e1b2dda8fbb1d = NULL;

    assertFrameObject(frame_8ee16325e7b90b2b674e1b2dda8fbb1d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);
    CHECK_OBJECT(par_additional_types);
    Py_DECREF(par_additional_types);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);
    CHECK_OBJECT(par_additional_types);
    Py_DECREF(par_additional_types);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_35_playlist_cover_image(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_playlist_id = python_pars[1];
    PyObject *var_plid = NULL;
    struct Nuitka_FrameObject *frame_81ae924ff3013530f1205e18ea0fb9cd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_81ae924ff3013530f1205e18ea0fb9cd = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_81ae924ff3013530f1205e18ea0fb9cd)) {
        Py_XDECREF(cache_frame_81ae924ff3013530f1205e18ea0fb9cd);

#if _DEBUG_REFCOUNTS
        if (cache_frame_81ae924ff3013530f1205e18ea0fb9cd == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_81ae924ff3013530f1205e18ea0fb9cd = MAKE_FUNCTION_FRAME(codeobj_81ae924ff3013530f1205e18ea0fb9cd, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_81ae924ff3013530f1205e18ea0fb9cd->m_type_description == NULL);
    frame_81ae924ff3013530f1205e18ea0fb9cd = cache_frame_81ae924ff3013530f1205e18ea0fb9cd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_81ae924ff3013530f1205e18ea0fb9cd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_81ae924ff3013530f1205e18ea0fb9cd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_81ae924ff3013530f1205e18ea0fb9cd->m_frame.f_lineno = 533;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 533;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 534;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_9edb48669a614c3726ceb81da3fc4901;
        CHECK_OBJECT(var_plid);
        tmp_right_name_1 = var_plid;
        tmp_args_element_name_3 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 534;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_81ae924ff3013530f1205e18ea0fb9cd->m_frame.f_lineno = 534;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 534;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_81ae924ff3013530f1205e18ea0fb9cd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_81ae924ff3013530f1205e18ea0fb9cd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_81ae924ff3013530f1205e18ea0fb9cd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_81ae924ff3013530f1205e18ea0fb9cd, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_81ae924ff3013530f1205e18ea0fb9cd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_81ae924ff3013530f1205e18ea0fb9cd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_81ae924ff3013530f1205e18ea0fb9cd,
        type_description_1,
        par_self,
        par_playlist_id,
        var_plid
    );


    // Release cached frame.
    if (frame_81ae924ff3013530f1205e18ea0fb9cd == cache_frame_81ae924ff3013530f1205e18ea0fb9cd) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_81ae924ff3013530f1205e18ea0fb9cd);
    }
    cache_frame_81ae924ff3013530f1205e18ea0fb9cd = NULL;

    assertFrameObject(frame_81ae924ff3013530f1205e18ea0fb9cd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_36_playlist_upload_cover_image(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_playlist_id = python_pars[1];
    PyObject *par_image_b64 = python_pars[2];
    PyObject *var_plid = NULL;
    struct Nuitka_FrameObject *frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9)) {
        Py_XDECREF(cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);

#if _DEBUG_REFCOUNTS
        if (cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 = MAKE_FUNCTION_FRAME(codeobj_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9->m_type_description == NULL);
    frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 = cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9->m_frame.f_lineno = 544;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 544;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 545;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_2 = const_str_digest_5fa7996b99deb750a6e6de8b5f21cbf4;
        CHECK_OBJECT(var_plid);
        tmp_args_element_name_3 = var_plid;
        frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9->m_frame.f_lineno = 546;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_tuple_element_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_format, call_args);
        }

        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 546;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_payload;
        CHECK_OBJECT(par_image_b64);
        tmp_dict_value_1 = par_image_b64;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_content_type;
        tmp_dict_value_2 = const_str_digest_e58eec2a5ea585c2c4db40f39721d451;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9->m_frame.f_lineno = 545;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 545;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9,
        type_description_1,
        par_self,
        par_playlist_id,
        par_image_b64,
        var_plid
    );


    // Release cached frame.
    if (frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 == cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);
    }
    cache_frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9 = NULL;

    assertFrameObject(frame_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_image_b64);
    Py_DECREF(par_image_b64);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_image_b64);
    Py_DECREF(par_image_b64);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_37_user_playlist(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_fields = python_pars[3];
    PyObject *par_market = python_pars[4];
    struct Nuitka_FrameObject *frame_11ebf3160087fe2851050075a57a707d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_11ebf3160087fe2851050075a57a707d = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_11ebf3160087fe2851050075a57a707d)) {
        Py_XDECREF(cache_frame_11ebf3160087fe2851050075a57a707d);

#if _DEBUG_REFCOUNTS
        if (cache_frame_11ebf3160087fe2851050075a57a707d == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_11ebf3160087fe2851050075a57a707d = MAKE_FUNCTION_FRAME(codeobj_11ebf3160087fe2851050075a57a707d, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_11ebf3160087fe2851050075a57a707d->m_type_description == NULL);
    frame_11ebf3160087fe2851050075a57a707d = cache_frame_11ebf3160087fe2851050075a57a707d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_11ebf3160087fe2851050075a57a707d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_11ebf3160087fe2851050075a57a707d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_warnings);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 8128 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 552;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_warn);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 552;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_digest_a4092bb382602ef0ef001894fe04bc08;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 10219 ], 40, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 554;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_2;
        frame_11ebf3160087fe2851050075a57a707d->m_frame.f_lineno = 552;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 552;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_playlist_id);
        tmp_compexpr_left_1 = par_playlist_id;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 == tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__get);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 565;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_bd964b21b4b89004df13ec1af48482be;
        CHECK_OBJECT(par_user);
        tmp_right_name_1 = par_user;
        tmp_args_element_name_3 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 565;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_11ebf3160087fe2851050075a57a707d->m_frame.f_lineno = 565;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 565;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }
    branch_no_1:;
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_3 = par_self;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain_playlist);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 566;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_playlist_id);
        tmp_tuple_element_1 = par_playlist_id;
        tmp_args_name_1 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_fields;
        CHECK_OBJECT(par_fields);
        tmp_dict_value_1 = par_fields;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_2 = par_market;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_11ebf3160087fe2851050075a57a707d->m_frame.f_lineno = 566;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 566;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_11ebf3160087fe2851050075a57a707d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_11ebf3160087fe2851050075a57a707d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_11ebf3160087fe2851050075a57a707d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_11ebf3160087fe2851050075a57a707d, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_11ebf3160087fe2851050075a57a707d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_11ebf3160087fe2851050075a57a707d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_11ebf3160087fe2851050075a57a707d,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_fields,
        par_market
    );


    // Release cached frame.
    if (frame_11ebf3160087fe2851050075a57a707d == cache_frame_11ebf3160087fe2851050075a57a707d) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_11ebf3160087fe2851050075a57a707d);
    }
    cache_frame_11ebf3160087fe2851050075a57a707d = NULL;

    assertFrameObject(frame_11ebf3160087fe2851050075a57a707d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_38_user_playlist_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_fields = python_pars[3];
    PyObject *par_limit = python_pars[4];
    PyObject *par_offset = python_pars[5];
    PyObject *par_market = python_pars[6];
    struct Nuitka_FrameObject *frame_2c79586a1ed1d017b86e3b8a016ef4f9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9)) {
        Py_XDECREF(cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9 = MAKE_FUNCTION_FRAME(codeobj_2c79586a1ed1d017b86e3b8a016ef4f9, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9->m_type_description == NULL);
    frame_2c79586a1ed1d017b86e3b8a016ef4f9 = cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2c79586a1ed1d017b86e3b8a016ef4f9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2c79586a1ed1d017b86e3b8a016ef4f9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_mvar_value_2;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_warnings);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_warnings);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 8128 ], 30, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 577;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_1 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_warn);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 577;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_digest_143a93a582706d71ac985cd217d846c8;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_DeprecationWarning);
        }

        if (tmp_mvar_value_2 == NULL) {
            Py_DECREF(tmp_called_name_1);
            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 10219 ], 40, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 579;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_args_element_name_2 = tmp_mvar_value_2;
        frame_2c79586a1ed1d017b86e3b8a016ef4f9->m_frame.f_lineno = 577;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 577;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_playlist_tracks);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 592;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_playlist_id);
        tmp_tuple_element_1 = par_playlist_id;
        tmp_args_name_1 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_fields;
        CHECK_OBJECT(par_fields);
        tmp_dict_value_3 = par_fields;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_4 = par_market;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        frame_2c79586a1ed1d017b86e3b8a016ef4f9->m_frame.f_lineno = 592;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_2, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 592;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2c79586a1ed1d017b86e3b8a016ef4f9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2c79586a1ed1d017b86e3b8a016ef4f9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2c79586a1ed1d017b86e3b8a016ef4f9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2c79586a1ed1d017b86e3b8a016ef4f9, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2c79586a1ed1d017b86e3b8a016ef4f9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2c79586a1ed1d017b86e3b8a016ef4f9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2c79586a1ed1d017b86e3b8a016ef4f9,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_fields,
        par_limit,
        par_offset,
        par_market
    );


    // Release cached frame.
    if (frame_2c79586a1ed1d017b86e3b8a016ef4f9 == cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2c79586a1ed1d017b86e3b8a016ef4f9);
    }
    cache_frame_2c79586a1ed1d017b86e3b8a016ef4f9 = NULL;

    assertFrameObject(frame_2c79586a1ed1d017b86e3b8a016ef4f9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_fields);
    Py_DECREF(par_fields);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_39_user_playlists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_limit = python_pars[2];
    PyObject *par_offset = python_pars[3];
    struct Nuitka_FrameObject *frame_48d6590f132aac7ab0ed4bc6f937525b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_48d6590f132aac7ab0ed4bc6f937525b = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_48d6590f132aac7ab0ed4bc6f937525b)) {
        Py_XDECREF(cache_frame_48d6590f132aac7ab0ed4bc6f937525b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_48d6590f132aac7ab0ed4bc6f937525b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_48d6590f132aac7ab0ed4bc6f937525b = MAKE_FUNCTION_FRAME(codeobj_48d6590f132aac7ab0ed4bc6f937525b, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_48d6590f132aac7ab0ed4bc6f937525b->m_type_description == NULL);
    frame_48d6590f132aac7ab0ed4bc6f937525b = cache_frame_48d6590f132aac7ab0ed4bc6f937525b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_48d6590f132aac7ab0ed4bc6f937525b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_48d6590f132aac7ab0ed4bc6f937525b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 608;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_eb7db257536c3fbd0210e240db4c263e;
        CHECK_OBJECT(par_user);
        tmp_right_name_1 = par_user;
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 609;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_48d6590f132aac7ab0ed4bc6f937525b->m_frame.f_lineno = 608;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 608;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_48d6590f132aac7ab0ed4bc6f937525b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_48d6590f132aac7ab0ed4bc6f937525b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_48d6590f132aac7ab0ed4bc6f937525b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_48d6590f132aac7ab0ed4bc6f937525b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_48d6590f132aac7ab0ed4bc6f937525b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_48d6590f132aac7ab0ed4bc6f937525b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_48d6590f132aac7ab0ed4bc6f937525b,
        type_description_1,
        par_self,
        par_user,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_48d6590f132aac7ab0ed4bc6f937525b == cache_frame_48d6590f132aac7ab0ed4bc6f937525b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_48d6590f132aac7ab0ed4bc6f937525b);
    }
    cache_frame_48d6590f132aac7ab0ed4bc6f937525b = NULL;

    assertFrameObject(frame_48d6590f132aac7ab0ed4bc6f937525b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_40_user_playlist_create(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_name = python_pars[2];
    PyObject *par_public = python_pars[3];
    PyObject *par_description = python_pars[4];
    PyObject *var_data = NULL;
    int tmp_res;
    struct Nuitka_FrameObject *frame_06fc7afb37bb590954770ef5cc01bd68;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_06fc7afb37bb590954770ef5cc01bd68 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        tmp_dict_key_1 = const_str_plain_name;
        CHECK_OBJECT(par_name);
        tmp_dict_value_1 = par_name;
        tmp_assign_source_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_public;
        CHECK_OBJECT(par_public);
        tmp_dict_value_2 = par_public;
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_description;
        CHECK_OBJECT(par_description);
        tmp_dict_value_3 = par_description;
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        assert(var_data == NULL);
        var_data = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_06fc7afb37bb590954770ef5cc01bd68)) {
        Py_XDECREF(cache_frame_06fc7afb37bb590954770ef5cc01bd68);

#if _DEBUG_REFCOUNTS
        if (cache_frame_06fc7afb37bb590954770ef5cc01bd68 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_06fc7afb37bb590954770ef5cc01bd68 = MAKE_FUNCTION_FRAME(codeobj_06fc7afb37bb590954770ef5cc01bd68, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_06fc7afb37bb590954770ef5cc01bd68->m_type_description == NULL);
    frame_06fc7afb37bb590954770ef5cc01bd68 = cache_frame_06fc7afb37bb590954770ef5cc01bd68;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_06fc7afb37bb590954770ef5cc01bd68);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_06fc7afb37bb590954770ef5cc01bd68) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__post);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 623;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_eb7db257536c3fbd0210e240db4c263e;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(1);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 623;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_4 = const_str_plain_payload;
        CHECK_OBJECT(var_data);
        tmp_dict_value_4 = var_data;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        frame_06fc7afb37bb590954770ef5cc01bd68->m_frame.f_lineno = 623;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 623;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_06fc7afb37bb590954770ef5cc01bd68);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_06fc7afb37bb590954770ef5cc01bd68);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_06fc7afb37bb590954770ef5cc01bd68);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_06fc7afb37bb590954770ef5cc01bd68, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_06fc7afb37bb590954770ef5cc01bd68->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_06fc7afb37bb590954770ef5cc01bd68, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_06fc7afb37bb590954770ef5cc01bd68,
        type_description_1,
        par_self,
        par_user,
        par_name,
        par_public,
        par_description,
        var_data
    );


    // Release cached frame.
    if (frame_06fc7afb37bb590954770ef5cc01bd68 == cache_frame_06fc7afb37bb590954770ef5cc01bd68) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_06fc7afb37bb590954770ef5cc01bd68);
    }
    cache_frame_06fc7afb37bb590954770ef5cc01bd68 = NULL;

    assertFrameObject(frame_06fc7afb37bb590954770ef5cc01bd68);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT(var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_public);
    Py_DECREF(par_public);
    CHECK_OBJECT(par_description);
    Py_DECREF(par_description);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_public);
    Py_DECREF(par_public);
    CHECK_OBJECT(par_description);
    Py_DECREF(par_description);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_41_user_playlist_change_details(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_name = python_pars[3];
    PyObject *par_public = python_pars[4];
    PyObject *par_collaborative = python_pars[5];
    PyObject *par_description = python_pars[6];
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_c9af8615d8b382ab25d387a4ae2144bc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c9af8615d8b382ab25d387a4ae2144bc = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyDict_New();
        assert(var_data == NULL);
        var_data = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_c9af8615d8b382ab25d387a4ae2144bc)) {
        Py_XDECREF(cache_frame_c9af8615d8b382ab25d387a4ae2144bc);

#if _DEBUG_REFCOUNTS
        if (cache_frame_c9af8615d8b382ab25d387a4ae2144bc == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_c9af8615d8b382ab25d387a4ae2144bc = MAKE_FUNCTION_FRAME(codeobj_c9af8615d8b382ab25d387a4ae2144bc, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_c9af8615d8b382ab25d387a4ae2144bc->m_type_description == NULL);
    frame_c9af8615d8b382ab25d387a4ae2144bc = cache_frame_c9af8615d8b382ab25d387a4ae2144bc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c9af8615d8b382ab25d387a4ae2144bc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c9af8615d8b382ab25d387a4ae2144bc) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_mvar_value_1;
        CHECK_OBJECT(par_name);
        tmp_isinstance_inst_1 = par_name;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16875 ], 25, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 646;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_1 = tmp_mvar_value_1;
        tmp_isinstance_cls_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_string_types);
        if (tmp_isinstance_cls_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 646;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        Py_DECREF(tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 646;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    CHECK_OBJECT(par_name);
    tmp_dictset_value = par_name;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_name;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_isinstance_inst_2;
        PyObject *tmp_isinstance_cls_2;
        CHECK_OBJECT(par_public);
        tmp_isinstance_inst_2 = par_public;
        tmp_isinstance_cls_2 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_2, tmp_isinstance_cls_2);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 648;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    CHECK_OBJECT(par_public);
    tmp_dictset_value = par_public;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_public;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_2:;
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_isinstance_inst_3;
        PyObject *tmp_isinstance_cls_3;
        CHECK_OBJECT(par_collaborative);
        tmp_isinstance_inst_3 = par_collaborative;
        tmp_isinstance_cls_3 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_3, tmp_isinstance_cls_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 650;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
    }
    branch_yes_3:;
    CHECK_OBJECT(par_collaborative);
    tmp_dictset_value = par_collaborative;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_collaborative;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_3:;
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_isinstance_inst_4;
        PyObject *tmp_isinstance_cls_4;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_mvar_value_2;
        CHECK_OBJECT(par_description);
        tmp_isinstance_inst_4 = par_description;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_six);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_six);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16875 ], 25, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 652;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_2 = tmp_mvar_value_2;
        tmp_isinstance_cls_4 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_string_types);
        if (tmp_isinstance_cls_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 652;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_4, tmp_isinstance_cls_4);
        Py_DECREF(tmp_isinstance_cls_4);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 652;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
    }
    branch_yes_4:;
    CHECK_OBJECT(par_description);
    tmp_dictset_value = par_description;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_description;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_4:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_3 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 654;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_c6869dc60b510805e792b2878f36c2bb;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(par_playlist_id);
        tmp_tuple_element_2 = par_playlist_id;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 655;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_payload;
        CHECK_OBJECT(var_data);
        tmp_dict_value_1 = var_data;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_c9af8615d8b382ab25d387a4ae2144bc->m_frame.f_lineno = 654;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 654;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c9af8615d8b382ab25d387a4ae2144bc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c9af8615d8b382ab25d387a4ae2144bc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c9af8615d8b382ab25d387a4ae2144bc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c9af8615d8b382ab25d387a4ae2144bc, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_c9af8615d8b382ab25d387a4ae2144bc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c9af8615d8b382ab25d387a4ae2144bc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_c9af8615d8b382ab25d387a4ae2144bc,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_name,
        par_public,
        par_collaborative,
        par_description,
        var_data
    );


    // Release cached frame.
    if (frame_c9af8615d8b382ab25d387a4ae2144bc == cache_frame_c9af8615d8b382ab25d387a4ae2144bc) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_c9af8615d8b382ab25d387a4ae2144bc);
    }
    cache_frame_c9af8615d8b382ab25d387a4ae2144bc = NULL;

    assertFrameObject(frame_c9af8615d8b382ab25d387a4ae2144bc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT(var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_public);
    Py_DECREF(par_public);
    CHECK_OBJECT(par_collaborative);
    Py_DECREF(par_collaborative);
    CHECK_OBJECT(par_description);
    Py_DECREF(par_description);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_name);
    Py_DECREF(par_name);
    CHECK_OBJECT(par_public);
    Py_DECREF(par_public);
    CHECK_OBJECT(par_collaborative);
    Py_DECREF(par_collaborative);
    CHECK_OBJECT(par_description);
    Py_DECREF(par_description);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_42_user_playlist_unfollow(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    struct Nuitka_FrameObject *frame_e88bbbf696a76c8d25dfac8c1b201a35;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_e88bbbf696a76c8d25dfac8c1b201a35 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_e88bbbf696a76c8d25dfac8c1b201a35)) {
        Py_XDECREF(cache_frame_e88bbbf696a76c8d25dfac8c1b201a35);

#if _DEBUG_REFCOUNTS
        if (cache_frame_e88bbbf696a76c8d25dfac8c1b201a35 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_e88bbbf696a76c8d25dfac8c1b201a35 = MAKE_FUNCTION_FRAME(codeobj_e88bbbf696a76c8d25dfac8c1b201a35, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_e88bbbf696a76c8d25dfac8c1b201a35->m_type_description == NULL);
    frame_e88bbbf696a76c8d25dfac8c1b201a35 = cache_frame_e88bbbf696a76c8d25dfac8c1b201a35;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e88bbbf696a76c8d25dfac8c1b201a35);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e88bbbf696a76c8d25dfac8c1b201a35) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 665;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_51757cba85587a91188620a63866ff3b;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_1 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(par_playlist_id);
        tmp_tuple_element_1 = par_playlist_id;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_1);
        tmp_args_element_name_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 666;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_e88bbbf696a76c8d25dfac8c1b201a35->m_frame.f_lineno = 665;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 665;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e88bbbf696a76c8d25dfac8c1b201a35);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e88bbbf696a76c8d25dfac8c1b201a35);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e88bbbf696a76c8d25dfac8c1b201a35);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e88bbbf696a76c8d25dfac8c1b201a35, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_e88bbbf696a76c8d25dfac8c1b201a35->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e88bbbf696a76c8d25dfac8c1b201a35, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_e88bbbf696a76c8d25dfac8c1b201a35,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id
    );


    // Release cached frame.
    if (frame_e88bbbf696a76c8d25dfac8c1b201a35 == cache_frame_e88bbbf696a76c8d25dfac8c1b201a35) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_e88bbbf696a76c8d25dfac8c1b201a35);
    }
    cache_frame_e88bbbf696a76c8d25dfac8c1b201a35 = NULL;

    assertFrameObject(frame_e88bbbf696a76c8d25dfac8c1b201a35);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_43_user_playlist_add_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_tracks = python_pars[3];
    PyObject *par_position = python_pars[4];
    PyObject *var_plid = NULL;
    PyObject *var_ftracks = NULL;
    PyObject *outline_0_var_tid = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_0b02fe1bf74fa2e8f3be10e4fea252d1;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1)) {
        Py_XDECREF(cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1);

#if _DEBUG_REFCOUNTS
        if (cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1 = MAKE_FUNCTION_FRAME(codeobj_0b02fe1bf74fa2e8f3be10e4fea252d1, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1->m_type_description == NULL);
    frame_0b02fe1bf74fa2e8f3be10e4fea252d1 = cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_0b02fe1bf74fa2e8f3be10e4fea252d1);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_0b02fe1bf74fa2e8f3be10e4fea252d1) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_0b02fe1bf74fa2e8f3be10e4fea252d1->m_frame.f_lineno = 680;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 680;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 681;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_4;
        }
        if (isFrameUnusable(cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2)) {
            Py_XDECREF(cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2 = MAKE_FUNCTION_FRAME(codeobj_b8a3c8eb6d0cfed599a0ebaf4228cb7e, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2->m_type_description == NULL);
        frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2 = cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 681;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_6 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_tid;
                outline_0_var_tid = tmp_assign_source_6;
                Py_INCREF(outline_0_var_tid);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            tmp_args_element_name_3 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_tid);
            tmp_args_element_name_4 = outline_0_var_tid;
            frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2->m_frame.f_lineno = 681;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain__get_uri, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 681;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 681;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 681;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_2 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_2);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2,
            type_description_2,
            outline_0_var_tid,
            par_self
        );


        // Release cached frame.
        if (frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2 == cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);
        }
        cache_frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2 = NULL;

        assertFrameObject(frame_b8a3c8eb6d0cfed599a0ebaf4228cb7e_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_tid);
        outline_0_var_tid = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_tid);
        outline_0_var_tid = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 681;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_ftracks == NULL);
        var_ftracks = tmp_assign_source_2;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__post);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 682;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(var_plid);
        tmp_tuple_element_2 = var_plid;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 683;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_payload;
        CHECK_OBJECT(var_ftracks);
        tmp_dict_value_1 = var_ftracks;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_position;
        CHECK_OBJECT(par_position);
        tmp_dict_value_2 = par_position;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_0b02fe1bf74fa2e8f3be10e4fea252d1->m_frame.f_lineno = 682;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 682;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0b02fe1bf74fa2e8f3be10e4fea252d1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_0b02fe1bf74fa2e8f3be10e4fea252d1);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_0b02fe1bf74fa2e8f3be10e4fea252d1);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_0b02fe1bf74fa2e8f3be10e4fea252d1, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_0b02fe1bf74fa2e8f3be10e4fea252d1->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_0b02fe1bf74fa2e8f3be10e4fea252d1, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_0b02fe1bf74fa2e8f3be10e4fea252d1,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_tracks,
        par_position,
        var_plid,
        var_ftracks
    );


    // Release cached frame.
    if (frame_0b02fe1bf74fa2e8f3be10e4fea252d1 == cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_0b02fe1bf74fa2e8f3be10e4fea252d1);
    }
    cache_frame_0b02fe1bf74fa2e8f3be10e4fea252d1 = NULL;

    assertFrameObject(frame_0b02fe1bf74fa2e8f3be10e4fea252d1);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    CHECK_OBJECT(var_ftracks);
    Py_DECREF(var_ftracks);
    var_ftracks = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    Py_XDECREF(var_ftracks);
    var_ftracks = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_position);
    Py_DECREF(par_position);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_position);
    Py_DECREF(par_position);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_44_user_playlist_replace_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_tracks = python_pars[3];
    PyObject *var_plid = NULL;
    PyObject *var_ftracks = NULL;
    PyObject *var_payload = NULL;
    PyObject *outline_0_var_tid = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_2d651ca3de79d85f11fde11a7e7de8a4;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_21a98671647d4c490602b522a14698c5_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_21a98671647d4c490602b522a14698c5_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_2d651ca3de79d85f11fde11a7e7de8a4 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_2d651ca3de79d85f11fde11a7e7de8a4)) {
        Py_XDECREF(cache_frame_2d651ca3de79d85f11fde11a7e7de8a4);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2d651ca3de79d85f11fde11a7e7de8a4 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2d651ca3de79d85f11fde11a7e7de8a4 = MAKE_FUNCTION_FRAME(codeobj_2d651ca3de79d85f11fde11a7e7de8a4, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2d651ca3de79d85f11fde11a7e7de8a4->m_type_description == NULL);
    frame_2d651ca3de79d85f11fde11a7e7de8a4 = cache_frame_2d651ca3de79d85f11fde11a7e7de8a4;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2d651ca3de79d85f11fde11a7e7de8a4);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2d651ca3de79d85f11fde11a7e7de8a4) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_2d651ca3de79d85f11fde11a7e7de8a4->m_frame.f_lineno = 696;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 696;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 697;
                type_description_1 = "ooooooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_4;
        }
        if (isFrameUnusable(cache_frame_21a98671647d4c490602b522a14698c5_2)) {
            Py_XDECREF(cache_frame_21a98671647d4c490602b522a14698c5_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_21a98671647d4c490602b522a14698c5_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_21a98671647d4c490602b522a14698c5_2 = MAKE_FUNCTION_FRAME(codeobj_21a98671647d4c490602b522a14698c5, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_21a98671647d4c490602b522a14698c5_2->m_type_description == NULL);
        frame_21a98671647d4c490602b522a14698c5_2 = cache_frame_21a98671647d4c490602b522a14698c5_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_21a98671647d4c490602b522a14698c5_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_21a98671647d4c490602b522a14698c5_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 697;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_6 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_tid;
                outline_0_var_tid = tmp_assign_source_6;
                Py_INCREF(outline_0_var_tid);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            tmp_args_element_name_3 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_tid);
            tmp_args_element_name_4 = outline_0_var_tid;
            frame_21a98671647d4c490602b522a14698c5_2->m_frame.f_lineno = 697;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain__get_uri, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 697;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 697;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 697;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_2 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_2);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_21a98671647d4c490602b522a14698c5_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_21a98671647d4c490602b522a14698c5_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_21a98671647d4c490602b522a14698c5_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_21a98671647d4c490602b522a14698c5_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_21a98671647d4c490602b522a14698c5_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_21a98671647d4c490602b522a14698c5_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_21a98671647d4c490602b522a14698c5_2,
            type_description_2,
            outline_0_var_tid,
            par_self
        );


        // Release cached frame.
        if (frame_21a98671647d4c490602b522a14698c5_2 == cache_frame_21a98671647d4c490602b522a14698c5_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_21a98671647d4c490602b522a14698c5_2);
        }
        cache_frame_21a98671647d4c490602b522a14698c5_2 = NULL;

        assertFrameObject(frame_21a98671647d4c490602b522a14698c5_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooooooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_tid);
        outline_0_var_tid = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_tid);
        outline_0_var_tid = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 697;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_ftracks == NULL);
        var_ftracks = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        tmp_dict_key_1 = const_str_plain_uris;
        CHECK_OBJECT(var_ftracks);
        tmp_dict_value_1 = var_ftracks;
        tmp_assign_source_7 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_assign_source_7, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        assert(var_payload == NULL);
        var_payload = tmp_assign_source_7;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 699;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(var_plid);
        tmp_tuple_element_2 = var_plid;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 700;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_2 = const_str_plain_payload;
        CHECK_OBJECT(var_payload);
        tmp_dict_value_2 = var_payload;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_2d651ca3de79d85f11fde11a7e7de8a4->m_frame.f_lineno = 699;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 699;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d651ca3de79d85f11fde11a7e7de8a4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d651ca3de79d85f11fde11a7e7de8a4);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2d651ca3de79d85f11fde11a7e7de8a4);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2d651ca3de79d85f11fde11a7e7de8a4, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2d651ca3de79d85f11fde11a7e7de8a4->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2d651ca3de79d85f11fde11a7e7de8a4, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2d651ca3de79d85f11fde11a7e7de8a4,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_tracks,
        var_plid,
        var_ftracks,
        var_payload
    );


    // Release cached frame.
    if (frame_2d651ca3de79d85f11fde11a7e7de8a4 == cache_frame_2d651ca3de79d85f11fde11a7e7de8a4) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2d651ca3de79d85f11fde11a7e7de8a4);
    }
    cache_frame_2d651ca3de79d85f11fde11a7e7de8a4 = NULL;

    assertFrameObject(frame_2d651ca3de79d85f11fde11a7e7de8a4);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    CHECK_OBJECT(var_ftracks);
    Py_DECREF(var_ftracks);
    var_ftracks = NULL;

    CHECK_OBJECT(var_payload);
    Py_DECREF(var_payload);
    var_payload = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    Py_XDECREF(var_ftracks);
    var_ftracks = NULL;

    Py_XDECREF(var_payload);
    var_payload = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_45_user_playlist_reorder_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_range_start = python_pars[3];
    PyObject *par_insert_before = python_pars[4];
    PyObject *par_range_length = python_pars[5];
    PyObject *par_snapshot_id = python_pars[6];
    PyObject *var_plid = NULL;
    PyObject *var_payload = NULL;
    struct Nuitka_FrameObject *frame_461ef44fe0103cf3dcb9bc48cf4045fa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa)) {
        Py_XDECREF(cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa);

#if _DEBUG_REFCOUNTS
        if (cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa = MAKE_FUNCTION_FRAME(codeobj_461ef44fe0103cf3dcb9bc48cf4045fa, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa->m_type_description == NULL);
    frame_461ef44fe0103cf3dcb9bc48cf4045fa = cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_461ef44fe0103cf3dcb9bc48cf4045fa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_461ef44fe0103cf3dcb9bc48cf4045fa) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_461ef44fe0103cf3dcb9bc48cf4045fa->m_frame.f_lineno = 724;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 724;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        tmp_dict_key_1 = const_str_plain_range_start;
        CHECK_OBJECT(par_range_start);
        tmp_dict_value_1 = par_range_start;
        tmp_assign_source_2 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_assign_source_2, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_range_length;
        CHECK_OBJECT(par_range_length);
        tmp_dict_value_2 = par_range_length;
        tmp_res = PyDict_SetItem(tmp_assign_source_2, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_insert_before;
        CHECK_OBJECT(par_insert_before);
        tmp_dict_value_3 = par_insert_before;
        tmp_res = PyDict_SetItem(tmp_assign_source_2, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        assert(var_payload == NULL);
        var_payload = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_snapshot_id);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_snapshot_id);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 730;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    CHECK_OBJECT(par_snapshot_id);
    tmp_dictset_value = par_snapshot_id;
    CHECK_OBJECT(var_payload);
    tmp_dictset_dict = var_payload;
    tmp_dictset_key = const_str_plain_snapshot_id;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 732;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(var_plid);
        tmp_tuple_element_2 = var_plid;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 733;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_4 = const_str_plain_payload;
        CHECK_OBJECT(var_payload);
        tmp_dict_value_4 = var_payload;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        frame_461ef44fe0103cf3dcb9bc48cf4045fa->m_frame.f_lineno = 732;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 732;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_461ef44fe0103cf3dcb9bc48cf4045fa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_461ef44fe0103cf3dcb9bc48cf4045fa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_461ef44fe0103cf3dcb9bc48cf4045fa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_461ef44fe0103cf3dcb9bc48cf4045fa, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_461ef44fe0103cf3dcb9bc48cf4045fa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_461ef44fe0103cf3dcb9bc48cf4045fa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_461ef44fe0103cf3dcb9bc48cf4045fa,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_range_start,
        par_insert_before,
        par_range_length,
        par_snapshot_id,
        var_plid,
        var_payload
    );


    // Release cached frame.
    if (frame_461ef44fe0103cf3dcb9bc48cf4045fa == cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_461ef44fe0103cf3dcb9bc48cf4045fa);
    }
    cache_frame_461ef44fe0103cf3dcb9bc48cf4045fa = NULL;

    assertFrameObject(frame_461ef44fe0103cf3dcb9bc48cf4045fa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    CHECK_OBJECT(var_payload);
    Py_DECREF(var_payload);
    var_payload = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    Py_XDECREF(var_payload);
    var_payload = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_range_start);
    Py_DECREF(par_range_start);
    CHECK_OBJECT(par_insert_before);
    Py_DECREF(par_insert_before);
    CHECK_OBJECT(par_range_length);
    Py_DECREF(par_range_length);
    CHECK_OBJECT(par_snapshot_id);
    Py_DECREF(par_snapshot_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_range_start);
    Py_DECREF(par_range_start);
    CHECK_OBJECT(par_insert_before);
    Py_DECREF(par_insert_before);
    CHECK_OBJECT(par_range_length);
    Py_DECREF(par_range_length);
    CHECK_OBJECT(par_snapshot_id);
    Py_DECREF(par_snapshot_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_46_user_playlist_remove_all_occurrences_of_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_tracks = python_pars[3];
    PyObject *par_snapshot_id = python_pars[4];
    PyObject *var_plid = NULL;
    PyObject *var_ftracks = NULL;
    PyObject *var_payload = NULL;
    PyObject *outline_0_var_tid = NULL;
    PyObject *outline_1_var_track = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    PyObject *tmp_listcomp_2__$0 = NULL;
    PyObject *tmp_listcomp_2__contraction = NULL;
    PyObject *tmp_listcomp_2__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_b3c4b5edc4fdbdc86e95e400aff5eb12;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    struct Nuitka_FrameObject *frame_faef31ac41c50554a2c87cdc350362bb_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_faef31ac41c50554a2c87cdc350362bb_3 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12 = NULL;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12)) {
        Py_XDECREF(cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12);

#if _DEBUG_REFCOUNTS
        if (cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12 = MAKE_FUNCTION_FRAME(codeobj_b3c4b5edc4fdbdc86e95e400aff5eb12, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12->m_type_description == NULL);
    frame_b3c4b5edc4fdbdc86e95e400aff5eb12 = cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b3c4b5edc4fdbdc86e95e400aff5eb12);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b3c4b5edc4fdbdc86e95e400aff5eb12) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_b3c4b5edc4fdbdc86e95e400aff5eb12->m_frame.f_lineno = 749;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 749;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 750;
                type_description_1 = "oooooooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_4;
        }
        if (isFrameUnusable(cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2)) {
            Py_XDECREF(cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2 = MAKE_FUNCTION_FRAME(codeobj_9c2f0b6ba6c67834b6917d8d37ef1b06, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2->m_type_description == NULL);
        frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2 = cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 750;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_6 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_tid;
                outline_0_var_tid = tmp_assign_source_6;
                Py_INCREF(outline_0_var_tid);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_3;
            PyObject *tmp_args_element_name_4;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            tmp_args_element_name_3 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_tid);
            tmp_args_element_name_4 = outline_0_var_tid;
            frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2->m_frame.f_lineno = 750;
            {
                PyObject *call_args[] = {tmp_args_element_name_3, tmp_args_element_name_4};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain__get_uri, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 750;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 750;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 750;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_2 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_2);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2,
            type_description_2,
            outline_0_var_tid,
            par_self
        );


        // Release cached frame.
        if (frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2 == cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);
        }
        cache_frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2 = NULL;

        assertFrameObject(frame_9c2f0b6ba6c67834b6917d8d37ef1b06_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "oooooooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_tid);
        outline_0_var_tid = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_tid);
        outline_0_var_tid = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 750;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_ftracks == NULL);
        var_ftracks = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        tmp_dict_key_1 = const_str_plain_tracks;
        // Tried code:
        {
            PyObject *tmp_assign_source_8;
            PyObject *tmp_iter_arg_2;
            CHECK_OBJECT(var_ftracks);
            tmp_iter_arg_2 = var_ftracks;
            tmp_assign_source_8 = MAKE_ITERATOR(tmp_iter_arg_2);
            if (tmp_assign_source_8 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 751;
                type_description_1 = "oooooooo";
                goto try_except_handler_4;
            }
            assert(tmp_listcomp_2__$0 == NULL);
            tmp_listcomp_2__$0 = tmp_assign_source_8;
        }
        {
            PyObject *tmp_assign_source_9;
            tmp_assign_source_9 = PyList_New(0);
            assert(tmp_listcomp_2__contraction == NULL);
            tmp_listcomp_2__contraction = tmp_assign_source_9;
        }
        if (isFrameUnusable(cache_frame_faef31ac41c50554a2c87cdc350362bb_3)) {
            Py_XDECREF(cache_frame_faef31ac41c50554a2c87cdc350362bb_3);

#if _DEBUG_REFCOUNTS
            if (cache_frame_faef31ac41c50554a2c87cdc350362bb_3 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_faef31ac41c50554a2c87cdc350362bb_3 = MAKE_FUNCTION_FRAME(codeobj_faef31ac41c50554a2c87cdc350362bb, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_faef31ac41c50554a2c87cdc350362bb_3->m_type_description == NULL);
        frame_faef31ac41c50554a2c87cdc350362bb_3 = cache_frame_faef31ac41c50554a2c87cdc350362bb_3;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_faef31ac41c50554a2c87cdc350362bb_3);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_faef31ac41c50554a2c87cdc350362bb_3) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_2:;
        {
            PyObject *tmp_next_source_2;
            PyObject *tmp_assign_source_10;
            CHECK_OBJECT(tmp_listcomp_2__$0);
            tmp_next_source_2 = tmp_listcomp_2__$0;
            tmp_assign_source_10 = ITERATOR_NEXT(tmp_next_source_2);
            if (tmp_assign_source_10 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_2;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "o";
                    exception_lineno = 751;
                    goto try_except_handler_5;
                }
            }

            {
                PyObject *old = tmp_listcomp_2__iter_value_0;
                tmp_listcomp_2__iter_value_0 = tmp_assign_source_10;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_11;
            CHECK_OBJECT(tmp_listcomp_2__iter_value_0);
            tmp_assign_source_11 = tmp_listcomp_2__iter_value_0;
            {
                PyObject *old = outline_1_var_track;
                outline_1_var_track = tmp_assign_source_11;
                Py_INCREF(outline_1_var_track);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_2;
            PyObject *tmp_append_value_2;
            PyObject *tmp_dict_key_2;
            PyObject *tmp_dict_value_2;
            CHECK_OBJECT(tmp_listcomp_2__contraction);
            tmp_append_list_2 = tmp_listcomp_2__contraction;
            tmp_dict_key_2 = const_str_plain_uri;
            CHECK_OBJECT(outline_1_var_track);
            tmp_dict_value_2 = outline_1_var_track;
            tmp_append_value_2 = _PyDict_NewPresized( 1 );
            tmp_res = PyDict_SetItem(tmp_append_value_2, tmp_dict_key_2, tmp_dict_value_2);
            assert(!(tmp_res != 0));
            assert(PyList_Check(tmp_append_list_2));
            tmp_res = PyList_Append(tmp_append_list_2, tmp_append_value_2);
            Py_DECREF(tmp_append_value_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 751;
                type_description_2 = "o";
                goto try_except_handler_5;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 751;
            type_description_2 = "o";
            goto try_except_handler_5;
        }
        goto loop_start_2;
        loop_end_2:;
        CHECK_OBJECT(tmp_listcomp_2__contraction);
        tmp_dict_value_1 = tmp_listcomp_2__contraction;
        Py_INCREF(tmp_dict_value_1);
        goto try_return_handler_5;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT(tmp_listcomp_2__$0);
        Py_DECREF(tmp_listcomp_2__$0);
        tmp_listcomp_2__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_2__contraction);
        Py_DECREF(tmp_listcomp_2__contraction);
        tmp_listcomp_2__contraction = NULL;

        Py_XDECREF(tmp_listcomp_2__iter_value_0);
        tmp_listcomp_2__iter_value_0 = NULL;

        goto frame_return_exit_3;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_2__$0);
        Py_DECREF(tmp_listcomp_2__$0);
        tmp_listcomp_2__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_2__contraction);
        Py_DECREF(tmp_listcomp_2__contraction);
        tmp_listcomp_2__contraction = NULL;

        Py_XDECREF(tmp_listcomp_2__iter_value_0);
        tmp_listcomp_2__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto frame_exception_exit_3;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_faef31ac41c50554a2c87cdc350362bb_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_return_exit_3:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_faef31ac41c50554a2c87cdc350362bb_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_4;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_faef31ac41c50554a2c87cdc350362bb_3);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_faef31ac41c50554a2c87cdc350362bb_3, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_faef31ac41c50554a2c87cdc350362bb_3->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_faef31ac41c50554a2c87cdc350362bb_3, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_faef31ac41c50554a2c87cdc350362bb_3,
            type_description_2,
            outline_1_var_track
        );


        // Release cached frame.
        if (frame_faef31ac41c50554a2c87cdc350362bb_3 == cache_frame_faef31ac41c50554a2c87cdc350362bb_3) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_faef31ac41c50554a2c87cdc350362bb_3);
        }
        cache_frame_faef31ac41c50554a2c87cdc350362bb_3 = NULL;

        assertFrameObject(frame_faef31ac41c50554a2c87cdc350362bb_3);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;
        type_description_1 = "oooooooo";
        goto try_except_handler_4;
        skip_nested_handling_2:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_4:;
        Py_XDECREF(outline_1_var_track);
        outline_1_var_track = NULL;

        goto outline_result_2;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_1_var_track);
        outline_1_var_track = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto outline_exception_2;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_2:;
        exception_lineno = 751;
        goto frame_exception_exit_1;
        outline_result_2:;
        tmp_assign_source_7 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_assign_source_7, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        assert(var_payload == NULL);
        var_payload = tmp_assign_source_7;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_snapshot_id);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_snapshot_id);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 752;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    CHECK_OBJECT(par_snapshot_id);
    tmp_dictset_value = par_snapshot_id;
    CHECK_OBJECT(var_payload);
    tmp_dictset_dict = var_payload;
    tmp_dictset_key = const_str_plain_snapshot_id;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 754;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(var_plid);
        tmp_tuple_element_2 = var_plid;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 755;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_3 = const_str_plain_payload;
        CHECK_OBJECT(var_payload);
        tmp_dict_value_3 = var_payload;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_b3c4b5edc4fdbdc86e95e400aff5eb12->m_frame.f_lineno = 754;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 754;
            type_description_1 = "oooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b3c4b5edc4fdbdc86e95e400aff5eb12);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_3;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b3c4b5edc4fdbdc86e95e400aff5eb12);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b3c4b5edc4fdbdc86e95e400aff5eb12);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b3c4b5edc4fdbdc86e95e400aff5eb12, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_b3c4b5edc4fdbdc86e95e400aff5eb12->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b3c4b5edc4fdbdc86e95e400aff5eb12, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_b3c4b5edc4fdbdc86e95e400aff5eb12,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_tracks,
        par_snapshot_id,
        var_plid,
        var_ftracks,
        var_payload
    );


    // Release cached frame.
    if (frame_b3c4b5edc4fdbdc86e95e400aff5eb12 == cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_b3c4b5edc4fdbdc86e95e400aff5eb12);
    }
    cache_frame_b3c4b5edc4fdbdc86e95e400aff5eb12 = NULL;

    assertFrameObject(frame_b3c4b5edc4fdbdc86e95e400aff5eb12);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_3:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    CHECK_OBJECT(var_ftracks);
    Py_DECREF(var_ftracks);
    var_ftracks = NULL;

    CHECK_OBJECT(var_payload);
    Py_DECREF(var_payload);
    var_payload = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    Py_XDECREF(var_ftracks);
    var_ftracks = NULL;

    Py_XDECREF(var_payload);
    var_payload = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_snapshot_id);
    Py_DECREF(par_snapshot_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_snapshot_id);
    Py_DECREF(par_snapshot_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_47_user_playlist_remove_specific_occurrences_of_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_user = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_tracks = python_pars[3];
    PyObject *par_snapshot_id = python_pars[4];
    PyObject *var_plid = NULL;
    PyObject *var_ftracks = NULL;
    PyObject *var_tr = NULL;
    PyObject *var_payload = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    struct Nuitka_FrameObject *frame_65974833a3df4d178e6a07b93e7b2058;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_65974833a3df4d178e6a07b93e7b2058 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_65974833a3df4d178e6a07b93e7b2058)) {
        Py_XDECREF(cache_frame_65974833a3df4d178e6a07b93e7b2058);

#if _DEBUG_REFCOUNTS
        if (cache_frame_65974833a3df4d178e6a07b93e7b2058 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_65974833a3df4d178e6a07b93e7b2058 = MAKE_FUNCTION_FRAME(codeobj_65974833a3df4d178e6a07b93e7b2058, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_65974833a3df4d178e6a07b93e7b2058->m_type_description == NULL);
    frame_65974833a3df4d178e6a07b93e7b2058 = cache_frame_65974833a3df4d178e6a07b93e7b2058;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_65974833a3df4d178e6a07b93e7b2058);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_65974833a3df4d178e6a07b93e7b2058) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_playlist;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_2 = par_playlist_id;
        frame_65974833a3df4d178e6a07b93e7b2058->m_frame.f_lineno = 774;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 774;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(var_plid == NULL);
        var_plid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = PyList_New(0);
        assert(var_ftracks == NULL);
        var_ftracks = tmp_assign_source_2;
    }
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_iter_arg_1;
        CHECK_OBJECT(par_tracks);
        tmp_iter_arg_1 = par_tracks;
        tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 776;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_3;
    }
    // Tried code:
    loop_start_1:;
    {
        PyObject *tmp_next_source_1;
        PyObject *tmp_assign_source_4;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_1 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
        if (tmp_assign_source_4 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_1;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooo";
                exception_lineno = 776;
                goto try_except_handler_2;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_4;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_5;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_5 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_tr;
            var_tr = tmp_assign_source_5;
            Py_INCREF(var_tr);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_expression_name_4;
        PyObject *tmp_subscript_name_2;
        CHECK_OBJECT(var_ftracks);
        tmp_expression_name_1 = var_ftracks;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_append);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 777;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_dict_key_1 = const_str_plain_uri;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__get_uri);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 779;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_4 = const_str_plain_track;
        CHECK_OBJECT(var_tr);
        tmp_expression_name_3 = var_tr;
        tmp_subscript_name_1 = const_str_plain_uri;
        tmp_args_element_name_5 = LOOKUP_SUBSCRIPT(tmp_expression_name_3, tmp_subscript_name_1);
        if (tmp_args_element_name_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 779;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        frame_65974833a3df4d178e6a07b93e7b2058->m_frame.f_lineno = 779;
        {
            PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
            tmp_dict_value_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_dict_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 779;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_args_element_name_3 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_args_element_name_3, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_positions;
        CHECK_OBJECT(var_tr);
        tmp_expression_name_4 = var_tr;
        tmp_subscript_name_2 = const_str_plain_positions;
        tmp_dict_value_2 = LOOKUP_SUBSCRIPT(tmp_expression_name_4, tmp_subscript_name_2);
        if (tmp_dict_value_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_args_element_name_3);

            exception_lineno = 780;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        tmp_res = PyDict_SetItem(tmp_args_element_name_3, tmp_dict_key_2, tmp_dict_value_2);
        Py_DECREF(tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_65974833a3df4d178e6a07b93e7b2058->m_frame.f_lineno = 777;
        tmp_call_result_1 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 777;
            type_description_1 = "ooooooooo";
            goto try_except_handler_2;
        }
        Py_DECREF(tmp_call_result_1);
    }
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 776;
        type_description_1 = "ooooooooo";
        goto try_except_handler_2;
    }
    goto loop_start_1;
    loop_end_1:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_2:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT(tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT(tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        tmp_dict_key_3 = const_str_plain_tracks;
        CHECK_OBJECT(var_ftracks);
        tmp_dict_value_3 = var_ftracks;
        tmp_assign_source_6 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_assign_source_6, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        assert(var_payload == NULL);
        var_payload = tmp_assign_source_6;
    }
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_snapshot_id);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_snapshot_id);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 784;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    CHECK_OBJECT(par_snapshot_id);
    tmp_dictset_value = par_snapshot_id;
    CHECK_OBJECT(var_payload);
    tmp_dictset_dict = var_payload;
    tmp_dictset_key = const_str_plain_snapshot_id;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_1:;
    {
        PyObject *tmp_called_name_3;
        PyObject *tmp_expression_name_5;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_5 = par_self;
        tmp_called_name_3 = LOOKUP_ATTRIBUTE(tmp_expression_name_5, const_str_plain__delete);
        if (tmp_called_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 786;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_1bce3c517fbddf8f52f2b01cb5e58e41;
        CHECK_OBJECT(par_user);
        tmp_tuple_element_2 = par_user;
        tmp_right_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(var_plid);
        tmp_tuple_element_2 = var_plid;
        Py_INCREF(tmp_tuple_element_2);
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_tuple_element_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_3);

            exception_lineno = 787;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_4 = const_str_plain_payload;
        CHECK_OBJECT(var_payload);
        tmp_dict_value_4 = var_payload;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        frame_65974833a3df4d178e6a07b93e7b2058->m_frame.f_lineno = 786;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_3, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_3);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 786;
            type_description_1 = "ooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_65974833a3df4d178e6a07b93e7b2058);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_65974833a3df4d178e6a07b93e7b2058);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_65974833a3df4d178e6a07b93e7b2058);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_65974833a3df4d178e6a07b93e7b2058, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_65974833a3df4d178e6a07b93e7b2058->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_65974833a3df4d178e6a07b93e7b2058, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_65974833a3df4d178e6a07b93e7b2058,
        type_description_1,
        par_self,
        par_user,
        par_playlist_id,
        par_tracks,
        par_snapshot_id,
        var_plid,
        var_ftracks,
        var_tr,
        var_payload
    );


    // Release cached frame.
    if (frame_65974833a3df4d178e6a07b93e7b2058 == cache_frame_65974833a3df4d178e6a07b93e7b2058) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_65974833a3df4d178e6a07b93e7b2058);
    }
    cache_frame_65974833a3df4d178e6a07b93e7b2058 = NULL;

    assertFrameObject(frame_65974833a3df4d178e6a07b93e7b2058);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_plid);
    Py_DECREF(var_plid);
    var_plid = NULL;

    CHECK_OBJECT(var_ftracks);
    Py_DECREF(var_ftracks);
    var_ftracks = NULL;

    Py_XDECREF(var_tr);
    var_tr = NULL;

    CHECK_OBJECT(var_payload);
    Py_DECREF(var_payload);
    var_payload = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_2 = exception_type;
    exception_keeper_value_2 = exception_value;
    exception_keeper_tb_2 = exception_tb;
    exception_keeper_lineno_2 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_plid);
    var_plid = NULL;

    Py_XDECREF(var_ftracks);
    var_ftracks = NULL;

    Py_XDECREF(var_tr);
    var_tr = NULL;

    Py_XDECREF(var_payload);
    var_payload = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_2;
    exception_value = exception_keeper_value_2;
    exception_tb = exception_keeper_tb_2;
    exception_lineno = exception_keeper_lineno_2;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_snapshot_id);
    Py_DECREF(par_snapshot_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_user);
    Py_DECREF(par_user);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);
    CHECK_OBJECT(par_snapshot_id);
    Py_DECREF(par_snapshot_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_48_user_playlist_follow_playlist(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_playlist_owner_id = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    struct Nuitka_FrameObject *frame_2c52ecf04878c5e07b5a9352531b27fd;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2c52ecf04878c5e07b5a9352531b27fd = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_2c52ecf04878c5e07b5a9352531b27fd)) {
        Py_XDECREF(cache_frame_2c52ecf04878c5e07b5a9352531b27fd);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2c52ecf04878c5e07b5a9352531b27fd == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2c52ecf04878c5e07b5a9352531b27fd = MAKE_FUNCTION_FRAME(codeobj_2c52ecf04878c5e07b5a9352531b27fd, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2c52ecf04878c5e07b5a9352531b27fd->m_type_description == NULL);
    frame_2c52ecf04878c5e07b5a9352531b27fd = cache_frame_2c52ecf04878c5e07b5a9352531b27fd;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2c52ecf04878c5e07b5a9352531b27fd);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2c52ecf04878c5e07b5a9352531b27fd) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 799;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_called_instance_1 = const_str_digest_c288d80fe09d5296eb3f023ab83cce4b;
        CHECK_OBJECT(par_playlist_owner_id);
        tmp_args_element_name_2 = par_playlist_owner_id;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_3 = par_playlist_id;
        frame_2c52ecf04878c5e07b5a9352531b27fd->m_frame.f_lineno = 800;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain_format, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 800;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_2c52ecf04878c5e07b5a9352531b27fd->m_frame.f_lineno = 799;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 799;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2c52ecf04878c5e07b5a9352531b27fd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2c52ecf04878c5e07b5a9352531b27fd);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2c52ecf04878c5e07b5a9352531b27fd);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2c52ecf04878c5e07b5a9352531b27fd, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2c52ecf04878c5e07b5a9352531b27fd->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2c52ecf04878c5e07b5a9352531b27fd, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2c52ecf04878c5e07b5a9352531b27fd,
        type_description_1,
        par_self,
        par_playlist_owner_id,
        par_playlist_id
    );


    // Release cached frame.
    if (frame_2c52ecf04878c5e07b5a9352531b27fd == cache_frame_2c52ecf04878c5e07b5a9352531b27fd) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2c52ecf04878c5e07b5a9352531b27fd);
    }
    cache_frame_2c52ecf04878c5e07b5a9352531b27fd = NULL;

    assertFrameObject(frame_2c52ecf04878c5e07b5a9352531b27fd);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_owner_id);
    Py_DECREF(par_playlist_owner_id);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_owner_id);
    Py_DECREF(par_playlist_owner_id);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_49_user_playlist_is_following(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_playlist_owner_id = python_pars[1];
    PyObject *par_playlist_id = python_pars[2];
    PyObject *par_user_ids = python_pars[3];
    struct Nuitka_FrameObject *frame_5e5a263fa0cb9631492a4fffaa6bde27;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_5e5a263fa0cb9631492a4fffaa6bde27 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_5e5a263fa0cb9631492a4fffaa6bde27)) {
        Py_XDECREF(cache_frame_5e5a263fa0cb9631492a4fffaa6bde27);

#if _DEBUG_REFCOUNTS
        if (cache_frame_5e5a263fa0cb9631492a4fffaa6bde27 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_5e5a263fa0cb9631492a4fffaa6bde27 = MAKE_FUNCTION_FRAME(codeobj_5e5a263fa0cb9631492a4fffaa6bde27, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_5e5a263fa0cb9631492a4fffaa6bde27->m_type_description == NULL);
    frame_5e5a263fa0cb9631492a4fffaa6bde27 = cache_frame_5e5a263fa0cb9631492a4fffaa6bde27;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5e5a263fa0cb9631492a4fffaa6bde27);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5e5a263fa0cb9631492a4fffaa6bde27) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_args_element_name_4;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_5;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 819;
            type_description_1 = "ooooN";
            goto frame_exception_exit_1;
        }
        tmp_expression_name_2 = const_str_digest_5ad7dec315c7c67463047637575d5a5d;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_format);
        assert(!(tmp_called_name_2 == NULL));
        CHECK_OBJECT(par_playlist_owner_id);
        tmp_args_element_name_2 = par_playlist_owner_id;
        CHECK_OBJECT(par_playlist_id);
        tmp_args_element_name_3 = par_playlist_id;
        tmp_called_instance_1 = const_str_chr_44;
        CHECK_OBJECT(par_user_ids);
        tmp_args_element_name_5 = par_user_ids;
        frame_5e5a263fa0cb9631492a4fffaa6bde27->m_frame.f_lineno = 820;
        {
            PyObject *call_args[] = {tmp_args_element_name_5};
            tmp_args_element_name_4 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_join, call_args);
        }

        if (tmp_args_element_name_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 820;
            type_description_1 = "ooooN";
            goto frame_exception_exit_1;
        }
        frame_5e5a263fa0cb9631492a4fffaa6bde27->m_frame.f_lineno = 820;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS3(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_4);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 820;
            type_description_1 = "ooooN";
            goto frame_exception_exit_1;
        }
        frame_5e5a263fa0cb9631492a4fffaa6bde27->m_frame.f_lineno = 819;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 819;
            type_description_1 = "ooooN";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e5a263fa0cb9631492a4fffaa6bde27);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e5a263fa0cb9631492a4fffaa6bde27);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5e5a263fa0cb9631492a4fffaa6bde27);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5e5a263fa0cb9631492a4fffaa6bde27, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_5e5a263fa0cb9631492a4fffaa6bde27->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5e5a263fa0cb9631492a4fffaa6bde27, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_5e5a263fa0cb9631492a4fffaa6bde27,
        type_description_1,
        par_self,
        par_playlist_owner_id,
        par_playlist_id,
        par_user_ids,
        NULL
    );


    // Release cached frame.
    if (frame_5e5a263fa0cb9631492a4fffaa6bde27 == cache_frame_5e5a263fa0cb9631492a4fffaa6bde27) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_5e5a263fa0cb9631492a4fffaa6bde27);
    }
    cache_frame_5e5a263fa0cb9631492a4fffaa6bde27 = NULL;

    assertFrameObject(frame_5e5a263fa0cb9631492a4fffaa6bde27);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_owner_id);
    Py_DECREF(par_playlist_owner_id);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_user_ids);
    Py_DECREF(par_user_ids);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_playlist_owner_id);
    Py_DECREF(par_playlist_owner_id);
    CHECK_OBJECT(par_playlist_id);
    Py_DECREF(par_playlist_id);
    CHECK_OBJECT(par_user_ids);
    Py_DECREF(par_user_ids);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_50_me(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_00663836178c09119ca59370dbc4f5ea;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_00663836178c09119ca59370dbc4f5ea = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_00663836178c09119ca59370dbc4f5ea)) {
        Py_XDECREF(cache_frame_00663836178c09119ca59370dbc4f5ea);

#if _DEBUG_REFCOUNTS
        if (cache_frame_00663836178c09119ca59370dbc4f5ea == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_00663836178c09119ca59370dbc4f5ea = MAKE_FUNCTION_FRAME(codeobj_00663836178c09119ca59370dbc4f5ea, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_00663836178c09119ca59370dbc4f5ea->m_type_description == NULL);
    frame_00663836178c09119ca59370dbc4f5ea = cache_frame_00663836178c09119ca59370dbc4f5ea;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_00663836178c09119ca59370dbc4f5ea);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_00663836178c09119ca59370dbc4f5ea) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_00663836178c09119ca59370dbc4f5ea->m_frame.f_lineno = 827;
        tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__get, &PyTuple_GET_ITEM(const_tuple_str_digest_da2afbbf6793907933f5ecd26dc790fb_tuple, 0));

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 827;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_00663836178c09119ca59370dbc4f5ea);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_00663836178c09119ca59370dbc4f5ea);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_00663836178c09119ca59370dbc4f5ea);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_00663836178c09119ca59370dbc4f5ea, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_00663836178c09119ca59370dbc4f5ea->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_00663836178c09119ca59370dbc4f5ea, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_00663836178c09119ca59370dbc4f5ea,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_00663836178c09119ca59370dbc4f5ea == cache_frame_00663836178c09119ca59370dbc4f5ea) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_00663836178c09119ca59370dbc4f5ea);
    }
    cache_frame_00663836178c09119ca59370dbc4f5ea = NULL;

    assertFrameObject(frame_00663836178c09119ca59370dbc4f5ea);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_51_current_user(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_53030939b146cc9d42e6d4f1be43e88c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_53030939b146cc9d42e6d4f1be43e88c = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_53030939b146cc9d42e6d4f1be43e88c)) {
        Py_XDECREF(cache_frame_53030939b146cc9d42e6d4f1be43e88c);

#if _DEBUG_REFCOUNTS
        if (cache_frame_53030939b146cc9d42e6d4f1be43e88c == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_53030939b146cc9d42e6d4f1be43e88c = MAKE_FUNCTION_FRAME(codeobj_53030939b146cc9d42e6d4f1be43e88c, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_53030939b146cc9d42e6d4f1be43e88c->m_type_description == NULL);
    frame_53030939b146cc9d42e6d4f1be43e88c = cache_frame_53030939b146cc9d42e6d4f1be43e88c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_53030939b146cc9d42e6d4f1be43e88c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_53030939b146cc9d42e6d4f1be43e88c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_53030939b146cc9d42e6d4f1be43e88c->m_frame.f_lineno = 833;
        tmp_return_value = CALL_METHOD_NO_ARGS(tmp_called_instance_1, const_str_plain_me);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 833;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_53030939b146cc9d42e6d4f1be43e88c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_53030939b146cc9d42e6d4f1be43e88c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_53030939b146cc9d42e6d4f1be43e88c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_53030939b146cc9d42e6d4f1be43e88c, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_53030939b146cc9d42e6d4f1be43e88c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_53030939b146cc9d42e6d4f1be43e88c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_53030939b146cc9d42e6d4f1be43e88c,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_53030939b146cc9d42e6d4f1be43e88c == cache_frame_53030939b146cc9d42e6d4f1be43e88c) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_53030939b146cc9d42e6d4f1be43e88c);
    }
    cache_frame_53030939b146cc9d42e6d4f1be43e88c = NULL;

    assertFrameObject(frame_53030939b146cc9d42e6d4f1be43e88c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_52_current_user_playing_track(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_807d4878b190acac94f898107f81fe18;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_807d4878b190acac94f898107f81fe18 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_807d4878b190acac94f898107f81fe18)) {
        Py_XDECREF(cache_frame_807d4878b190acac94f898107f81fe18);

#if _DEBUG_REFCOUNTS
        if (cache_frame_807d4878b190acac94f898107f81fe18 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_807d4878b190acac94f898107f81fe18 = MAKE_FUNCTION_FRAME(codeobj_807d4878b190acac94f898107f81fe18, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_807d4878b190acac94f898107f81fe18->m_type_description == NULL);
    frame_807d4878b190acac94f898107f81fe18 = cache_frame_807d4878b190acac94f898107f81fe18;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_807d4878b190acac94f898107f81fe18);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_807d4878b190acac94f898107f81fe18) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_807d4878b190acac94f898107f81fe18->m_frame.f_lineno = 838;
        tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__get, &PyTuple_GET_ITEM(const_tuple_str_digest_8921f974345d80799e10e01caa480348_tuple, 0));

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 838;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_807d4878b190acac94f898107f81fe18);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_807d4878b190acac94f898107f81fe18);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_807d4878b190acac94f898107f81fe18);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_807d4878b190acac94f898107f81fe18, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_807d4878b190acac94f898107f81fe18->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_807d4878b190acac94f898107f81fe18, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_807d4878b190acac94f898107f81fe18,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_807d4878b190acac94f898107f81fe18 == cache_frame_807d4878b190acac94f898107f81fe18) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_807d4878b190acac94f898107f81fe18);
    }
    cache_frame_807d4878b190acac94f898107f81fe18 = NULL;

    assertFrameObject(frame_807d4878b190acac94f898107f81fe18);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_53_current_user_saved_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_offset = python_pars[2];
    struct Nuitka_FrameObject *frame_e234381f83cd62c5730033d0a983bd87;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_e234381f83cd62c5730033d0a983bd87 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_e234381f83cd62c5730033d0a983bd87)) {
        Py_XDECREF(cache_frame_e234381f83cd62c5730033d0a983bd87);

#if _DEBUG_REFCOUNTS
        if (cache_frame_e234381f83cd62c5730033d0a983bd87 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_e234381f83cd62c5730033d0a983bd87 = MAKE_FUNCTION_FRAME(codeobj_e234381f83cd62c5730033d0a983bd87, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_e234381f83cd62c5730033d0a983bd87->m_type_description == NULL);
    frame_e234381f83cd62c5730033d0a983bd87 = cache_frame_e234381f83cd62c5730033d0a983bd87;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e234381f83cd62c5730033d0a983bd87);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e234381f83cd62c5730033d0a983bd87) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_78c0f8fb326d72503211c7f83461a856_tuple;
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_e234381f83cd62c5730033d0a983bd87->m_frame.f_lineno = 849;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 849;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e234381f83cd62c5730033d0a983bd87);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e234381f83cd62c5730033d0a983bd87);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e234381f83cd62c5730033d0a983bd87);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e234381f83cd62c5730033d0a983bd87, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_e234381f83cd62c5730033d0a983bd87->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e234381f83cd62c5730033d0a983bd87, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_e234381f83cd62c5730033d0a983bd87,
        type_description_1,
        par_self,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_e234381f83cd62c5730033d0a983bd87 == cache_frame_e234381f83cd62c5730033d0a983bd87) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_e234381f83cd62c5730033d0a983bd87);
    }
    cache_frame_e234381f83cd62c5730033d0a983bd87 = NULL;

    assertFrameObject(frame_e234381f83cd62c5730033d0a983bd87);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_54_current_user_followed_artists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_after = python_pars[2];
    struct Nuitka_FrameObject *frame_76dad211ce06eefadd08e6fe6a2ec222;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_76dad211ce06eefadd08e6fe6a2ec222 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_76dad211ce06eefadd08e6fe6a2ec222)) {
        Py_XDECREF(cache_frame_76dad211ce06eefadd08e6fe6a2ec222);

#if _DEBUG_REFCOUNTS
        if (cache_frame_76dad211ce06eefadd08e6fe6a2ec222 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_76dad211ce06eefadd08e6fe6a2ec222 = MAKE_FUNCTION_FRAME(codeobj_76dad211ce06eefadd08e6fe6a2ec222, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_76dad211ce06eefadd08e6fe6a2ec222->m_type_description == NULL);
    frame_76dad211ce06eefadd08e6fe6a2ec222 = cache_frame_76dad211ce06eefadd08e6fe6a2ec222;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_76dad211ce06eefadd08e6fe6a2ec222);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_76dad211ce06eefadd08e6fe6a2ec222) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_5b506f304dd8229333e7f1c8eeb8465b_tuple;
        tmp_dict_key_1 = const_str_plain_type;
        tmp_dict_value_1 = const_str_plain_artist;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_2 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_after;
        CHECK_OBJECT(par_after);
        tmp_dict_value_3 = par_after;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_76dad211ce06eefadd08e6fe6a2ec222->m_frame.f_lineno = 860;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 860;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_76dad211ce06eefadd08e6fe6a2ec222);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_76dad211ce06eefadd08e6fe6a2ec222);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_76dad211ce06eefadd08e6fe6a2ec222);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_76dad211ce06eefadd08e6fe6a2ec222, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_76dad211ce06eefadd08e6fe6a2ec222->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_76dad211ce06eefadd08e6fe6a2ec222, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_76dad211ce06eefadd08e6fe6a2ec222,
        type_description_1,
        par_self,
        par_limit,
        par_after
    );


    // Release cached frame.
    if (frame_76dad211ce06eefadd08e6fe6a2ec222 == cache_frame_76dad211ce06eefadd08e6fe6a2ec222) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_76dad211ce06eefadd08e6fe6a2ec222);
    }
    cache_frame_76dad211ce06eefadd08e6fe6a2ec222 = NULL;

    assertFrameObject(frame_76dad211ce06eefadd08e6fe6a2ec222);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_after);
    Py_DECREF(par_after);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_after);
    Py_DECREF(par_after);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_55_current_user_saved_tracks_delete(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_tracks = python_pars[1];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_t = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_efd3c2b04e65a2e7494c99d633f9af5b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_8f657b6a02f36cc5275fe109975cdb9f_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_efd3c2b04e65a2e7494c99d633f9af5b = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_efd3c2b04e65a2e7494c99d633f9af5b)) {
        Py_XDECREF(cache_frame_efd3c2b04e65a2e7494c99d633f9af5b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_efd3c2b04e65a2e7494c99d633f9af5b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_efd3c2b04e65a2e7494c99d633f9af5b = MAKE_FUNCTION_FRAME(codeobj_efd3c2b04e65a2e7494c99d633f9af5b, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_efd3c2b04e65a2e7494c99d633f9af5b->m_type_description == NULL);
    frame_efd3c2b04e65a2e7494c99d633f9af5b = cache_frame_efd3c2b04e65a2e7494c99d633f9af5b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_efd3c2b04e65a2e7494c99d633f9af5b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_efd3c2b04e65a2e7494c99d633f9af5b) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_tracks);
        tmp_compexpr_left_1 = par_tracks;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 873;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_4;
        }
        if (isFrameUnusable(cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2)) {
            Py_XDECREF(cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2 = MAKE_FUNCTION_FRAME(codeobj_8f657b6a02f36cc5275fe109975cdb9f, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2->m_type_description == NULL);
        frame_8f657b6a02f36cc5275fe109975cdb9f_2 = cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_8f657b6a02f36cc5275fe109975cdb9f_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_8f657b6a02f36cc5275fe109975cdb9f_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 873;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_6 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_t;
                outline_0_var_t = tmp_assign_source_6;
                Py_INCREF(outline_0_var_t);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_t);
            tmp_args_element_name_2 = outline_0_var_t;
            frame_8f657b6a02f36cc5275fe109975cdb9f_2->m_frame.f_lineno = 873;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 873;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 873;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 873;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_2 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_2);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8f657b6a02f36cc5275fe109975cdb9f_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_8f657b6a02f36cc5275fe109975cdb9f_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_8f657b6a02f36cc5275fe109975cdb9f_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_8f657b6a02f36cc5275fe109975cdb9f_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_8f657b6a02f36cc5275fe109975cdb9f_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_8f657b6a02f36cc5275fe109975cdb9f_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_8f657b6a02f36cc5275fe109975cdb9f_2,
            type_description_2,
            outline_0_var_t,
            par_self
        );


        // Release cached frame.
        if (frame_8f657b6a02f36cc5275fe109975cdb9f_2 == cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_8f657b6a02f36cc5275fe109975cdb9f_2);
        }
        cache_frame_8f657b6a02f36cc5275fe109975cdb9f_2 = NULL;

        assertFrameObject(frame_8f657b6a02f36cc5275fe109975cdb9f_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 873;
        goto frame_exception_exit_1;
        outline_result_1:;
        {
            PyObject *old = var_tlist;
            assert(old != NULL);
            var_tlist = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 874;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_798b1b3ff15941081d0a1905436770f1;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_4 = var_tlist;
        frame_efd3c2b04e65a2e7494c99d633f9af5b->m_frame.f_lineno = 874;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 874;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 874;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_efd3c2b04e65a2e7494c99d633f9af5b->m_frame.f_lineno = 874;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 874;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efd3c2b04e65a2e7494c99d633f9af5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_efd3c2b04e65a2e7494c99d633f9af5b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efd3c2b04e65a2e7494c99d633f9af5b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_efd3c2b04e65a2e7494c99d633f9af5b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_efd3c2b04e65a2e7494c99d633f9af5b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_efd3c2b04e65a2e7494c99d633f9af5b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_efd3c2b04e65a2e7494c99d633f9af5b,
        type_description_1,
        par_self,
        par_tracks,
        var_tlist
    );


    // Release cached frame.
    if (frame_efd3c2b04e65a2e7494c99d633f9af5b == cache_frame_efd3c2b04e65a2e7494c99d633f9af5b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_efd3c2b04e65a2e7494c99d633f9af5b);
    }
    cache_frame_efd3c2b04e65a2e7494c99d633f9af5b = NULL;

    assertFrameObject(frame_efd3c2b04e65a2e7494c99d633f9af5b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_56_current_user_saved_tracks_contains(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_tracks = python_pars[1];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_t = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_b62f655676fb2fb2ac69760ff8894e32;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_e9748f74fbae27652dd60c784d716940_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_e9748f74fbae27652dd60c784d716940_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_b62f655676fb2fb2ac69760ff8894e32 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_b62f655676fb2fb2ac69760ff8894e32)) {
        Py_XDECREF(cache_frame_b62f655676fb2fb2ac69760ff8894e32);

#if _DEBUG_REFCOUNTS
        if (cache_frame_b62f655676fb2fb2ac69760ff8894e32 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_b62f655676fb2fb2ac69760ff8894e32 = MAKE_FUNCTION_FRAME(codeobj_b62f655676fb2fb2ac69760ff8894e32, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_b62f655676fb2fb2ac69760ff8894e32->m_type_description == NULL);
    frame_b62f655676fb2fb2ac69760ff8894e32 = cache_frame_b62f655676fb2fb2ac69760ff8894e32;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_b62f655676fb2fb2ac69760ff8894e32);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_b62f655676fb2fb2ac69760ff8894e32) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_tracks);
        tmp_compexpr_left_1 = par_tracks;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 885;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_4;
        }
        if (isFrameUnusable(cache_frame_e9748f74fbae27652dd60c784d716940_2)) {
            Py_XDECREF(cache_frame_e9748f74fbae27652dd60c784d716940_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_e9748f74fbae27652dd60c784d716940_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_e9748f74fbae27652dd60c784d716940_2 = MAKE_FUNCTION_FRAME(codeobj_e9748f74fbae27652dd60c784d716940, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_e9748f74fbae27652dd60c784d716940_2->m_type_description == NULL);
        frame_e9748f74fbae27652dd60c784d716940_2 = cache_frame_e9748f74fbae27652dd60c784d716940_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_e9748f74fbae27652dd60c784d716940_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_e9748f74fbae27652dd60c784d716940_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 885;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_6 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_t;
                outline_0_var_t = tmp_assign_source_6;
                Py_INCREF(outline_0_var_t);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_t);
            tmp_args_element_name_2 = outline_0_var_t;
            frame_e9748f74fbae27652dd60c784d716940_2->m_frame.f_lineno = 885;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 885;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 885;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 885;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_2 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_2);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e9748f74fbae27652dd60c784d716940_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_e9748f74fbae27652dd60c784d716940_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e9748f74fbae27652dd60c784d716940_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_e9748f74fbae27652dd60c784d716940_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_e9748f74fbae27652dd60c784d716940_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_e9748f74fbae27652dd60c784d716940_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_e9748f74fbae27652dd60c784d716940_2,
            type_description_2,
            outline_0_var_t,
            par_self
        );


        // Release cached frame.
        if (frame_e9748f74fbae27652dd60c784d716940_2 == cache_frame_e9748f74fbae27652dd60c784d716940_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_e9748f74fbae27652dd60c784d716940_2);
        }
        cache_frame_e9748f74fbae27652dd60c784d716940_2 = NULL;

        assertFrameObject(frame_e9748f74fbae27652dd60c784d716940_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 885;
        goto frame_exception_exit_1;
        outline_result_1:;
        {
            PyObject *old = var_tlist;
            assert(old != NULL);
            var_tlist = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 886;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_d395ee4166bcad255ab6cb1b5c5f9e0b;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_4 = var_tlist;
        frame_b62f655676fb2fb2ac69760ff8894e32->m_frame.f_lineno = 886;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 886;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 886;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_b62f655676fb2fb2ac69760ff8894e32->m_frame.f_lineno = 886;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 886;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b62f655676fb2fb2ac69760ff8894e32);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_b62f655676fb2fb2ac69760ff8894e32);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_b62f655676fb2fb2ac69760ff8894e32);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_b62f655676fb2fb2ac69760ff8894e32, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_b62f655676fb2fb2ac69760ff8894e32->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_b62f655676fb2fb2ac69760ff8894e32, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_b62f655676fb2fb2ac69760ff8894e32,
        type_description_1,
        par_self,
        par_tracks,
        var_tlist
    );


    // Release cached frame.
    if (frame_b62f655676fb2fb2ac69760ff8894e32 == cache_frame_b62f655676fb2fb2ac69760ff8894e32) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_b62f655676fb2fb2ac69760ff8894e32);
    }
    cache_frame_b62f655676fb2fb2ac69760ff8894e32 = NULL;

    assertFrameObject(frame_b62f655676fb2fb2ac69760ff8894e32);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_57_current_user_saved_tracks_add(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_tracks = python_pars[1];
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_t = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_c802e26f9455ae469522a70187683133;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_b5fd4ac062544087b6a9ddde81164b51_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_b5fd4ac062544087b6a9ddde81164b51_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c802e26f9455ae469522a70187683133 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyList_New(0);
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_c802e26f9455ae469522a70187683133)) {
        Py_XDECREF(cache_frame_c802e26f9455ae469522a70187683133);

#if _DEBUG_REFCOUNTS
        if (cache_frame_c802e26f9455ae469522a70187683133 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_c802e26f9455ae469522a70187683133 = MAKE_FUNCTION_FRAME(codeobj_c802e26f9455ae469522a70187683133, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_c802e26f9455ae469522a70187683133->m_type_description == NULL);
    frame_c802e26f9455ae469522a70187683133 = cache_frame_c802e26f9455ae469522a70187683133;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c802e26f9455ae469522a70187683133);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c802e26f9455ae469522a70187683133) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_tracks);
        tmp_compexpr_left_1 = par_tracks;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assign_source_2;
        // Tried code:
        {
            PyObject *tmp_assign_source_3;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_3 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 897;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_3;
        }
        {
            PyObject *tmp_assign_source_4;
            tmp_assign_source_4 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_4;
        }
        if (isFrameUnusable(cache_frame_b5fd4ac062544087b6a9ddde81164b51_2)) {
            Py_XDECREF(cache_frame_b5fd4ac062544087b6a9ddde81164b51_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_b5fd4ac062544087b6a9ddde81164b51_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_b5fd4ac062544087b6a9ddde81164b51_2 = MAKE_FUNCTION_FRAME(codeobj_b5fd4ac062544087b6a9ddde81164b51, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_b5fd4ac062544087b6a9ddde81164b51_2->m_type_description == NULL);
        frame_b5fd4ac062544087b6a9ddde81164b51_2 = cache_frame_b5fd4ac062544087b6a9ddde81164b51_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_b5fd4ac062544087b6a9ddde81164b51_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_b5fd4ac062544087b6a9ddde81164b51_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_5 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_5 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 897;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_5;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_6 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_t;
                outline_0_var_t = tmp_assign_source_6;
                Py_INCREF(outline_0_var_t);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_t);
            tmp_args_element_name_2 = outline_0_var_t;
            frame_b5fd4ac062544087b6a9ddde81164b51_2->m_frame.f_lineno = 897;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 897;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 897;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 897;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_2 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_2);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b5fd4ac062544087b6a9ddde81164b51_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_b5fd4ac062544087b6a9ddde81164b51_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b5fd4ac062544087b6a9ddde81164b51_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_b5fd4ac062544087b6a9ddde81164b51_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_b5fd4ac062544087b6a9ddde81164b51_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_b5fd4ac062544087b6a9ddde81164b51_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_b5fd4ac062544087b6a9ddde81164b51_2,
            type_description_2,
            outline_0_var_t,
            par_self
        );


        // Release cached frame.
        if (frame_b5fd4ac062544087b6a9ddde81164b51_2 == cache_frame_b5fd4ac062544087b6a9ddde81164b51_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_b5fd4ac062544087b6a9ddde81164b51_2);
        }
        cache_frame_b5fd4ac062544087b6a9ddde81164b51_2 = NULL;

        assertFrameObject(frame_b5fd4ac062544087b6a9ddde81164b51_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 897;
        goto frame_exception_exit_1;
        outline_result_1:;
        {
            PyObject *old = var_tlist;
            assert(old != NULL);
            var_tlist = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 898;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_798b1b3ff15941081d0a1905436770f1;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_4 = var_tlist;
        frame_c802e26f9455ae469522a70187683133->m_frame.f_lineno = 898;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 898;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 898;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c802e26f9455ae469522a70187683133->m_frame.f_lineno = 898;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 898;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c802e26f9455ae469522a70187683133);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c802e26f9455ae469522a70187683133);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c802e26f9455ae469522a70187683133);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c802e26f9455ae469522a70187683133, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_c802e26f9455ae469522a70187683133->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c802e26f9455ae469522a70187683133, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_c802e26f9455ae469522a70187683133,
        type_description_1,
        par_self,
        par_tracks,
        var_tlist
    );


    // Release cached frame.
    if (frame_c802e26f9455ae469522a70187683133 == cache_frame_c802e26f9455ae469522a70187683133) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_c802e26f9455ae469522a70187683133);
    }
    cache_frame_c802e26f9455ae469522a70187683133 = NULL;

    assertFrameObject(frame_c802e26f9455ae469522a70187683133);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_tlist);
    Py_DECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_58_current_user_top_artists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_offset = python_pars[2];
    PyObject *par_time_range = python_pars[3];
    struct Nuitka_FrameObject *frame_beb81c8ff6f3724b3c8798c4c515daca;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_beb81c8ff6f3724b3c8798c4c515daca = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_beb81c8ff6f3724b3c8798c4c515daca)) {
        Py_XDECREF(cache_frame_beb81c8ff6f3724b3c8798c4c515daca);

#if _DEBUG_REFCOUNTS
        if (cache_frame_beb81c8ff6f3724b3c8798c4c515daca == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_beb81c8ff6f3724b3c8798c4c515daca = MAKE_FUNCTION_FRAME(codeobj_beb81c8ff6f3724b3c8798c4c515daca, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_beb81c8ff6f3724b3c8798c4c515daca->m_type_description == NULL);
    frame_beb81c8ff6f3724b3c8798c4c515daca = cache_frame_beb81c8ff6f3724b3c8798c4c515daca;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_beb81c8ff6f3724b3c8798c4c515daca);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_beb81c8ff6f3724b3c8798c4c515daca) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_f072b674dcd223579507c51d0df33d44_tuple;
        tmp_dict_key_1 = const_str_plain_time_range;
        CHECK_OBJECT(par_time_range);
        tmp_dict_value_1 = par_time_range;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_2 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_3 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_beb81c8ff6f3724b3c8798c4c515daca->m_frame.f_lineno = 911;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 911;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_beb81c8ff6f3724b3c8798c4c515daca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_beb81c8ff6f3724b3c8798c4c515daca);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_beb81c8ff6f3724b3c8798c4c515daca);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_beb81c8ff6f3724b3c8798c4c515daca, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_beb81c8ff6f3724b3c8798c4c515daca->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_beb81c8ff6f3724b3c8798c4c515daca, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_beb81c8ff6f3724b3c8798c4c515daca,
        type_description_1,
        par_self,
        par_limit,
        par_offset,
        par_time_range
    );


    // Release cached frame.
    if (frame_beb81c8ff6f3724b3c8798c4c515daca == cache_frame_beb81c8ff6f3724b3c8798c4c515daca) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_beb81c8ff6f3724b3c8798c4c515daca);
    }
    cache_frame_beb81c8ff6f3724b3c8798c4c515daca = NULL;

    assertFrameObject(frame_beb81c8ff6f3724b3c8798c4c515daca);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_time_range);
    Py_DECREF(par_time_range);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_time_range);
    Py_DECREF(par_time_range);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_59_current_user_top_tracks(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_offset = python_pars[2];
    PyObject *par_time_range = python_pars[3];
    struct Nuitka_FrameObject *frame_1350fb0c9dc013e11cfe4743a442a947;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_1350fb0c9dc013e11cfe4743a442a947 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_1350fb0c9dc013e11cfe4743a442a947)) {
        Py_XDECREF(cache_frame_1350fb0c9dc013e11cfe4743a442a947);

#if _DEBUG_REFCOUNTS
        if (cache_frame_1350fb0c9dc013e11cfe4743a442a947 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_1350fb0c9dc013e11cfe4743a442a947 = MAKE_FUNCTION_FRAME(codeobj_1350fb0c9dc013e11cfe4743a442a947, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_1350fb0c9dc013e11cfe4743a442a947->m_type_description == NULL);
    frame_1350fb0c9dc013e11cfe4743a442a947 = cache_frame_1350fb0c9dc013e11cfe4743a442a947;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1350fb0c9dc013e11cfe4743a442a947);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1350fb0c9dc013e11cfe4743a442a947) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_c7224164f58b9974744c1a8795894870_tuple;
        tmp_dict_key_1 = const_str_plain_time_range;
        CHECK_OBJECT(par_time_range);
        tmp_dict_value_1 = par_time_range;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_2 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_3 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_1350fb0c9dc013e11cfe4743a442a947->m_frame.f_lineno = 926;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 926;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1350fb0c9dc013e11cfe4743a442a947);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1350fb0c9dc013e11cfe4743a442a947);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1350fb0c9dc013e11cfe4743a442a947);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1350fb0c9dc013e11cfe4743a442a947, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_1350fb0c9dc013e11cfe4743a442a947->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1350fb0c9dc013e11cfe4743a442a947, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_1350fb0c9dc013e11cfe4743a442a947,
        type_description_1,
        par_self,
        par_limit,
        par_offset,
        par_time_range
    );


    // Release cached frame.
    if (frame_1350fb0c9dc013e11cfe4743a442a947 == cache_frame_1350fb0c9dc013e11cfe4743a442a947) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_1350fb0c9dc013e11cfe4743a442a947);
    }
    cache_frame_1350fb0c9dc013e11cfe4743a442a947 = NULL;

    assertFrameObject(frame_1350fb0c9dc013e11cfe4743a442a947);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_time_range);
    Py_DECREF(par_time_range);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_time_range);
    Py_DECREF(par_time_range);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_60_current_user_recently_played(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_after = python_pars[2];
    PyObject *par_before = python_pars[3];
    struct Nuitka_FrameObject *frame_965440f565182c6598dbf33c10541c66;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_965440f565182c6598dbf33c10541c66 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_965440f565182c6598dbf33c10541c66)) {
        Py_XDECREF(cache_frame_965440f565182c6598dbf33c10541c66);

#if _DEBUG_REFCOUNTS
        if (cache_frame_965440f565182c6598dbf33c10541c66 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_965440f565182c6598dbf33c10541c66 = MAKE_FUNCTION_FRAME(codeobj_965440f565182c6598dbf33c10541c66, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_965440f565182c6598dbf33c10541c66->m_type_description == NULL);
    frame_965440f565182c6598dbf33c10541c66 = cache_frame_965440f565182c6598dbf33c10541c66;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_965440f565182c6598dbf33c10541c66);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_965440f565182c6598dbf33c10541c66) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 942;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_dfc401f7f4274ac522480928076aa127_tuple;
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_after;
        CHECK_OBJECT(par_after);
        tmp_dict_value_2 = par_after;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_before;
        CHECK_OBJECT(par_before);
        tmp_dict_value_3 = par_before;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_965440f565182c6598dbf33c10541c66->m_frame.f_lineno = 942;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 942;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_965440f565182c6598dbf33c10541c66);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_965440f565182c6598dbf33c10541c66);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_965440f565182c6598dbf33c10541c66);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_965440f565182c6598dbf33c10541c66, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_965440f565182c6598dbf33c10541c66->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_965440f565182c6598dbf33c10541c66, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_965440f565182c6598dbf33c10541c66,
        type_description_1,
        par_self,
        par_limit,
        par_after,
        par_before
    );


    // Release cached frame.
    if (frame_965440f565182c6598dbf33c10541c66 == cache_frame_965440f565182c6598dbf33c10541c66) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_965440f565182c6598dbf33c10541c66);
    }
    cache_frame_965440f565182c6598dbf33c10541c66 = NULL;

    assertFrameObject(frame_965440f565182c6598dbf33c10541c66);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_after);
    Py_DECREF(par_after);
    CHECK_OBJECT(par_before);
    Py_DECREF(par_before);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_after);
    Py_DECREF(par_after);
    CHECK_OBJECT(par_before);
    Py_DECREF(par_before);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_61_current_user_saved_albums(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_offset = python_pars[2];
    struct Nuitka_FrameObject *frame_451a8011f44bd9fb715fc33536be8eaf;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_451a8011f44bd9fb715fc33536be8eaf = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_451a8011f44bd9fb715fc33536be8eaf)) {
        Py_XDECREF(cache_frame_451a8011f44bd9fb715fc33536be8eaf);

#if _DEBUG_REFCOUNTS
        if (cache_frame_451a8011f44bd9fb715fc33536be8eaf == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_451a8011f44bd9fb715fc33536be8eaf = MAKE_FUNCTION_FRAME(codeobj_451a8011f44bd9fb715fc33536be8eaf, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_451a8011f44bd9fb715fc33536be8eaf->m_type_description == NULL);
    frame_451a8011f44bd9fb715fc33536be8eaf = cache_frame_451a8011f44bd9fb715fc33536be8eaf;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_451a8011f44bd9fb715fc33536be8eaf);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_451a8011f44bd9fb715fc33536be8eaf) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 958;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_182a5343dd2556daa4702ebff5e2a31b_tuple;
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_451a8011f44bd9fb715fc33536be8eaf->m_frame.f_lineno = 958;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 958;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_451a8011f44bd9fb715fc33536be8eaf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_451a8011f44bd9fb715fc33536be8eaf);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_451a8011f44bd9fb715fc33536be8eaf);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_451a8011f44bd9fb715fc33536be8eaf, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_451a8011f44bd9fb715fc33536be8eaf->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_451a8011f44bd9fb715fc33536be8eaf, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_451a8011f44bd9fb715fc33536be8eaf,
        type_description_1,
        par_self,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_451a8011f44bd9fb715fc33536be8eaf == cache_frame_451a8011f44bd9fb715fc33536be8eaf) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_451a8011f44bd9fb715fc33536be8eaf);
    }
    cache_frame_451a8011f44bd9fb715fc33536be8eaf = NULL;

    assertFrameObject(frame_451a8011f44bd9fb715fc33536be8eaf);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_62_current_user_saved_albums_contains(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_albums = python_pars[1];
    PyObject *var_alist = NULL;
    PyObject *outline_0_var_a = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_c8c71ecff826f1d926365130265beaa0;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_dc46bea2e1fc1b5ddb719d7050173072_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_c8c71ecff826f1d926365130265beaa0 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_c8c71ecff826f1d926365130265beaa0)) {
        Py_XDECREF(cache_frame_c8c71ecff826f1d926365130265beaa0);

#if _DEBUG_REFCOUNTS
        if (cache_frame_c8c71ecff826f1d926365130265beaa0 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_c8c71ecff826f1d926365130265beaa0 = MAKE_FUNCTION_FRAME(codeobj_c8c71ecff826f1d926365130265beaa0, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_c8c71ecff826f1d926365130265beaa0->m_type_description == NULL);
    frame_c8c71ecff826f1d926365130265beaa0 = cache_frame_c8c71ecff826f1d926365130265beaa0;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c8c71ecff826f1d926365130265beaa0);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c8c71ecff826f1d926365130265beaa0) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_albums);
            tmp_iter_arg_1 = par_albums;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 967;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2)) {
            Py_XDECREF(cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2 = MAKE_FUNCTION_FRAME(codeobj_dc46bea2e1fc1b5ddb719d7050173072, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2->m_type_description == NULL);
        frame_dc46bea2e1fc1b5ddb719d7050173072_2 = cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_dc46bea2e1fc1b5ddb719d7050173072_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_dc46bea2e1fc1b5ddb719d7050173072_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 967;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_a;
                outline_0_var_a = tmp_assign_source_5;
                Py_INCREF(outline_0_var_a);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_album;
            CHECK_OBJECT(outline_0_var_a);
            tmp_args_element_name_2 = outline_0_var_a;
            frame_dc46bea2e1fc1b5ddb719d7050173072_2->m_frame.f_lineno = 967;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 967;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 967;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 967;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_dc46bea2e1fc1b5ddb719d7050173072_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_dc46bea2e1fc1b5ddb719d7050173072_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_dc46bea2e1fc1b5ddb719d7050173072_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_dc46bea2e1fc1b5ddb719d7050173072_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_dc46bea2e1fc1b5ddb719d7050173072_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_dc46bea2e1fc1b5ddb719d7050173072_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_dc46bea2e1fc1b5ddb719d7050173072_2,
            type_description_2,
            outline_0_var_a,
            par_self
        );


        // Release cached frame.
        if (frame_dc46bea2e1fc1b5ddb719d7050173072_2 == cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_dc46bea2e1fc1b5ddb719d7050173072_2);
        }
        cache_frame_dc46bea2e1fc1b5ddb719d7050173072_2 = NULL;

        assertFrameObject(frame_dc46bea2e1fc1b5ddb719d7050173072_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 967;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_alist == NULL);
        var_alist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 968;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_5f146a4556c0c7bd93727cb0e0330379;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_alist);
        tmp_args_element_name_4 = var_alist;
        frame_c8c71ecff826f1d926365130265beaa0->m_frame.f_lineno = 968;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 968;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 968;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_c8c71ecff826f1d926365130265beaa0->m_frame.f_lineno = 968;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 968;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8c71ecff826f1d926365130265beaa0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8c71ecff826f1d926365130265beaa0);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8c71ecff826f1d926365130265beaa0);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c8c71ecff826f1d926365130265beaa0, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_c8c71ecff826f1d926365130265beaa0->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c8c71ecff826f1d926365130265beaa0, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_c8c71ecff826f1d926365130265beaa0,
        type_description_1,
        par_self,
        par_albums,
        var_alist
    );


    // Release cached frame.
    if (frame_c8c71ecff826f1d926365130265beaa0 == cache_frame_c8c71ecff826f1d926365130265beaa0) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_c8c71ecff826f1d926365130265beaa0);
    }
    cache_frame_c8c71ecff826f1d926365130265beaa0 = NULL;

    assertFrameObject(frame_c8c71ecff826f1d926365130265beaa0);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_alist);
    Py_DECREF(var_alist);
    var_alist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_alist);
    var_alist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_63_current_user_saved_albums_add(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_albums = python_pars[1];
    PyObject *var_alist = NULL;
    PyObject *outline_0_var_a = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_a4377935b5e1079fffa83973e17dd07e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_efe41bc1c089bb53bb12793c18870fbd_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_efe41bc1c089bb53bb12793c18870fbd_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_a4377935b5e1079fffa83973e17dd07e = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_a4377935b5e1079fffa83973e17dd07e)) {
        Py_XDECREF(cache_frame_a4377935b5e1079fffa83973e17dd07e);

#if _DEBUG_REFCOUNTS
        if (cache_frame_a4377935b5e1079fffa83973e17dd07e == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_a4377935b5e1079fffa83973e17dd07e = MAKE_FUNCTION_FRAME(codeobj_a4377935b5e1079fffa83973e17dd07e, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_a4377935b5e1079fffa83973e17dd07e->m_type_description == NULL);
    frame_a4377935b5e1079fffa83973e17dd07e = cache_frame_a4377935b5e1079fffa83973e17dd07e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_a4377935b5e1079fffa83973e17dd07e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_a4377935b5e1079fffa83973e17dd07e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_albums);
            tmp_iter_arg_1 = par_albums;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 976;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_efe41bc1c089bb53bb12793c18870fbd_2)) {
            Py_XDECREF(cache_frame_efe41bc1c089bb53bb12793c18870fbd_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_efe41bc1c089bb53bb12793c18870fbd_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_efe41bc1c089bb53bb12793c18870fbd_2 = MAKE_FUNCTION_FRAME(codeobj_efe41bc1c089bb53bb12793c18870fbd, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_efe41bc1c089bb53bb12793c18870fbd_2->m_type_description == NULL);
        frame_efe41bc1c089bb53bb12793c18870fbd_2 = cache_frame_efe41bc1c089bb53bb12793c18870fbd_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_efe41bc1c089bb53bb12793c18870fbd_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_efe41bc1c089bb53bb12793c18870fbd_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 976;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_a;
                outline_0_var_a = tmp_assign_source_5;
                Py_INCREF(outline_0_var_a);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_album;
            CHECK_OBJECT(outline_0_var_a);
            tmp_args_element_name_2 = outline_0_var_a;
            frame_efe41bc1c089bb53bb12793c18870fbd_2->m_frame.f_lineno = 976;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 976;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 976;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 976;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_efe41bc1c089bb53bb12793c18870fbd_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_efe41bc1c089bb53bb12793c18870fbd_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_efe41bc1c089bb53bb12793c18870fbd_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_efe41bc1c089bb53bb12793c18870fbd_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_efe41bc1c089bb53bb12793c18870fbd_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_efe41bc1c089bb53bb12793c18870fbd_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_efe41bc1c089bb53bb12793c18870fbd_2,
            type_description_2,
            outline_0_var_a,
            par_self
        );


        // Release cached frame.
        if (frame_efe41bc1c089bb53bb12793c18870fbd_2 == cache_frame_efe41bc1c089bb53bb12793c18870fbd_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_efe41bc1c089bb53bb12793c18870fbd_2);
        }
        cache_frame_efe41bc1c089bb53bb12793c18870fbd_2 = NULL;

        assertFrameObject(frame_efe41bc1c089bb53bb12793c18870fbd_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 976;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_alist == NULL);
        var_alist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 977;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_72b0d4f925b9f004a6696b8da7844b76;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_alist);
        tmp_args_element_name_4 = var_alist;
        frame_a4377935b5e1079fffa83973e17dd07e->m_frame.f_lineno = 977;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 977;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 977;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_a4377935b5e1079fffa83973e17dd07e->m_frame.f_lineno = 977;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 977;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4377935b5e1079fffa83973e17dd07e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4377935b5e1079fffa83973e17dd07e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_a4377935b5e1079fffa83973e17dd07e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_a4377935b5e1079fffa83973e17dd07e, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_a4377935b5e1079fffa83973e17dd07e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_a4377935b5e1079fffa83973e17dd07e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_a4377935b5e1079fffa83973e17dd07e,
        type_description_1,
        par_self,
        par_albums,
        var_alist
    );


    // Release cached frame.
    if (frame_a4377935b5e1079fffa83973e17dd07e == cache_frame_a4377935b5e1079fffa83973e17dd07e) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_a4377935b5e1079fffa83973e17dd07e);
    }
    cache_frame_a4377935b5e1079fffa83973e17dd07e = NULL;

    assertFrameObject(frame_a4377935b5e1079fffa83973e17dd07e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_alist);
    Py_DECREF(var_alist);
    var_alist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_alist);
    var_alist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_64_current_user_saved_albums_delete(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_albums = python_pars[1];
    PyObject *var_alist = NULL;
    PyObject *outline_0_var_a = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_ac03c002d6c914734a0ab63039d24303;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_dfa67eee91fa81af058566081de7dad5_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_dfa67eee91fa81af058566081de7dad5_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ac03c002d6c914734a0ab63039d24303 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_ac03c002d6c914734a0ab63039d24303)) {
        Py_XDECREF(cache_frame_ac03c002d6c914734a0ab63039d24303);

#if _DEBUG_REFCOUNTS
        if (cache_frame_ac03c002d6c914734a0ab63039d24303 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_ac03c002d6c914734a0ab63039d24303 = MAKE_FUNCTION_FRAME(codeobj_ac03c002d6c914734a0ab63039d24303, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_ac03c002d6c914734a0ab63039d24303->m_type_description == NULL);
    frame_ac03c002d6c914734a0ab63039d24303 = cache_frame_ac03c002d6c914734a0ab63039d24303;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ac03c002d6c914734a0ab63039d24303);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ac03c002d6c914734a0ab63039d24303) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_albums);
            tmp_iter_arg_1 = par_albums;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 986;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_dfa67eee91fa81af058566081de7dad5_2)) {
            Py_XDECREF(cache_frame_dfa67eee91fa81af058566081de7dad5_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_dfa67eee91fa81af058566081de7dad5_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_dfa67eee91fa81af058566081de7dad5_2 = MAKE_FUNCTION_FRAME(codeobj_dfa67eee91fa81af058566081de7dad5, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_dfa67eee91fa81af058566081de7dad5_2->m_type_description == NULL);
        frame_dfa67eee91fa81af058566081de7dad5_2 = cache_frame_dfa67eee91fa81af058566081de7dad5_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_dfa67eee91fa81af058566081de7dad5_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_dfa67eee91fa81af058566081de7dad5_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 986;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_a;
                outline_0_var_a = tmp_assign_source_5;
                Py_INCREF(outline_0_var_a);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_album;
            CHECK_OBJECT(outline_0_var_a);
            tmp_args_element_name_2 = outline_0_var_a;
            frame_dfa67eee91fa81af058566081de7dad5_2->m_frame.f_lineno = 986;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 986;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 986;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 986;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_dfa67eee91fa81af058566081de7dad5_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_dfa67eee91fa81af058566081de7dad5_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_dfa67eee91fa81af058566081de7dad5_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_dfa67eee91fa81af058566081de7dad5_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_dfa67eee91fa81af058566081de7dad5_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_dfa67eee91fa81af058566081de7dad5_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_dfa67eee91fa81af058566081de7dad5_2,
            type_description_2,
            outline_0_var_a,
            par_self
        );


        // Release cached frame.
        if (frame_dfa67eee91fa81af058566081de7dad5_2 == cache_frame_dfa67eee91fa81af058566081de7dad5_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_dfa67eee91fa81af058566081de7dad5_2);
        }
        cache_frame_dfa67eee91fa81af058566081de7dad5_2 = NULL;

        assertFrameObject(frame_dfa67eee91fa81af058566081de7dad5_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 986;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_alist == NULL);
        var_alist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 987;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_a3911b6aa4c898878e39b3942a493b69;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_alist);
        tmp_args_element_name_4 = var_alist;
        frame_ac03c002d6c914734a0ab63039d24303->m_frame.f_lineno = 987;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 987;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 987;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ac03c002d6c914734a0ab63039d24303->m_frame.f_lineno = 987;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 987;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ac03c002d6c914734a0ab63039d24303);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ac03c002d6c914734a0ab63039d24303);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ac03c002d6c914734a0ab63039d24303);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ac03c002d6c914734a0ab63039d24303, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_ac03c002d6c914734a0ab63039d24303->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ac03c002d6c914734a0ab63039d24303, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_ac03c002d6c914734a0ab63039d24303,
        type_description_1,
        par_self,
        par_albums,
        var_alist
    );


    // Release cached frame.
    if (frame_ac03c002d6c914734a0ab63039d24303 == cache_frame_ac03c002d6c914734a0ab63039d24303) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_ac03c002d6c914734a0ab63039d24303);
    }
    cache_frame_ac03c002d6c914734a0ab63039d24303 = NULL;

    assertFrameObject(frame_ac03c002d6c914734a0ab63039d24303);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_alist);
    Py_DECREF(var_alist);
    var_alist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_alist);
    var_alist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_albums);
    Py_DECREF(par_albums);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_65_current_user_saved_shows(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_limit = python_pars[1];
    PyObject *par_offset = python_pars[2];
    struct Nuitka_FrameObject *frame_91fb653747c37e13f8b2d9e64801a04b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_91fb653747c37e13f8b2d9e64801a04b = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_91fb653747c37e13f8b2d9e64801a04b)) {
        Py_XDECREF(cache_frame_91fb653747c37e13f8b2d9e64801a04b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_91fb653747c37e13f8b2d9e64801a04b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_91fb653747c37e13f8b2d9e64801a04b = MAKE_FUNCTION_FRAME(codeobj_91fb653747c37e13f8b2d9e64801a04b, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_91fb653747c37e13f8b2d9e64801a04b->m_type_description == NULL);
    frame_91fb653747c37e13f8b2d9e64801a04b = cache_frame_91fb653747c37e13f8b2d9e64801a04b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_91fb653747c37e13f8b2d9e64801a04b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_91fb653747c37e13f8b2d9e64801a04b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 998;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_5ecac5642f7e480103d36531036f6532_tuple;
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_kw_name_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_2 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        frame_91fb653747c37e13f8b2d9e64801a04b->m_frame.f_lineno = 998;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 998;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_91fb653747c37e13f8b2d9e64801a04b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_91fb653747c37e13f8b2d9e64801a04b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_91fb653747c37e13f8b2d9e64801a04b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_91fb653747c37e13f8b2d9e64801a04b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_91fb653747c37e13f8b2d9e64801a04b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_91fb653747c37e13f8b2d9e64801a04b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_91fb653747c37e13f8b2d9e64801a04b,
        type_description_1,
        par_self,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_91fb653747c37e13f8b2d9e64801a04b == cache_frame_91fb653747c37e13f8b2d9e64801a04b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_91fb653747c37e13f8b2d9e64801a04b);
    }
    cache_frame_91fb653747c37e13f8b2d9e64801a04b = NULL;

    assertFrameObject(frame_91fb653747c37e13f8b2d9e64801a04b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_66_current_user_saved_shows_contains(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_shows = python_pars[1];
    PyObject *var_slist = NULL;
    PyObject *outline_0_var_s = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_f52a04d1a853156b6ca0927a29e3e304;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_f52a04d1a853156b6ca0927a29e3e304 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_f52a04d1a853156b6ca0927a29e3e304)) {
        Py_XDECREF(cache_frame_f52a04d1a853156b6ca0927a29e3e304);

#if _DEBUG_REFCOUNTS
        if (cache_frame_f52a04d1a853156b6ca0927a29e3e304 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_f52a04d1a853156b6ca0927a29e3e304 = MAKE_FUNCTION_FRAME(codeobj_f52a04d1a853156b6ca0927a29e3e304, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_f52a04d1a853156b6ca0927a29e3e304->m_type_description == NULL);
    frame_f52a04d1a853156b6ca0927a29e3e304 = cache_frame_f52a04d1a853156b6ca0927a29e3e304;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f52a04d1a853156b6ca0927a29e3e304);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f52a04d1a853156b6ca0927a29e3e304) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_shows);
            tmp_iter_arg_1 = par_shows;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1007;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2)) {
            Py_XDECREF(cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2 = MAKE_FUNCTION_FRAME(codeobj_b4e5fc01de25d83cb1f9b8c6e90e2392, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2->m_type_description == NULL);
        frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2 = cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 1007;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_s;
                outline_0_var_s = tmp_assign_source_5;
                Py_INCREF(outline_0_var_s);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_show;
            CHECK_OBJECT(outline_0_var_s);
            tmp_args_element_name_2 = outline_0_var_s;
            frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2->m_frame.f_lineno = 1007;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1007;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1007;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1007;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2,
            type_description_2,
            outline_0_var_s,
            par_self
        );


        // Release cached frame.
        if (frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2 == cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);
        }
        cache_frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2 = NULL;

        assertFrameObject(frame_b4e5fc01de25d83cb1f9b8c6e90e2392_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 1007;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_slist == NULL);
        var_slist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1008;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_069bc1a16ac92217a1a2071901af3a5a;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_slist);
        tmp_args_element_name_4 = var_slist;
        frame_f52a04d1a853156b6ca0927a29e3e304->m_frame.f_lineno = 1008;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1008;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1008;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_f52a04d1a853156b6ca0927a29e3e304->m_frame.f_lineno = 1008;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1008;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f52a04d1a853156b6ca0927a29e3e304);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f52a04d1a853156b6ca0927a29e3e304);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f52a04d1a853156b6ca0927a29e3e304);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f52a04d1a853156b6ca0927a29e3e304, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_f52a04d1a853156b6ca0927a29e3e304->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f52a04d1a853156b6ca0927a29e3e304, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_f52a04d1a853156b6ca0927a29e3e304,
        type_description_1,
        par_self,
        par_shows,
        var_slist
    );


    // Release cached frame.
    if (frame_f52a04d1a853156b6ca0927a29e3e304 == cache_frame_f52a04d1a853156b6ca0927a29e3e304) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_f52a04d1a853156b6ca0927a29e3e304);
    }
    cache_frame_f52a04d1a853156b6ca0927a29e3e304 = NULL;

    assertFrameObject(frame_f52a04d1a853156b6ca0927a29e3e304);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_slist);
    Py_DECREF(var_slist);
    var_slist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_slist);
    var_slist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_67_current_user_saved_shows_add(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_shows = python_pars[1];
    PyObject *var_slist = NULL;
    PyObject *outline_0_var_s = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_e3486177e75618a26bbf2b5cd6036d4e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_fe241e4894e4a0c9becdd4bc6600c26d_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e3486177e75618a26bbf2b5cd6036d4e = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_e3486177e75618a26bbf2b5cd6036d4e)) {
        Py_XDECREF(cache_frame_e3486177e75618a26bbf2b5cd6036d4e);

#if _DEBUG_REFCOUNTS
        if (cache_frame_e3486177e75618a26bbf2b5cd6036d4e == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_e3486177e75618a26bbf2b5cd6036d4e = MAKE_FUNCTION_FRAME(codeobj_e3486177e75618a26bbf2b5cd6036d4e, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_e3486177e75618a26bbf2b5cd6036d4e->m_type_description == NULL);
    frame_e3486177e75618a26bbf2b5cd6036d4e = cache_frame_e3486177e75618a26bbf2b5cd6036d4e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e3486177e75618a26bbf2b5cd6036d4e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e3486177e75618a26bbf2b5cd6036d4e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_shows);
            tmp_iter_arg_1 = par_shows;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1016;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2)) {
            Py_XDECREF(cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2 = MAKE_FUNCTION_FRAME(codeobj_fe241e4894e4a0c9becdd4bc6600c26d, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2->m_type_description == NULL);
        frame_fe241e4894e4a0c9becdd4bc6600c26d_2 = cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_fe241e4894e4a0c9becdd4bc6600c26d_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_fe241e4894e4a0c9becdd4bc6600c26d_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 1016;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_s;
                outline_0_var_s = tmp_assign_source_5;
                Py_INCREF(outline_0_var_s);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_show;
            CHECK_OBJECT(outline_0_var_s);
            tmp_args_element_name_2 = outline_0_var_s;
            frame_fe241e4894e4a0c9becdd4bc6600c26d_2->m_frame.f_lineno = 1016;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1016;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1016;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1016;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_fe241e4894e4a0c9becdd4bc6600c26d_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_fe241e4894e4a0c9becdd4bc6600c26d_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_fe241e4894e4a0c9becdd4bc6600c26d_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_fe241e4894e4a0c9becdd4bc6600c26d_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_fe241e4894e4a0c9becdd4bc6600c26d_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_fe241e4894e4a0c9becdd4bc6600c26d_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_fe241e4894e4a0c9becdd4bc6600c26d_2,
            type_description_2,
            outline_0_var_s,
            par_self
        );


        // Release cached frame.
        if (frame_fe241e4894e4a0c9becdd4bc6600c26d_2 == cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_fe241e4894e4a0c9becdd4bc6600c26d_2);
        }
        cache_frame_fe241e4894e4a0c9becdd4bc6600c26d_2 = NULL;

        assertFrameObject(frame_fe241e4894e4a0c9becdd4bc6600c26d_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 1016;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_slist == NULL);
        var_slist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1017;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_8778ffeefebf38a1b121e70d438be59e;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_slist);
        tmp_args_element_name_4 = var_slist;
        frame_e3486177e75618a26bbf2b5cd6036d4e->m_frame.f_lineno = 1017;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1017;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1017;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_e3486177e75618a26bbf2b5cd6036d4e->m_frame.f_lineno = 1017;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1017;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3486177e75618a26bbf2b5cd6036d4e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3486177e75618a26bbf2b5cd6036d4e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3486177e75618a26bbf2b5cd6036d4e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e3486177e75618a26bbf2b5cd6036d4e, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_e3486177e75618a26bbf2b5cd6036d4e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e3486177e75618a26bbf2b5cd6036d4e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_e3486177e75618a26bbf2b5cd6036d4e,
        type_description_1,
        par_self,
        par_shows,
        var_slist
    );


    // Release cached frame.
    if (frame_e3486177e75618a26bbf2b5cd6036d4e == cache_frame_e3486177e75618a26bbf2b5cd6036d4e) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_e3486177e75618a26bbf2b5cd6036d4e);
    }
    cache_frame_e3486177e75618a26bbf2b5cd6036d4e = NULL;

    assertFrameObject(frame_e3486177e75618a26bbf2b5cd6036d4e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_slist);
    Py_DECREF(var_slist);
    var_slist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_slist);
    var_slist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_68_current_user_saved_shows_delete(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_shows = python_pars[1];
    PyObject *var_slist = NULL;
    PyObject *outline_0_var_s = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_eb56fe42c9d4a9e33251b43172c33420;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_2e404164e29148f30f48039278898bad_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    int tmp_res;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_2e404164e29148f30f48039278898bad_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_eb56fe42c9d4a9e33251b43172c33420 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_eb56fe42c9d4a9e33251b43172c33420)) {
        Py_XDECREF(cache_frame_eb56fe42c9d4a9e33251b43172c33420);

#if _DEBUG_REFCOUNTS
        if (cache_frame_eb56fe42c9d4a9e33251b43172c33420 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_eb56fe42c9d4a9e33251b43172c33420 = MAKE_FUNCTION_FRAME(codeobj_eb56fe42c9d4a9e33251b43172c33420, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_eb56fe42c9d4a9e33251b43172c33420->m_type_description == NULL);
    frame_eb56fe42c9d4a9e33251b43172c33420 = cache_frame_eb56fe42c9d4a9e33251b43172c33420;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_eb56fe42c9d4a9e33251b43172c33420);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_eb56fe42c9d4a9e33251b43172c33420) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_shows);
            tmp_iter_arg_1 = par_shows;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1026;
                type_description_1 = "ooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_2e404164e29148f30f48039278898bad_2)) {
            Py_XDECREF(cache_frame_2e404164e29148f30f48039278898bad_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_2e404164e29148f30f48039278898bad_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_2e404164e29148f30f48039278898bad_2 = MAKE_FUNCTION_FRAME(codeobj_2e404164e29148f30f48039278898bad, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_2e404164e29148f30f48039278898bad_2->m_type_description == NULL);
        frame_2e404164e29148f30f48039278898bad_2 = cache_frame_2e404164e29148f30f48039278898bad_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_2e404164e29148f30f48039278898bad_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_2e404164e29148f30f48039278898bad_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 1026;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_s;
                outline_0_var_s = tmp_assign_source_5;
                Py_INCREF(outline_0_var_s);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_args_element_name_2;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_1 = const_str_plain_show;
            CHECK_OBJECT(outline_0_var_s);
            tmp_args_element_name_2 = outline_0_var_s;
            frame_2e404164e29148f30f48039278898bad_2->m_frame.f_lineno = 1026;
            {
                PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1026;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1026;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1026;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2e404164e29148f30f48039278898bad_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_2e404164e29148f30f48039278898bad_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_2e404164e29148f30f48039278898bad_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_2e404164e29148f30f48039278898bad_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_2e404164e29148f30f48039278898bad_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_2e404164e29148f30f48039278898bad_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_2e404164e29148f30f48039278898bad_2,
            type_description_2,
            outline_0_var_s,
            par_self
        );


        // Release cached frame.
        if (frame_2e404164e29148f30f48039278898bad_2 == cache_frame_2e404164e29148f30f48039278898bad_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_2e404164e29148f30f48039278898bad_2);
        }
        cache_frame_2e404164e29148f30f48039278898bad_2 = NULL;

        assertFrameObject(frame_2e404164e29148f30f48039278898bad_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_s);
        outline_0_var_s = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 1026;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_slist == NULL);
        var_slist = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1027;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_6b8ace3f84c15e9c2104ecbe7cae2585;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(var_slist);
        tmp_args_element_name_4 = var_slist;
        frame_eb56fe42c9d4a9e33251b43172c33420->m_frame.f_lineno = 1027;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1027;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1027;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_eb56fe42c9d4a9e33251b43172c33420->m_frame.f_lineno = 1027;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1027;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb56fe42c9d4a9e33251b43172c33420);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb56fe42c9d4a9e33251b43172c33420);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_eb56fe42c9d4a9e33251b43172c33420);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_eb56fe42c9d4a9e33251b43172c33420, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_eb56fe42c9d4a9e33251b43172c33420->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_eb56fe42c9d4a9e33251b43172c33420, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_eb56fe42c9d4a9e33251b43172c33420,
        type_description_1,
        par_self,
        par_shows,
        var_slist
    );


    // Release cached frame.
    if (frame_eb56fe42c9d4a9e33251b43172c33420 == cache_frame_eb56fe42c9d4a9e33251b43172c33420) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_eb56fe42c9d4a9e33251b43172c33420);
    }
    cache_frame_eb56fe42c9d4a9e33251b43172c33420 = NULL;

    assertFrameObject(frame_eb56fe42c9d4a9e33251b43172c33420);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_slist);
    Py_DECREF(var_slist);
    var_slist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_slist);
    var_slist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_shows);
    Py_DECREF(par_shows);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_69_user_follow_artists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_ids = python_pars[1];
    struct Nuitka_FrameObject *frame_2ae85457f5c0b77074e133a648deb12f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_2ae85457f5c0b77074e133a648deb12f = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_2ae85457f5c0b77074e133a648deb12f)) {
        Py_XDECREF(cache_frame_2ae85457f5c0b77074e133a648deb12f);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2ae85457f5c0b77074e133a648deb12f == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2ae85457f5c0b77074e133a648deb12f = MAKE_FUNCTION_FRAME(codeobj_2ae85457f5c0b77074e133a648deb12f, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2ae85457f5c0b77074e133a648deb12f->m_type_description == NULL);
    frame_2ae85457f5c0b77074e133a648deb12f = cache_frame_2ae85457f5c0b77074e133a648deb12f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2ae85457f5c0b77074e133a648deb12f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2ae85457f5c0b77074e133a648deb12f) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1034;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_967a403b50fcd58b05904c6eb0b02666;
        tmp_called_instance_1 = const_str_chr_44;
        CHECK_OBJECT(par_ids);
        tmp_args_element_name_2 = par_ids;
        frame_2ae85457f5c0b77074e133a648deb12f->m_frame.f_lineno = 1034;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1034;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1034;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_2ae85457f5c0b77074e133a648deb12f->m_frame.f_lineno = 1034;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1034;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ae85457f5c0b77074e133a648deb12f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ae85457f5c0b77074e133a648deb12f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2ae85457f5c0b77074e133a648deb12f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2ae85457f5c0b77074e133a648deb12f, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2ae85457f5c0b77074e133a648deb12f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2ae85457f5c0b77074e133a648deb12f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2ae85457f5c0b77074e133a648deb12f,
        type_description_1,
        par_self,
        par_ids
    );


    // Release cached frame.
    if (frame_2ae85457f5c0b77074e133a648deb12f == cache_frame_2ae85457f5c0b77074e133a648deb12f) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2ae85457f5c0b77074e133a648deb12f);
    }
    cache_frame_2ae85457f5c0b77074e133a648deb12f = NULL;

    assertFrameObject(frame_2ae85457f5c0b77074e133a648deb12f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_70_user_follow_users(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_ids = python_pars[1];
    struct Nuitka_FrameObject *frame_aca315e566868c59fcac8a4c130784fa;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_aca315e566868c59fcac8a4c130784fa = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_aca315e566868c59fcac8a4c130784fa)) {
        Py_XDECREF(cache_frame_aca315e566868c59fcac8a4c130784fa);

#if _DEBUG_REFCOUNTS
        if (cache_frame_aca315e566868c59fcac8a4c130784fa == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_aca315e566868c59fcac8a4c130784fa = MAKE_FUNCTION_FRAME(codeobj_aca315e566868c59fcac8a4c130784fa, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_aca315e566868c59fcac8a4c130784fa->m_type_description == NULL);
    frame_aca315e566868c59fcac8a4c130784fa = cache_frame_aca315e566868c59fcac8a4c130784fa;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_aca315e566868c59fcac8a4c130784fa);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_aca315e566868c59fcac8a4c130784fa) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1041;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_709f5323a138435d167ad8ffaa8e9e75;
        tmp_called_instance_1 = const_str_chr_44;
        CHECK_OBJECT(par_ids);
        tmp_args_element_name_2 = par_ids;
        frame_aca315e566868c59fcac8a4c130784fa->m_frame.f_lineno = 1041;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1041;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1041;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_aca315e566868c59fcac8a4c130784fa->m_frame.f_lineno = 1041;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1041;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aca315e566868c59fcac8a4c130784fa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_aca315e566868c59fcac8a4c130784fa);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_aca315e566868c59fcac8a4c130784fa);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_aca315e566868c59fcac8a4c130784fa, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_aca315e566868c59fcac8a4c130784fa->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_aca315e566868c59fcac8a4c130784fa, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_aca315e566868c59fcac8a4c130784fa,
        type_description_1,
        par_self,
        par_ids
    );


    // Release cached frame.
    if (frame_aca315e566868c59fcac8a4c130784fa == cache_frame_aca315e566868c59fcac8a4c130784fa) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_aca315e566868c59fcac8a4c130784fa);
    }
    cache_frame_aca315e566868c59fcac8a4c130784fa = NULL;

    assertFrameObject(frame_aca315e566868c59fcac8a4c130784fa);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_71_user_unfollow_artists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_ids = python_pars[1];
    struct Nuitka_FrameObject *frame_195f6802c28d1d62bcec0d77580932c9;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_195f6802c28d1d62bcec0d77580932c9 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_195f6802c28d1d62bcec0d77580932c9)) {
        Py_XDECREF(cache_frame_195f6802c28d1d62bcec0d77580932c9);

#if _DEBUG_REFCOUNTS
        if (cache_frame_195f6802c28d1d62bcec0d77580932c9 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_195f6802c28d1d62bcec0d77580932c9 = MAKE_FUNCTION_FRAME(codeobj_195f6802c28d1d62bcec0d77580932c9, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_195f6802c28d1d62bcec0d77580932c9->m_type_description == NULL);
    frame_195f6802c28d1d62bcec0d77580932c9 = cache_frame_195f6802c28d1d62bcec0d77580932c9;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_195f6802c28d1d62bcec0d77580932c9);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_195f6802c28d1d62bcec0d77580932c9) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_967a403b50fcd58b05904c6eb0b02666;
        tmp_called_instance_1 = const_str_chr_44;
        CHECK_OBJECT(par_ids);
        tmp_args_element_name_2 = par_ids;
        frame_195f6802c28d1d62bcec0d77580932c9->m_frame.f_lineno = 1048;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1048;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1048;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_195f6802c28d1d62bcec0d77580932c9->m_frame.f_lineno = 1048;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1048;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_195f6802c28d1d62bcec0d77580932c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_195f6802c28d1d62bcec0d77580932c9);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_195f6802c28d1d62bcec0d77580932c9);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_195f6802c28d1d62bcec0d77580932c9, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_195f6802c28d1d62bcec0d77580932c9->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_195f6802c28d1d62bcec0d77580932c9, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_195f6802c28d1d62bcec0d77580932c9,
        type_description_1,
        par_self,
        par_ids
    );


    // Release cached frame.
    if (frame_195f6802c28d1d62bcec0d77580932c9 == cache_frame_195f6802c28d1d62bcec0d77580932c9) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_195f6802c28d1d62bcec0d77580932c9);
    }
    cache_frame_195f6802c28d1d62bcec0d77580932c9 = NULL;

    assertFrameObject(frame_195f6802c28d1d62bcec0d77580932c9);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_72_user_unfollow_users(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_ids = python_pars[1];
    struct Nuitka_FrameObject *frame_6d428aa80f9c6f7f05fa23513004f374;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_6d428aa80f9c6f7f05fa23513004f374 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_6d428aa80f9c6f7f05fa23513004f374)) {
        Py_XDECREF(cache_frame_6d428aa80f9c6f7f05fa23513004f374);

#if _DEBUG_REFCOUNTS
        if (cache_frame_6d428aa80f9c6f7f05fa23513004f374 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_6d428aa80f9c6f7f05fa23513004f374 = MAKE_FUNCTION_FRAME(codeobj_6d428aa80f9c6f7f05fa23513004f374, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_6d428aa80f9c6f7f05fa23513004f374->m_type_description == NULL);
    frame_6d428aa80f9c6f7f05fa23513004f374 = cache_frame_6d428aa80f9c6f7f05fa23513004f374;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_6d428aa80f9c6f7f05fa23513004f374);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_6d428aa80f9c6f7f05fa23513004f374) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__delete);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1055;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_709f5323a138435d167ad8ffaa8e9e75;
        tmp_called_instance_1 = const_str_chr_44;
        CHECK_OBJECT(par_ids);
        tmp_args_element_name_2 = par_ids;
        frame_6d428aa80f9c6f7f05fa23513004f374->m_frame.f_lineno = 1055;
        {
            PyObject *call_args[] = {tmp_args_element_name_2};
            tmp_right_name_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_join, call_args);
        }

        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1055;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1055;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_6d428aa80f9c6f7f05fa23513004f374->m_frame.f_lineno = 1055;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1055;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6d428aa80f9c6f7f05fa23513004f374);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_6d428aa80f9c6f7f05fa23513004f374);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_6d428aa80f9c6f7f05fa23513004f374);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_6d428aa80f9c6f7f05fa23513004f374, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_6d428aa80f9c6f7f05fa23513004f374->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_6d428aa80f9c6f7f05fa23513004f374, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_6d428aa80f9c6f7f05fa23513004f374,
        type_description_1,
        par_self,
        par_ids
    );


    // Release cached frame.
    if (frame_6d428aa80f9c6f7f05fa23513004f374 == cache_frame_6d428aa80f9c6f7f05fa23513004f374) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_6d428aa80f9c6f7f05fa23513004f374);
    }
    cache_frame_6d428aa80f9c6f7f05fa23513004f374 = NULL;

    assertFrameObject(frame_6d428aa80f9c6f7f05fa23513004f374);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_ids);
    Py_DECREF(par_ids);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_73_featured_playlists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_locale = python_pars[1];
    PyObject *par_country = python_pars[2];
    PyObject *par_timestamp = python_pars[3];
    PyObject *par_limit = python_pars[4];
    PyObject *par_offset = python_pars[5];
    struct Nuitka_FrameObject *frame_32675116669130ce76980bf99d864bad;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_32675116669130ce76980bf99d864bad = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_32675116669130ce76980bf99d864bad)) {
        Py_XDECREF(cache_frame_32675116669130ce76980bf99d864bad);

#if _DEBUG_REFCOUNTS
        if (cache_frame_32675116669130ce76980bf99d864bad == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_32675116669130ce76980bf99d864bad = MAKE_FUNCTION_FRAME(codeobj_32675116669130ce76980bf99d864bad, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_32675116669130ce76980bf99d864bad->m_type_description == NULL);
    frame_32675116669130ce76980bf99d864bad = cache_frame_32675116669130ce76980bf99d864bad;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_32675116669130ce76980bf99d864bad);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_32675116669130ce76980bf99d864bad) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        PyObject *tmp_dict_key_5;
        PyObject *tmp_dict_value_5;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1081;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_5090487500dd71ff8ac64eb8e9322d70_tuple;
        tmp_dict_key_1 = const_str_plain_locale;
        CHECK_OBJECT(par_locale);
        tmp_dict_value_1 = par_locale;
        tmp_kw_name_1 = _PyDict_NewPresized( 5 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_country;
        CHECK_OBJECT(par_country);
        tmp_dict_value_2 = par_country;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_timestamp;
        CHECK_OBJECT(par_timestamp);
        tmp_dict_value_3 = par_timestamp;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_4 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        tmp_dict_key_5 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_5 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_5, tmp_dict_value_5);
        assert(!(tmp_res != 0));
        frame_32675116669130ce76980bf99d864bad->m_frame.f_lineno = 1081;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1081;
            type_description_1 = "oooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_32675116669130ce76980bf99d864bad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_32675116669130ce76980bf99d864bad);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_32675116669130ce76980bf99d864bad);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_32675116669130ce76980bf99d864bad, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_32675116669130ce76980bf99d864bad->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_32675116669130ce76980bf99d864bad, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_32675116669130ce76980bf99d864bad,
        type_description_1,
        par_self,
        par_locale,
        par_country,
        par_timestamp,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_32675116669130ce76980bf99d864bad == cache_frame_32675116669130ce76980bf99d864bad) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_32675116669130ce76980bf99d864bad);
    }
    cache_frame_32675116669130ce76980bf99d864bad = NULL;

    assertFrameObject(frame_32675116669130ce76980bf99d864bad);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_locale);
    Py_DECREF(par_locale);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_timestamp);
    Py_DECREF(par_timestamp);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_locale);
    Py_DECREF(par_locale);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_timestamp);
    Py_DECREF(par_timestamp);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_74_new_releases(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_country = python_pars[1];
    PyObject *par_limit = python_pars[2];
    PyObject *par_offset = python_pars[3];
    struct Nuitka_FrameObject *frame_8056a8f22b2faed7ea2b76e6f43dd588;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_8056a8f22b2faed7ea2b76e6f43dd588 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_8056a8f22b2faed7ea2b76e6f43dd588)) {
        Py_XDECREF(cache_frame_8056a8f22b2faed7ea2b76e6f43dd588);

#if _DEBUG_REFCOUNTS
        if (cache_frame_8056a8f22b2faed7ea2b76e6f43dd588 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_8056a8f22b2faed7ea2b76e6f43dd588 = MAKE_FUNCTION_FRAME(codeobj_8056a8f22b2faed7ea2b76e6f43dd588, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_8056a8f22b2faed7ea2b76e6f43dd588->m_type_description == NULL);
    frame_8056a8f22b2faed7ea2b76e6f43dd588 = cache_frame_8056a8f22b2faed7ea2b76e6f43dd588;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_8056a8f22b2faed7ea2b76e6f43dd588);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_8056a8f22b2faed7ea2b76e6f43dd588) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1103;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_6c9e8a9e157453a28103d4c0f15c86e1_tuple;
        tmp_dict_key_1 = const_str_plain_country;
        CHECK_OBJECT(par_country);
        tmp_dict_value_1 = par_country;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_2 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_3 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_8056a8f22b2faed7ea2b76e6f43dd588->m_frame.f_lineno = 1103;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1103;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8056a8f22b2faed7ea2b76e6f43dd588);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_8056a8f22b2faed7ea2b76e6f43dd588);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_8056a8f22b2faed7ea2b76e6f43dd588);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_8056a8f22b2faed7ea2b76e6f43dd588, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_8056a8f22b2faed7ea2b76e6f43dd588->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_8056a8f22b2faed7ea2b76e6f43dd588, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_8056a8f22b2faed7ea2b76e6f43dd588,
        type_description_1,
        par_self,
        par_country,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_8056a8f22b2faed7ea2b76e6f43dd588 == cache_frame_8056a8f22b2faed7ea2b76e6f43dd588) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_8056a8f22b2faed7ea2b76e6f43dd588);
    }
    cache_frame_8056a8f22b2faed7ea2b76e6f43dd588 = NULL;

    assertFrameObject(frame_8056a8f22b2faed7ea2b76e6f43dd588);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_75_categories(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_country = python_pars[1];
    PyObject *par_locale = python_pars[2];
    PyObject *par_limit = python_pars[3];
    PyObject *par_offset = python_pars[4];
    struct Nuitka_FrameObject *frame_2831de19996274756f58b6426de83d52;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_2831de19996274756f58b6426de83d52 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_2831de19996274756f58b6426de83d52)) {
        Py_XDECREF(cache_frame_2831de19996274756f58b6426de83d52);

#if _DEBUG_REFCOUNTS
        if (cache_frame_2831de19996274756f58b6426de83d52 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_2831de19996274756f58b6426de83d52 = MAKE_FUNCTION_FRAME(codeobj_2831de19996274756f58b6426de83d52, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_2831de19996274756f58b6426de83d52->m_type_description == NULL);
    frame_2831de19996274756f58b6426de83d52 = cache_frame_2831de19996274756f58b6426de83d52;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_2831de19996274756f58b6426de83d52);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_2831de19996274756f58b6426de83d52) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        PyObject *tmp_dict_key_4;
        PyObject *tmp_dict_value_4;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1123;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_7b254f67abe140a54f1f6bb0fc0ef8a9_tuple;
        tmp_dict_key_1 = const_str_plain_country;
        CHECK_OBJECT(par_country);
        tmp_dict_value_1 = par_country;
        tmp_kw_name_1 = _PyDict_NewPresized( 4 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_locale;
        CHECK_OBJECT(par_locale);
        tmp_dict_value_2 = par_locale;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_3 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        tmp_dict_key_4 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_4 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_4, tmp_dict_value_4);
        assert(!(tmp_res != 0));
        frame_2831de19996274756f58b6426de83d52->m_frame.f_lineno = 1123;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1123;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2831de19996274756f58b6426de83d52);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_2831de19996274756f58b6426de83d52);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_2831de19996274756f58b6426de83d52);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_2831de19996274756f58b6426de83d52, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_2831de19996274756f58b6426de83d52->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_2831de19996274756f58b6426de83d52, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_2831de19996274756f58b6426de83d52,
        type_description_1,
        par_self,
        par_country,
        par_locale,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_2831de19996274756f58b6426de83d52 == cache_frame_2831de19996274756f58b6426de83d52) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_2831de19996274756f58b6426de83d52);
    }
    cache_frame_2831de19996274756f58b6426de83d52 = NULL;

    assertFrameObject(frame_2831de19996274756f58b6426de83d52);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_locale);
    Py_DECREF(par_locale);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_locale);
    Py_DECREF(par_locale);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_76_category_playlists(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_category_id = python_pars[1];
    PyObject *par_country = python_pars[2];
    PyObject *par_limit = python_pars[3];
    PyObject *par_offset = python_pars[4];
    struct Nuitka_FrameObject *frame_147fb4f7b72cbe42d6cc16a449aa37f2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2)) {
        Py_XDECREF(cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2);

#if _DEBUG_REFCOUNTS
        if (cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2 = MAKE_FUNCTION_FRAME(codeobj_147fb4f7b72cbe42d6cc16a449aa37f2, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2->m_type_description == NULL);
    frame_147fb4f7b72cbe42d6cc16a449aa37f2 = cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_147fb4f7b72cbe42d6cc16a449aa37f2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_147fb4f7b72cbe42d6cc16a449aa37f2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1148;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_0a31963364057b0f70b283146476706a;
        CHECK_OBJECT(par_category_id);
        tmp_right_name_1 = par_category_id;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_1);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1149;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_digest_7ec0c6fc74111291c6117e275b9af9e9;
        tmp_tuple_element_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_1, tmp_right_name_2);
        Py_DECREF(tmp_left_name_1);
        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1149;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_country;
        CHECK_OBJECT(par_country);
        tmp_dict_value_1 = par_country;
        tmp_kw_name_1 = _PyDict_NewPresized( 3 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_2 = par_limit;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        tmp_dict_key_3 = const_str_plain_offset;
        CHECK_OBJECT(par_offset);
        tmp_dict_value_3 = par_offset;
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_147fb4f7b72cbe42d6cc16a449aa37f2->m_frame.f_lineno = 1148;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1148;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_147fb4f7b72cbe42d6cc16a449aa37f2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_147fb4f7b72cbe42d6cc16a449aa37f2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_147fb4f7b72cbe42d6cc16a449aa37f2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_147fb4f7b72cbe42d6cc16a449aa37f2, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_147fb4f7b72cbe42d6cc16a449aa37f2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_147fb4f7b72cbe42d6cc16a449aa37f2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_147fb4f7b72cbe42d6cc16a449aa37f2,
        type_description_1,
        par_self,
        par_category_id,
        par_country,
        par_limit,
        par_offset
    );


    // Release cached frame.
    if (frame_147fb4f7b72cbe42d6cc16a449aa37f2 == cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_147fb4f7b72cbe42d6cc16a449aa37f2);
    }
    cache_frame_147fb4f7b72cbe42d6cc16a449aa37f2 = NULL;

    assertFrameObject(frame_147fb4f7b72cbe42d6cc16a449aa37f2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_category_id);
    Py_DECREF(par_category_id);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_category_id);
    Py_DECREF(par_category_id);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_77_recommendations(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_seed_artists = python_pars[1];
    PyObject *par_seed_genres = python_pars[2];
    PyObject *par_seed_tracks = python_pars[3];
    PyObject *par_limit = python_pars[4];
    PyObject *par_country = python_pars[5];
    PyObject *par_kwargs = python_pars[6];
    PyObject *var_params = NULL;
    PyObject *var_attribute = NULL;
    PyObject *var_prefix = NULL;
    PyObject *var_param = NULL;
    PyObject *outline_0_var_a = NULL;
    PyObject *outline_1_var_t = NULL;
    PyObject *tmp_for_loop_1__for_iterator = NULL;
    PyObject *tmp_for_loop_1__iter_value = NULL;
    PyObject *tmp_for_loop_2__for_iterator = NULL;
    PyObject *tmp_for_loop_2__iter_value = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    PyObject *tmp_listcomp_2__$0 = NULL;
    PyObject *tmp_listcomp_2__contraction = NULL;
    PyObject *tmp_listcomp_2__iter_value_0 = NULL;
    int tmp_res;
    struct Nuitka_FrameObject *frame_89b4b5423ea0ab4a62a22ab266feaff6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_ff403a14643d9f44c988823fbe0ecdaf_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    struct Nuitka_FrameObject *frame_a73a4c372e34cc67c4020017d925c212_3;
    NUITKA_MAY_BE_UNUSED char const *type_description_3 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;
    static struct Nuitka_FrameObject *cache_frame_a73a4c372e34cc67c4020017d925c212_3 = NULL;
    PyObject *exception_keeper_type_4;
    PyObject *exception_keeper_value_4;
    PyTracebackObject *exception_keeper_tb_4;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_4;
    PyObject *exception_keeper_type_5;
    PyObject *exception_keeper_value_5;
    PyTracebackObject *exception_keeper_tb_5;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_5;
    PyObject *exception_keeper_type_6;
    PyObject *exception_keeper_value_6;
    PyTracebackObject *exception_keeper_tb_6;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_6;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_89b4b5423ea0ab4a62a22ab266feaff6 = NULL;
    PyObject *exception_keeper_type_7;
    PyObject *exception_keeper_value_7;
    PyTracebackObject *exception_keeper_tb_7;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_7;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        tmp_dict_key_1 = const_str_plain_limit;
        CHECK_OBJECT(par_limit);
        tmp_dict_value_1 = par_limit;
        tmp_assign_source_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        assert(var_params == NULL);
        var_params = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_89b4b5423ea0ab4a62a22ab266feaff6)) {
        Py_XDECREF(cache_frame_89b4b5423ea0ab4a62a22ab266feaff6);

#if _DEBUG_REFCOUNTS
        if (cache_frame_89b4b5423ea0ab4a62a22ab266feaff6 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_89b4b5423ea0ab4a62a22ab266feaff6 = MAKE_FUNCTION_FRAME(codeobj_89b4b5423ea0ab4a62a22ab266feaff6, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_89b4b5423ea0ab4a62a22ab266feaff6->m_type_description == NULL);
    frame_89b4b5423ea0ab4a62a22ab266feaff6 = cache_frame_89b4b5423ea0ab4a62a22ab266feaff6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_89b4b5423ea0ab4a62a22ab266feaff6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_89b4b5423ea0ab4a62a22ab266feaff6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_seed_artists);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_seed_artists);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1186;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        tmp_expression_name_1 = const_str_chr_44;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain_join);
        assert(!(tmp_called_name_1 == NULL));
        // Tried code:
        {
            PyObject *tmp_assign_source_2;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_seed_artists);
            tmp_iter_arg_1 = par_seed_artists;
            tmp_assign_source_2 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1188;
                type_description_1 = "ooooooooooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_2;
        }
        {
            PyObject *tmp_assign_source_3;
            tmp_assign_source_3 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_3;
        }
        if (isFrameUnusable(cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2)) {
            Py_XDECREF(cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2 = MAKE_FUNCTION_FRAME(codeobj_ff403a14643d9f44c988823fbe0ecdaf, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2->m_type_description == NULL);
        frame_ff403a14643d9f44c988823fbe0ecdaf_2 = cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_ff403a14643d9f44c988823fbe0ecdaf_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_ff403a14643d9f44c988823fbe0ecdaf_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_4;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_4 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_4 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 1188;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_4;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_5;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_5 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_a;
                outline_0_var_a = tmp_assign_source_5;
                Py_INCREF(outline_0_var_a);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_1;
            PyObject *tmp_args_element_name_2;
            PyObject *tmp_args_element_name_3;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_1 = par_self;
            tmp_args_element_name_2 = const_str_plain_artist;
            CHECK_OBJECT(outline_0_var_a);
            tmp_args_element_name_3 = outline_0_var_a;
            frame_ff403a14643d9f44c988823fbe0ecdaf_2->m_frame.f_lineno = 1188;
            {
                PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1188;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1188;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1188;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_args_element_name_1 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_args_element_name_1);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_ff403a14643d9f44c988823fbe0ecdaf_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_ff403a14643d9f44c988823fbe0ecdaf_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_ff403a14643d9f44c988823fbe0ecdaf_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_ff403a14643d9f44c988823fbe0ecdaf_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_ff403a14643d9f44c988823fbe0ecdaf_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_ff403a14643d9f44c988823fbe0ecdaf_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_ff403a14643d9f44c988823fbe0ecdaf_2,
            type_description_2,
            outline_0_var_a,
            par_self
        );


        // Release cached frame.
        if (frame_ff403a14643d9f44c988823fbe0ecdaf_2 == cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_ff403a14643d9f44c988823fbe0ecdaf_2);
        }
        cache_frame_ff403a14643d9f44c988823fbe0ecdaf_2 = NULL;

        assertFrameObject(frame_ff403a14643d9f44c988823fbe0ecdaf_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooooooooooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_a);
        outline_0_var_a = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 1188;
        goto frame_exception_exit_1;
        outline_result_1:;
        frame_89b4b5423ea0ab4a62a22ab266feaff6->m_frame.f_lineno = 1187;
        tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1187;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_params);
        tmp_dictset_dict = var_params;
        tmp_dictset_key = const_str_plain_seed_artists;
        tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
    }
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_2;
        CHECK_OBJECT(par_seed_genres);
        tmp_truth_name_2 = CHECK_IF_TRUE(par_seed_genres);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1190;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_4;
        tmp_called_instance_2 = const_str_chr_44;
        CHECK_OBJECT(par_seed_genres);
        tmp_args_element_name_4 = par_seed_genres;
        frame_89b4b5423ea0ab4a62a22ab266feaff6->m_frame.f_lineno = 1191;
        {
            PyObject *call_args[] = {tmp_args_element_name_4};
            tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_join, call_args);
        }

        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1191;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_params);
        tmp_dictset_dict = var_params;
        tmp_dictset_key = const_str_plain_seed_genres;
        tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
    }
    branch_no_2:;
    {
        nuitka_bool tmp_condition_result_3;
        int tmp_truth_name_3;
        CHECK_OBJECT(par_seed_tracks);
        tmp_truth_name_3 = CHECK_IF_TRUE(par_seed_tracks);
        if (tmp_truth_name_3 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1192;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_3 = tmp_truth_name_3 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
    }
    branch_yes_3:;
    {
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_5;
        tmp_expression_name_2 = const_str_chr_44;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_join);
        assert(!(tmp_called_name_2 == NULL));
        // Tried code:
        {
            PyObject *tmp_assign_source_6;
            PyObject *tmp_iter_arg_2;
            CHECK_OBJECT(par_seed_tracks);
            tmp_iter_arg_2 = par_seed_tracks;
            tmp_assign_source_6 = MAKE_ITERATOR(tmp_iter_arg_2);
            if (tmp_assign_source_6 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1194;
                type_description_1 = "ooooooooooo";
                goto try_except_handler_4;
            }
            assert(tmp_listcomp_2__$0 == NULL);
            tmp_listcomp_2__$0 = tmp_assign_source_6;
        }
        {
            PyObject *tmp_assign_source_7;
            tmp_assign_source_7 = PyList_New(0);
            assert(tmp_listcomp_2__contraction == NULL);
            tmp_listcomp_2__contraction = tmp_assign_source_7;
        }
        if (isFrameUnusable(cache_frame_a73a4c372e34cc67c4020017d925c212_3)) {
            Py_XDECREF(cache_frame_a73a4c372e34cc67c4020017d925c212_3);

#if _DEBUG_REFCOUNTS
            if (cache_frame_a73a4c372e34cc67c4020017d925c212_3 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_a73a4c372e34cc67c4020017d925c212_3 = MAKE_FUNCTION_FRAME(codeobj_a73a4c372e34cc67c4020017d925c212, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_a73a4c372e34cc67c4020017d925c212_3->m_type_description == NULL);
        frame_a73a4c372e34cc67c4020017d925c212_3 = cache_frame_a73a4c372e34cc67c4020017d925c212_3;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_a73a4c372e34cc67c4020017d925c212_3);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_a73a4c372e34cc67c4020017d925c212_3) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_2:;
        {
            PyObject *tmp_next_source_2;
            PyObject *tmp_assign_source_8;
            CHECK_OBJECT(tmp_listcomp_2__$0);
            tmp_next_source_2 = tmp_listcomp_2__$0;
            tmp_assign_source_8 = ITERATOR_NEXT(tmp_next_source_2);
            if (tmp_assign_source_8 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_2;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 1194;
                    goto try_except_handler_5;
                }
            }

            {
                PyObject *old = tmp_listcomp_2__iter_value_0;
                tmp_listcomp_2__iter_value_0 = tmp_assign_source_8;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_9;
            CHECK_OBJECT(tmp_listcomp_2__iter_value_0);
            tmp_assign_source_9 = tmp_listcomp_2__iter_value_0;
            {
                PyObject *old = outline_1_var_t;
                outline_1_var_t = tmp_assign_source_9;
                Py_INCREF(outline_1_var_t);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_2;
            PyObject *tmp_append_value_2;
            PyObject *tmp_called_instance_3;
            PyObject *tmp_args_element_name_6;
            PyObject *tmp_args_element_name_7;
            CHECK_OBJECT(tmp_listcomp_2__contraction);
            tmp_append_list_2 = tmp_listcomp_2__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_3 = par_self;
            tmp_args_element_name_6 = const_str_plain_track;
            CHECK_OBJECT(outline_1_var_t);
            tmp_args_element_name_7 = outline_1_var_t;
            frame_a73a4c372e34cc67c4020017d925c212_3->m_frame.f_lineno = 1194;
            {
                PyObject *call_args[] = {tmp_args_element_name_6, tmp_args_element_name_7};
                tmp_append_value_2 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1194;
                type_description_2 = "oo";
                goto try_except_handler_5;
            }
            assert(PyList_Check(tmp_append_list_2));
            tmp_res = PyList_Append(tmp_append_list_2, tmp_append_value_2);
            Py_DECREF(tmp_append_value_2);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1194;
                type_description_2 = "oo";
                goto try_except_handler_5;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1194;
            type_description_2 = "oo";
            goto try_except_handler_5;
        }
        goto loop_start_2;
        loop_end_2:;
        CHECK_OBJECT(tmp_listcomp_2__contraction);
        tmp_args_element_name_5 = tmp_listcomp_2__contraction;
        Py_INCREF(tmp_args_element_name_5);
        goto try_return_handler_5;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_5:;
        CHECK_OBJECT(tmp_listcomp_2__$0);
        Py_DECREF(tmp_listcomp_2__$0);
        tmp_listcomp_2__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_2__contraction);
        Py_DECREF(tmp_listcomp_2__contraction);
        tmp_listcomp_2__contraction = NULL;

        Py_XDECREF(tmp_listcomp_2__iter_value_0);
        tmp_listcomp_2__iter_value_0 = NULL;

        goto frame_return_exit_3;
        // Exception handler code:
        try_except_handler_5:;
        exception_keeper_type_3 = exception_type;
        exception_keeper_value_3 = exception_value;
        exception_keeper_tb_3 = exception_tb;
        exception_keeper_lineno_3 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_2__$0);
        Py_DECREF(tmp_listcomp_2__$0);
        tmp_listcomp_2__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_2__contraction);
        Py_DECREF(tmp_listcomp_2__contraction);
        tmp_listcomp_2__contraction = NULL;

        Py_XDECREF(tmp_listcomp_2__iter_value_0);
        tmp_listcomp_2__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_3;
        exception_value = exception_keeper_value_3;
        exception_tb = exception_keeper_tb_3;
        exception_lineno = exception_keeper_lineno_3;

        goto frame_exception_exit_3;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_a73a4c372e34cc67c4020017d925c212_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_2;

        frame_return_exit_3:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_a73a4c372e34cc67c4020017d925c212_3);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_4;

        frame_exception_exit_3:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_a73a4c372e34cc67c4020017d925c212_3);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_a73a4c372e34cc67c4020017d925c212_3, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_a73a4c372e34cc67c4020017d925c212_3->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_a73a4c372e34cc67c4020017d925c212_3, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_a73a4c372e34cc67c4020017d925c212_3,
            type_description_2,
            outline_1_var_t,
            par_self
        );


        // Release cached frame.
        if (frame_a73a4c372e34cc67c4020017d925c212_3 == cache_frame_a73a4c372e34cc67c4020017d925c212_3) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_a73a4c372e34cc67c4020017d925c212_3);
        }
        cache_frame_a73a4c372e34cc67c4020017d925c212_3 = NULL;

        assertFrameObject(frame_a73a4c372e34cc67c4020017d925c212_3);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_2;

        frame_no_exception_2:;
        goto skip_nested_handling_2;
        nested_frame_exit_2:;
        type_description_1 = "ooooooooooo";
        goto try_except_handler_4;
        skip_nested_handling_2:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_4:;
        Py_XDECREF(outline_1_var_t);
        outline_1_var_t = NULL;

        goto outline_result_2;
        // Exception handler code:
        try_except_handler_4:;
        exception_keeper_type_4 = exception_type;
        exception_keeper_value_4 = exception_value;
        exception_keeper_tb_4 = exception_tb;
        exception_keeper_lineno_4 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_1_var_t);
        outline_1_var_t = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_4;
        exception_value = exception_keeper_value_4;
        exception_tb = exception_keeper_tb_4;
        exception_lineno = exception_keeper_lineno_4;

        goto outline_exception_2;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_2:;
        exception_lineno = 1194;
        goto frame_exception_exit_1;
        outline_result_2:;
        frame_89b4b5423ea0ab4a62a22ab266feaff6->m_frame.f_lineno = 1193;
        tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_5);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_5);
        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1193;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(var_params);
        tmp_dictset_dict = var_params;
        tmp_dictset_key = const_str_plain_seed_tracks;
        tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        assert(!(tmp_res != 0));
    }
    branch_no_3:;
    {
        nuitka_bool tmp_condition_result_4;
        int tmp_truth_name_4;
        CHECK_OBJECT(par_country);
        tmp_truth_name_4 = CHECK_IF_TRUE(par_country);
        if (tmp_truth_name_4 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1196;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_4 = tmp_truth_name_4 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
    }
    branch_yes_4:;
    CHECK_OBJECT(par_country);
    tmp_dictset_value = par_country;
    CHECK_OBJECT(var_params);
    tmp_dictset_dict = var_params;
    tmp_dictset_key = const_str_plain_market;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_4:;
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_iter_arg_3;
        tmp_iter_arg_3 = const_tuple_dc3ebec037ca19cf156baacd2db50e46_tuple;
        tmp_assign_source_10 = MAKE_ITERATOR(tmp_iter_arg_3);
        assert(!(tmp_assign_source_10 == NULL));
        assert(tmp_for_loop_1__for_iterator == NULL);
        tmp_for_loop_1__for_iterator = tmp_assign_source_10;
    }
    // Tried code:
    loop_start_3:;
    {
        PyObject *tmp_next_source_3;
        PyObject *tmp_assign_source_11;
        CHECK_OBJECT(tmp_for_loop_1__for_iterator);
        tmp_next_source_3 = tmp_for_loop_1__for_iterator;
        tmp_assign_source_11 = ITERATOR_NEXT(tmp_next_source_3);
        if (tmp_assign_source_11 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_3;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooooo";
                exception_lineno = 1199;
                goto try_except_handler_6;
            }
        }

        {
            PyObject *old = tmp_for_loop_1__iter_value;
            tmp_for_loop_1__iter_value = tmp_assign_source_11;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_12;
        CHECK_OBJECT(tmp_for_loop_1__iter_value);
        tmp_assign_source_12 = tmp_for_loop_1__iter_value;
        {
            PyObject *old = var_attribute;
            var_attribute = tmp_assign_source_12;
            Py_INCREF(var_attribute);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_iter_arg_4;
        tmp_iter_arg_4 = const_tuple_str_plain_min__str_plain_max__str_plain_target__tuple;
        tmp_assign_source_13 = MAKE_ITERATOR(tmp_iter_arg_4);
        assert(!(tmp_assign_source_13 == NULL));
        {
            PyObject *old = tmp_for_loop_2__for_iterator;
            tmp_for_loop_2__for_iterator = tmp_assign_source_13;
            Py_XDECREF(old);
        }

    }
    // Tried code:
    loop_start_4:;
    {
        PyObject *tmp_next_source_4;
        PyObject *tmp_assign_source_14;
        CHECK_OBJECT(tmp_for_loop_2__for_iterator);
        tmp_next_source_4 = tmp_for_loop_2__for_iterator;
        tmp_assign_source_14 = ITERATOR_NEXT(tmp_next_source_4);
        if (tmp_assign_source_14 == NULL) {
            if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                goto loop_end_4;
            } else {

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                type_description_1 = "ooooooooooo";
                exception_lineno = 1215;
                goto try_except_handler_7;
            }
        }

        {
            PyObject *old = tmp_for_loop_2__iter_value;
            tmp_for_loop_2__iter_value = tmp_assign_source_14;
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_15;
        CHECK_OBJECT(tmp_for_loop_2__iter_value);
        tmp_assign_source_15 = tmp_for_loop_2__iter_value;
        {
            PyObject *old = var_prefix;
            var_prefix = tmp_assign_source_15;
            Py_INCREF(var_prefix);
            Py_XDECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(var_prefix);
        tmp_left_name_1 = var_prefix;
        CHECK_OBJECT(var_attribute);
        tmp_right_name_1 = var_attribute;
        tmp_assign_source_16 = BINARY_OPERATION_ADD_OBJECT_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_assign_source_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1216;
            type_description_1 = "ooooooooooo";
            goto try_except_handler_7;
        }
        {
            PyObject *old = var_param;
            var_param = tmp_assign_source_16;
            Py_XDECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(var_param);
        tmp_compexpr_left_1 = var_param;
        CHECK_OBJECT(par_kwargs);
        tmp_compexpr_right_1 = par_kwargs;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1217;
            type_description_1 = "ooooooooooo";
            goto try_except_handler_7;
        }
        tmp_condition_result_5 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
    }
    branch_yes_5:;
    {
        PyObject *tmp_expression_name_3;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_kwargs);
        tmp_expression_name_3 = par_kwargs;
        CHECK_OBJECT(var_param);
        tmp_subscript_name_1 = var_param;
        tmp_dictset_value = LOOKUP_SUBSCRIPT(tmp_expression_name_3, tmp_subscript_name_1);
        if (tmp_dictset_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1218;
            type_description_1 = "ooooooooooo";
            goto try_except_handler_7;
        }
        CHECK_OBJECT(var_params);
        tmp_dictset_dict = var_params;
        CHECK_OBJECT(var_param);
        tmp_dictset_key = var_param;
        tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1218;
            type_description_1 = "ooooooooooo";
            goto try_except_handler_7;
        }
    }
    branch_no_5:;
    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1215;
        type_description_1 = "ooooooooooo";
        goto try_except_handler_7;
    }
    goto loop_start_4;
    loop_end_4:;
    goto try_end_1;
    // Exception handler code:
    try_except_handler_7:;
    exception_keeper_type_5 = exception_type;
    exception_keeper_value_5 = exception_value;
    exception_keeper_tb_5 = exception_tb;
    exception_keeper_lineno_5 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_2__iter_value);
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT(tmp_for_loop_2__for_iterator);
    Py_DECREF(tmp_for_loop_2__for_iterator);
    tmp_for_loop_2__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_5;
    exception_value = exception_keeper_value_5;
    exception_tb = exception_keeper_tb_5;
    exception_lineno = exception_keeper_lineno_5;

    goto try_except_handler_6;
    // End of try:
    try_end_1:;
    Py_XDECREF(tmp_for_loop_2__iter_value);
    tmp_for_loop_2__iter_value = NULL;

    CHECK_OBJECT(tmp_for_loop_2__for_iterator);
    Py_DECREF(tmp_for_loop_2__for_iterator);
    tmp_for_loop_2__for_iterator = NULL;

    if (CONSIDER_THREADING() == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 1199;
        type_description_1 = "ooooooooooo";
        goto try_except_handler_6;
    }
    goto loop_start_3;
    loop_end_3:;
    goto try_end_2;
    // Exception handler code:
    try_except_handler_6:;
    exception_keeper_type_6 = exception_type;
    exception_keeper_value_6 = exception_value;
    exception_keeper_tb_6 = exception_tb;
    exception_keeper_lineno_6 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT(tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_6;
    exception_value = exception_keeper_value_6;
    exception_tb = exception_keeper_tb_6;
    exception_lineno = exception_keeper_lineno_6;

    goto frame_exception_exit_1;
    // End of try:
    try_end_2:;
    Py_XDECREF(tmp_for_loop_1__iter_value);
    tmp_for_loop_1__iter_value = NULL;

    CHECK_OBJECT(tmp_for_loop_1__for_iterator);
    Py_DECREF(tmp_for_loop_1__for_iterator);
    tmp_for_loop_1__for_iterator = NULL;

    {
        PyObject *tmp_dircall_arg1_1;
        PyObject *tmp_expression_name_4;
        PyObject *tmp_dircall_arg2_1;
        PyObject *tmp_dircall_arg3_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_4 = par_self;
        tmp_dircall_arg1_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_4, const_str_plain__get);
        if (tmp_dircall_arg1_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1219;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        tmp_dircall_arg2_1 = const_tuple_str_plain_recommendations_tuple;
        CHECK_OBJECT(var_params);
        tmp_dircall_arg3_1 = var_params;
        Py_INCREF(tmp_dircall_arg2_1);
        Py_INCREF(tmp_dircall_arg3_1);

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1, tmp_dircall_arg2_1, tmp_dircall_arg3_1};
            tmp_return_value = impl___internal__$$$function_9_complex_call_helper_pos_star_dict(dir_call_args);
        }
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1219;
            type_description_1 = "ooooooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_89b4b5423ea0ab4a62a22ab266feaff6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_3;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_89b4b5423ea0ab4a62a22ab266feaff6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_89b4b5423ea0ab4a62a22ab266feaff6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_89b4b5423ea0ab4a62a22ab266feaff6, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_89b4b5423ea0ab4a62a22ab266feaff6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_89b4b5423ea0ab4a62a22ab266feaff6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_89b4b5423ea0ab4a62a22ab266feaff6,
        type_description_1,
        par_self,
        par_seed_artists,
        par_seed_genres,
        par_seed_tracks,
        par_limit,
        par_country,
        par_kwargs,
        var_params,
        var_attribute,
        var_prefix,
        var_param
    );


    // Release cached frame.
    if (frame_89b4b5423ea0ab4a62a22ab266feaff6 == cache_frame_89b4b5423ea0ab4a62a22ab266feaff6) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_89b4b5423ea0ab4a62a22ab266feaff6);
    }
    cache_frame_89b4b5423ea0ab4a62a22ab266feaff6 = NULL;

    assertFrameObject(frame_89b4b5423ea0ab4a62a22ab266feaff6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_3:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_params);
    Py_DECREF(var_params);
    var_params = NULL;

    Py_XDECREF(var_attribute);
    var_attribute = NULL;

    Py_XDECREF(var_prefix);
    var_prefix = NULL;

    Py_XDECREF(var_param);
    var_param = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_7 = exception_type;
    exception_keeper_value_7 = exception_value;
    exception_keeper_tb_7 = exception_tb;
    exception_keeper_lineno_7 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT(var_params);
    Py_DECREF(var_params);
    var_params = NULL;

    Py_XDECREF(var_attribute);
    var_attribute = NULL;

    Py_XDECREF(var_prefix);
    var_prefix = NULL;

    Py_XDECREF(var_param);
    var_param = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_7;
    exception_value = exception_keeper_value_7;
    exception_tb = exception_keeper_tb_7;
    exception_lineno = exception_keeper_lineno_7;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_seed_artists);
    Py_DECREF(par_seed_artists);
    CHECK_OBJECT(par_seed_genres);
    Py_DECREF(par_seed_genres);
    CHECK_OBJECT(par_seed_tracks);
    Py_DECREF(par_seed_tracks);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_seed_artists);
    Py_DECREF(par_seed_artists);
    CHECK_OBJECT(par_seed_genres);
    Py_DECREF(par_seed_genres);
    CHECK_OBJECT(par_seed_tracks);
    Py_DECREF(par_seed_tracks);
    CHECK_OBJECT(par_limit);
    Py_DECREF(par_limit);
    CHECK_OBJECT(par_country);
    Py_DECREF(par_country);
    CHECK_OBJECT(par_kwargs);
    Py_DECREF(par_kwargs);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_78_recommendation_genre_seeds(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_efc1505ed87c663bcff91271fe296d91;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_efc1505ed87c663bcff91271fe296d91 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_efc1505ed87c663bcff91271fe296d91)) {
        Py_XDECREF(cache_frame_efc1505ed87c663bcff91271fe296d91);

#if _DEBUG_REFCOUNTS
        if (cache_frame_efc1505ed87c663bcff91271fe296d91 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_efc1505ed87c663bcff91271fe296d91 = MAKE_FUNCTION_FRAME(codeobj_efc1505ed87c663bcff91271fe296d91, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_efc1505ed87c663bcff91271fe296d91->m_type_description == NULL);
    frame_efc1505ed87c663bcff91271fe296d91 = cache_frame_efc1505ed87c663bcff91271fe296d91;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_efc1505ed87c663bcff91271fe296d91);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_efc1505ed87c663bcff91271fe296d91) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_efc1505ed87c663bcff91271fe296d91->m_frame.f_lineno = 1224;
        tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__get, &PyTuple_GET_ITEM(const_tuple_str_digest_d7c7baadbbd36aaede69325123afee60_tuple, 0));

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1224;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efc1505ed87c663bcff91271fe296d91);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_efc1505ed87c663bcff91271fe296d91);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efc1505ed87c663bcff91271fe296d91);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_efc1505ed87c663bcff91271fe296d91, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_efc1505ed87c663bcff91271fe296d91->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_efc1505ed87c663bcff91271fe296d91, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_efc1505ed87c663bcff91271fe296d91,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_efc1505ed87c663bcff91271fe296d91 == cache_frame_efc1505ed87c663bcff91271fe296d91) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_efc1505ed87c663bcff91271fe296d91);
    }
    cache_frame_efc1505ed87c663bcff91271fe296d91 = NULL;

    assertFrameObject(frame_efc1505ed87c663bcff91271fe296d91);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_79_audio_analysis(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_track_id = python_pars[1];
    PyObject *var_trid = NULL;
    struct Nuitka_FrameObject *frame_d9e89bd634fe62a085eca6d7aa03162b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_d9e89bd634fe62a085eca6d7aa03162b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_d9e89bd634fe62a085eca6d7aa03162b)) {
        Py_XDECREF(cache_frame_d9e89bd634fe62a085eca6d7aa03162b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_d9e89bd634fe62a085eca6d7aa03162b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_d9e89bd634fe62a085eca6d7aa03162b = MAKE_FUNCTION_FRAME(codeobj_d9e89bd634fe62a085eca6d7aa03162b, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_d9e89bd634fe62a085eca6d7aa03162b->m_type_description == NULL);
    frame_d9e89bd634fe62a085eca6d7aa03162b = cache_frame_d9e89bd634fe62a085eca6d7aa03162b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d9e89bd634fe62a085eca6d7aa03162b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d9e89bd634fe62a085eca6d7aa03162b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_track;
        CHECK_OBJECT(par_track_id);
        tmp_args_element_name_2 = par_track_id;
        frame_d9e89bd634fe62a085eca6d7aa03162b->m_frame.f_lineno = 1231;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1231;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        assert(var_trid == NULL);
        var_trid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1232;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_9a89b14ef9f9031019bb64544b058eba;
        CHECK_OBJECT(var_trid);
        tmp_right_name_1 = var_trid;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1232;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_d9e89bd634fe62a085eca6d7aa03162b->m_frame.f_lineno = 1232;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1232;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d9e89bd634fe62a085eca6d7aa03162b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d9e89bd634fe62a085eca6d7aa03162b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d9e89bd634fe62a085eca6d7aa03162b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d9e89bd634fe62a085eca6d7aa03162b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_d9e89bd634fe62a085eca6d7aa03162b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d9e89bd634fe62a085eca6d7aa03162b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_d9e89bd634fe62a085eca6d7aa03162b,
        type_description_1,
        par_self,
        par_track_id,
        var_trid
    );


    // Release cached frame.
    if (frame_d9e89bd634fe62a085eca6d7aa03162b == cache_frame_d9e89bd634fe62a085eca6d7aa03162b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_d9e89bd634fe62a085eca6d7aa03162b);
    }
    cache_frame_d9e89bd634fe62a085eca6d7aa03162b = NULL;

    assertFrameObject(frame_d9e89bd634fe62a085eca6d7aa03162b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_trid);
    Py_DECREF(var_trid);
    var_trid = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trid);
    var_trid = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_track_id);
    Py_DECREF(par_track_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_track_id);
    Py_DECREF(par_track_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_80_audio_features(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_tracks = python_pars[1];
    PyObject *var_trackid = NULL;
    PyObject *var_results = NULL;
    PyObject *var_tlist = NULL;
    PyObject *outline_0_var_t = NULL;
    PyObject *tmp_listcomp_1__$0 = NULL;
    PyObject *tmp_listcomp_1__contraction = NULL;
    PyObject *tmp_listcomp_1__iter_value_0 = NULL;
    struct Nuitka_FrameObject *frame_408b682245f176e23a2c4ef692a9a3d6;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    struct Nuitka_FrameObject *frame_e8e0aef170bf84feeacf8ba1c883ecbc_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    static struct Nuitka_FrameObject *cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2 = NULL;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_408b682245f176e23a2c4ef692a9a3d6 = NULL;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_408b682245f176e23a2c4ef692a9a3d6)) {
        Py_XDECREF(cache_frame_408b682245f176e23a2c4ef692a9a3d6);

#if _DEBUG_REFCOUNTS
        if (cache_frame_408b682245f176e23a2c4ef692a9a3d6 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_408b682245f176e23a2c4ef692a9a3d6 = MAKE_FUNCTION_FRAME(codeobj_408b682245f176e23a2c4ef692a9a3d6, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_408b682245f176e23a2c4ef692a9a3d6->m_type_description == NULL);
    frame_408b682245f176e23a2c4ef692a9a3d6 = cache_frame_408b682245f176e23a2c4ef692a9a3d6;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_408b682245f176e23a2c4ef692a9a3d6);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_408b682245f176e23a2c4ef692a9a3d6) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_tracks);
        tmp_isinstance_inst_1 = par_tracks;
        tmp_isinstance_cls_1 = (PyObject *)&PyUnicode_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1239;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_track;
        CHECK_OBJECT(par_tracks);
        tmp_args_element_name_2 = par_tracks;
        frame_408b682245f176e23a2c4ef692a9a3d6->m_frame.f_lineno = 1240;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1240;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_trackid == NULL);
        var_trackid = tmp_assign_source_1;
    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1241;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_f82a2299550c18805d7c9a6deebb5f8b;
        CHECK_OBJECT(var_trackid);
        tmp_right_name_1 = var_trackid;
        tmp_args_element_name_3 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1241;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_408b682245f176e23a2c4ef692a9a3d6->m_frame.f_lineno = 1241;
        tmp_assign_source_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_3);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1241;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_results == NULL);
        var_results = tmp_assign_source_2;
    }
    goto branch_end_1;
    branch_no_1:;
    {
        PyObject *tmp_assign_source_3;
        // Tried code:
        {
            PyObject *tmp_assign_source_4;
            PyObject *tmp_iter_arg_1;
            CHECK_OBJECT(par_tracks);
            tmp_iter_arg_1 = par_tracks;
            tmp_assign_source_4 = MAKE_ITERATOR(tmp_iter_arg_1);
            if (tmp_assign_source_4 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1243;
                type_description_1 = "ooooo";
                goto try_except_handler_2;
            }
            assert(tmp_listcomp_1__$0 == NULL);
            tmp_listcomp_1__$0 = tmp_assign_source_4;
        }
        {
            PyObject *tmp_assign_source_5;
            tmp_assign_source_5 = PyList_New(0);
            assert(tmp_listcomp_1__contraction == NULL);
            tmp_listcomp_1__contraction = tmp_assign_source_5;
        }
        if (isFrameUnusable(cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2)) {
            Py_XDECREF(cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2 = MAKE_FUNCTION_FRAME(codeobj_e8e0aef170bf84feeacf8ba1c883ecbc, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2->m_type_description == NULL);
        frame_e8e0aef170bf84feeacf8ba1c883ecbc_2 = cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2) == 2); // Frame stack

        // Framed code:
        // Tried code:
        loop_start_1:;
        {
            PyObject *tmp_next_source_1;
            PyObject *tmp_assign_source_6;
            CHECK_OBJECT(tmp_listcomp_1__$0);
            tmp_next_source_1 = tmp_listcomp_1__$0;
            tmp_assign_source_6 = ITERATOR_NEXT(tmp_next_source_1);
            if (tmp_assign_source_6 == NULL) {
                if (CHECK_AND_CLEAR_STOP_ITERATION_OCCURRED()) {

                    goto loop_end_1;
                } else {

                    FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                    type_description_2 = "oo";
                    exception_lineno = 1243;
                    goto try_except_handler_3;
                }
            }

            {
                PyObject *old = tmp_listcomp_1__iter_value_0;
                tmp_listcomp_1__iter_value_0 = tmp_assign_source_6;
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_assign_source_7;
            CHECK_OBJECT(tmp_listcomp_1__iter_value_0);
            tmp_assign_source_7 = tmp_listcomp_1__iter_value_0;
            {
                PyObject *old = outline_0_var_t;
                outline_0_var_t = tmp_assign_source_7;
                Py_INCREF(outline_0_var_t);
                Py_XDECREF(old);
            }

        }
        {
            PyObject *tmp_append_list_1;
            PyObject *tmp_append_value_1;
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_4;
            PyObject *tmp_args_element_name_5;
            CHECK_OBJECT(tmp_listcomp_1__contraction);
            tmp_append_list_1 = tmp_listcomp_1__contraction;
            CHECK_OBJECT(par_self);
            tmp_called_instance_2 = par_self;
            tmp_args_element_name_4 = const_str_plain_track;
            CHECK_OBJECT(outline_0_var_t);
            tmp_args_element_name_5 = outline_0_var_t;
            frame_e8e0aef170bf84feeacf8ba1c883ecbc_2->m_frame.f_lineno = 1243;
            {
                PyObject *call_args[] = {tmp_args_element_name_4, tmp_args_element_name_5};
                tmp_append_value_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_2, const_str_plain__get_id, call_args);
            }

            if (tmp_append_value_1 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1243;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
            assert(PyList_Check(tmp_append_list_1));
            tmp_res = PyList_Append(tmp_append_list_1, tmp_append_value_1);
            Py_DECREF(tmp_append_value_1);
            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1243;
                type_description_2 = "oo";
                goto try_except_handler_3;
            }
        }
        if (CONSIDER_THREADING() == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1243;
            type_description_2 = "oo";
            goto try_except_handler_3;
        }
        goto loop_start_1;
        loop_end_1:;
        CHECK_OBJECT(tmp_listcomp_1__contraction);
        tmp_assign_source_3 = tmp_listcomp_1__contraction;
        Py_INCREF(tmp_assign_source_3);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        goto frame_return_exit_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        CHECK_OBJECT(tmp_listcomp_1__$0);
        Py_DECREF(tmp_listcomp_1__$0);
        tmp_listcomp_1__$0 = NULL;

        CHECK_OBJECT(tmp_listcomp_1__contraction);
        Py_DECREF(tmp_listcomp_1__contraction);
        tmp_listcomp_1__contraction = NULL;

        Py_XDECREF(tmp_listcomp_1__iter_value_0);
        tmp_listcomp_1__iter_value_0 = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto frame_exception_exit_2;
        // End of try:

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_return_exit_2:;
#if 0
        RESTORE_FRAME_EXCEPTION(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto try_return_handler_2;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_e8e0aef170bf84feeacf8ba1c883ecbc_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_e8e0aef170bf84feeacf8ba1c883ecbc_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_e8e0aef170bf84feeacf8ba1c883ecbc_2,
            type_description_2,
            outline_0_var_t,
            par_self
        );


        // Release cached frame.
        if (frame_e8e0aef170bf84feeacf8ba1c883ecbc_2 == cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);
        }
        cache_frame_e8e0aef170bf84feeacf8ba1c883ecbc_2 = NULL;

        assertFrameObject(frame_e8e0aef170bf84feeacf8ba1c883ecbc_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;
        type_description_1 = "ooooo";
        goto try_except_handler_2;
        skip_nested_handling_1:;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_XDECREF(outline_0_var_t);
        outline_0_var_t = NULL;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 1243;
        goto frame_exception_exit_1;
        outline_result_1:;
        assert(var_tlist == NULL);
        var_tlist = tmp_assign_source_3;
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_7;
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__get);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1244;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_2 = const_str_digest_f82a2299550c18805d7c9a6deebb5f8b;
        tmp_called_instance_3 = const_str_chr_44;
        CHECK_OBJECT(var_tlist);
        tmp_args_element_name_7 = var_tlist;
        frame_408b682245f176e23a2c4ef692a9a3d6->m_frame.f_lineno = 1244;
        {
            PyObject *call_args[] = {tmp_args_element_name_7};
            tmp_right_name_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_3, const_str_plain_join, call_args);
        }

        if (tmp_right_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1244;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_6 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_2);
        Py_DECREF(tmp_right_name_2);
        if (tmp_args_element_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1244;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_408b682245f176e23a2c4ef692a9a3d6->m_frame.f_lineno = 1244;
        tmp_assign_source_8 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_6);
        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_6);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1244;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_results == NULL);
        var_results = tmp_assign_source_8;
    }
    branch_end_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = const_str_plain_audio_features;
        CHECK_OBJECT(var_results);
        tmp_compexpr_right_1 = var_results;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1247;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_expression_name_3;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(var_results);
        tmp_expression_name_3 = var_results;
        tmp_subscript_name_1 = const_str_plain_audio_features;
        tmp_return_value = LOOKUP_SUBSCRIPT(tmp_expression_name_3, tmp_subscript_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1248;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }
    goto branch_end_2;
    branch_no_2:;
    CHECK_OBJECT(var_results);
    tmp_return_value = var_results;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_end_2:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_408b682245f176e23a2c4ef692a9a3d6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_2;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_408b682245f176e23a2c4ef692a9a3d6);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_408b682245f176e23a2c4ef692a9a3d6);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_408b682245f176e23a2c4ef692a9a3d6, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_408b682245f176e23a2c4ef692a9a3d6->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_408b682245f176e23a2c4ef692a9a3d6, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_408b682245f176e23a2c4ef692a9a3d6,
        type_description_1,
        par_self,
        par_tracks,
        var_trackid,
        var_results,
        var_tlist
    );


    // Release cached frame.
    if (frame_408b682245f176e23a2c4ef692a9a3d6 == cache_frame_408b682245f176e23a2c4ef692a9a3d6) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_408b682245f176e23a2c4ef692a9a3d6);
    }
    cache_frame_408b682245f176e23a2c4ef692a9a3d6 = NULL;

    assertFrameObject(frame_408b682245f176e23a2c4ef692a9a3d6);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_2:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_trackid);
    var_trackid = NULL;

    CHECK_OBJECT(var_results);
    Py_DECREF(var_results);
    var_results = NULL;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_trackid);
    var_trackid = NULL;

    Py_XDECREF(var_results);
    var_results = NULL;

    Py_XDECREF(var_tlist);
    var_tlist = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_tracks);
    Py_DECREF(par_tracks);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_81_devices(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    struct Nuitka_FrameObject *frame_c8e859882515ed15aeb5b23f99d36210;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_c8e859882515ed15aeb5b23f99d36210 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_c8e859882515ed15aeb5b23f99d36210)) {
        Py_XDECREF(cache_frame_c8e859882515ed15aeb5b23f99d36210);

#if _DEBUG_REFCOUNTS
        if (cache_frame_c8e859882515ed15aeb5b23f99d36210 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_c8e859882515ed15aeb5b23f99d36210 = MAKE_FUNCTION_FRAME(codeobj_c8e859882515ed15aeb5b23f99d36210, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_c8e859882515ed15aeb5b23f99d36210->m_type_description == NULL);
    frame_c8e859882515ed15aeb5b23f99d36210 = cache_frame_c8e859882515ed15aeb5b23f99d36210;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_c8e859882515ed15aeb5b23f99d36210);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_c8e859882515ed15aeb5b23f99d36210) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        frame_c8e859882515ed15aeb5b23f99d36210->m_frame.f_lineno = 1255;
        tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain__get, &PyTuple_GET_ITEM(const_tuple_str_digest_6ba34161f4b1f940d6d5b6c37f996eea_tuple, 0));

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1255;
            type_description_1 = "o";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8e859882515ed15aeb5b23f99d36210);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8e859882515ed15aeb5b23f99d36210);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_c8e859882515ed15aeb5b23f99d36210);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_c8e859882515ed15aeb5b23f99d36210, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_c8e859882515ed15aeb5b23f99d36210->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_c8e859882515ed15aeb5b23f99d36210, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_c8e859882515ed15aeb5b23f99d36210,
        type_description_1,
        par_self
    );


    // Release cached frame.
    if (frame_c8e859882515ed15aeb5b23f99d36210 == cache_frame_c8e859882515ed15aeb5b23f99d36210) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_c8e859882515ed15aeb5b23f99d36210);
    }
    cache_frame_c8e859882515ed15aeb5b23f99d36210 = NULL;

    assertFrameObject(frame_c8e859882515ed15aeb5b23f99d36210);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_82_current_playback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_market = python_pars[1];
    struct Nuitka_FrameObject *frame_930beb42264bc52c118db28d3d84c5e2;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_930beb42264bc52c118db28d3d84c5e2 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_930beb42264bc52c118db28d3d84c5e2)) {
        Py_XDECREF(cache_frame_930beb42264bc52c118db28d3d84c5e2);

#if _DEBUG_REFCOUNTS
        if (cache_frame_930beb42264bc52c118db28d3d84c5e2 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_930beb42264bc52c118db28d3d84c5e2 = MAKE_FUNCTION_FRAME(codeobj_930beb42264bc52c118db28d3d84c5e2, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_930beb42264bc52c118db28d3d84c5e2->m_type_description == NULL);
    frame_930beb42264bc52c118db28d3d84c5e2 = cache_frame_930beb42264bc52c118db28d3d84c5e2;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_930beb42264bc52c118db28d3d84c5e2);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_930beb42264bc52c118db28d3d84c5e2) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1263;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_12c7255d70fc5dcdbef99c54e18933c6_tuple;
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_930beb42264bc52c118db28d3d84c5e2->m_frame.f_lineno = 1263;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1263;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_930beb42264bc52c118db28d3d84c5e2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_930beb42264bc52c118db28d3d84c5e2);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_930beb42264bc52c118db28d3d84c5e2);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_930beb42264bc52c118db28d3d84c5e2, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_930beb42264bc52c118db28d3d84c5e2->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_930beb42264bc52c118db28d3d84c5e2, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_930beb42264bc52c118db28d3d84c5e2,
        type_description_1,
        par_self,
        par_market
    );


    // Release cached frame.
    if (frame_930beb42264bc52c118db28d3d84c5e2 == cache_frame_930beb42264bc52c118db28d3d84c5e2) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_930beb42264bc52c118db28d3d84c5e2);
    }
    cache_frame_930beb42264bc52c118db28d3d84c5e2 = NULL;

    assertFrameObject(frame_930beb42264bc52c118db28d3d84c5e2);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_83_currently_playing(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_market = python_pars[1];
    struct Nuitka_FrameObject *frame_f5900a135869b2c725abedc03985587c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    static struct Nuitka_FrameObject *cache_frame_f5900a135869b2c725abedc03985587c = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_f5900a135869b2c725abedc03985587c)) {
        Py_XDECREF(cache_frame_f5900a135869b2c725abedc03985587c);

#if _DEBUG_REFCOUNTS
        if (cache_frame_f5900a135869b2c725abedc03985587c == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_f5900a135869b2c725abedc03985587c = MAKE_FUNCTION_FRAME(codeobj_f5900a135869b2c725abedc03985587c, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_f5900a135869b2c725abedc03985587c->m_type_description == NULL);
    frame_f5900a135869b2c725abedc03985587c = cache_frame_f5900a135869b2c725abedc03985587c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_f5900a135869b2c725abedc03985587c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_f5900a135869b2c725abedc03985587c) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__get);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_8921f974345d80799e10e01caa480348_tuple;
        tmp_dict_key_1 = const_str_plain_market;
        CHECK_OBJECT(par_market);
        tmp_dict_value_1 = par_market;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_f5900a135869b2c725abedc03985587c->m_frame.f_lineno = 1271;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1271;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f5900a135869b2c725abedc03985587c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_f5900a135869b2c725abedc03985587c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_f5900a135869b2c725abedc03985587c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_f5900a135869b2c725abedc03985587c, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_f5900a135869b2c725abedc03985587c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_f5900a135869b2c725abedc03985587c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_f5900a135869b2c725abedc03985587c,
        type_description_1,
        par_self,
        par_market
    );


    // Release cached frame.
    if (frame_f5900a135869b2c725abedc03985587c == cache_frame_f5900a135869b2c725abedc03985587c) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_f5900a135869b2c725abedc03985587c);
    }
    cache_frame_f5900a135869b2c725abedc03985587c = NULL;

    assertFrameObject(frame_f5900a135869b2c725abedc03985587c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_market);
    Py_DECREF(par_market);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_84_transfer_playback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_device_id = python_pars[1];
    PyObject *par_force_play = python_pars[2];
    PyObject *var_data = NULL;
    int tmp_res;
    struct Nuitka_FrameObject *frame_fbf262121f91f3804d33b3044803566e;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_fbf262121f91f3804d33b3044803566e = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        PyObject *tmp_list_element_1;
        PyObject *tmp_dict_key_2;
        PyObject *tmp_dict_value_2;
        tmp_dict_key_1 = const_str_plain_device_ids;
        CHECK_OBJECT(par_device_id);
        tmp_list_element_1 = par_device_id;
        tmp_dict_value_1 = PyList_New(1);
        Py_INCREF(tmp_list_element_1);
        PyList_SET_ITEM(tmp_dict_value_1, 0, tmp_list_element_1);
        tmp_assign_source_1 = _PyDict_NewPresized( 2 );
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_1, tmp_dict_value_1);
        Py_DECREF(tmp_dict_value_1);
        assert(!(tmp_res != 0));
        tmp_dict_key_2 = const_str_plain_play;
        CHECK_OBJECT(par_force_play);
        tmp_dict_value_2 = par_force_play;
        tmp_res = PyDict_SetItem(tmp_assign_source_1, tmp_dict_key_2, tmp_dict_value_2);
        assert(!(tmp_res != 0));
        assert(var_data == NULL);
        var_data = tmp_assign_source_1;
    }
    // Tried code:
    if (isFrameUnusable(cache_frame_fbf262121f91f3804d33b3044803566e)) {
        Py_XDECREF(cache_frame_fbf262121f91f3804d33b3044803566e);

#if _DEBUG_REFCOUNTS
        if (cache_frame_fbf262121f91f3804d33b3044803566e == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_fbf262121f91f3804d33b3044803566e = MAKE_FUNCTION_FRAME(codeobj_fbf262121f91f3804d33b3044803566e, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_fbf262121f91f3804d33b3044803566e->m_type_description == NULL);
    frame_fbf262121f91f3804d33b3044803566e = cache_frame_fbf262121f91f3804d33b3044803566e;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_fbf262121f91f3804d33b3044803566e);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_fbf262121f91f3804d33b3044803566e) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_3;
        PyObject *tmp_dict_value_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1284;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = const_tuple_str_digest_12c7255d70fc5dcdbef99c54e18933c6_tuple;
        tmp_dict_key_3 = const_str_plain_payload;
        CHECK_OBJECT(var_data);
        tmp_dict_value_3 = var_data;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_3, tmp_dict_value_3);
        assert(!(tmp_res != 0));
        frame_fbf262121f91f3804d33b3044803566e->m_frame.f_lineno = 1284;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1284;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbf262121f91f3804d33b3044803566e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbf262121f91f3804d33b3044803566e);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_fbf262121f91f3804d33b3044803566e);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_fbf262121f91f3804d33b3044803566e, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_fbf262121f91f3804d33b3044803566e->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_fbf262121f91f3804d33b3044803566e, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_fbf262121f91f3804d33b3044803566e,
        type_description_1,
        par_self,
        par_device_id,
        par_force_play,
        var_data
    );


    // Release cached frame.
    if (frame_fbf262121f91f3804d33b3044803566e == cache_frame_fbf262121f91f3804d33b3044803566e) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_fbf262121f91f3804d33b3044803566e);
    }
    cache_frame_fbf262121f91f3804d33b3044803566e = NULL;

    assertFrameObject(frame_fbf262121f91f3804d33b3044803566e);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT(var_data);
    Py_DECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);
    CHECK_OBJECT(par_force_play);
    Py_DECREF(par_force_play);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);
    CHECK_OBJECT(par_force_play);
    Py_DECREF(par_force_play);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_85_start_playback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_device_id = python_pars[1];
    PyObject *par_context_uri = python_pars[2];
    PyObject *par_uris = python_pars[3];
    PyObject *par_offset = python_pars[4];
    PyObject *par_position_ms = python_pars[5];
    PyObject *var_data = NULL;
    struct Nuitka_FrameObject *frame_d05adab5b849556bfc3129c4f25b24f3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    PyObject *tmp_return_value = NULL;
    int tmp_res;
    PyObject *tmp_dictset_value;
    PyObject *tmp_dictset_dict;
    PyObject *tmp_dictset_key;
    static struct Nuitka_FrameObject *cache_frame_d05adab5b849556bfc3129c4f25b24f3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_d05adab5b849556bfc3129c4f25b24f3)) {
        Py_XDECREF(cache_frame_d05adab5b849556bfc3129c4f25b24f3);

#if _DEBUG_REFCOUNTS
        if (cache_frame_d05adab5b849556bfc3129c4f25b24f3 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_d05adab5b849556bfc3129c4f25b24f3 = MAKE_FUNCTION_FRAME(codeobj_d05adab5b849556bfc3129c4f25b24f3, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_d05adab5b849556bfc3129c4f25b24f3->m_type_description == NULL);
    frame_d05adab5b849556bfc3129c4f25b24f3 = cache_frame_d05adab5b849556bfc3129c4f25b24f3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_d05adab5b849556bfc3129c4f25b24f3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_d05adab5b849556bfc3129c4f25b24f3) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_and_left_truth_1;
        nuitka_bool tmp_and_left_value_1;
        nuitka_bool tmp_and_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        CHECK_OBJECT(par_context_uri);
        tmp_compexpr_left_1 = par_context_uri;
        tmp_compexpr_right_1 = Py_None;
        tmp_and_left_value_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_1 = tmp_and_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_1 == 1) {
            goto and_right_1;
        } else {
            goto and_left_1;
        }
        and_right_1:;
        CHECK_OBJECT(par_uris);
        tmp_compexpr_left_2 = par_uris;
        tmp_compexpr_right_2 = Py_None;
        tmp_and_right_value_1 = (tmp_compexpr_left_2 != tmp_compexpr_right_2) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_1 = tmp_and_right_value_1;
        goto and_end_1;
        and_left_1:;
        tmp_condition_result_1 = tmp_and_left_value_1;
        and_end_1:;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1311;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_d05adab5b849556bfc3129c4f25b24f3->m_frame.f_lineno = 1311;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_7475ac184a2aa6f3857bca677c46863f_tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1311;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_and_left_truth_2;
        nuitka_bool tmp_and_left_value_2;
        nuitka_bool tmp_and_right_value_2;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_uris);
        tmp_compexpr_left_3 = par_uris;
        tmp_compexpr_right_3 = Py_None;
        tmp_and_left_value_2 = (tmp_compexpr_left_3 != tmp_compexpr_right_3) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_and_left_truth_2 = tmp_and_left_value_2 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_and_left_truth_2 == 1) {
            goto and_right_2;
        } else {
            goto and_left_2;
        }
        and_right_2:;
        CHECK_OBJECT(par_uris);
        tmp_isinstance_inst_1 = par_uris;
        tmp_isinstance_cls_1 = (PyObject *)&PyList_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1313;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1313;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_and_right_value_2 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        tmp_condition_result_2 = tmp_and_right_value_2;
        goto and_end_2;
        and_left_2:;
        tmp_condition_result_2 = tmp_and_left_value_2;
        and_end_2:;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1314;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_d05adab5b849556bfc3129c4f25b24f3->m_frame.f_lineno = 1314;
        tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_5787669024b1126d33f548eee9dfba27_tuple, 0));

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1314;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_2:;
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = PyDict_New();
        assert(var_data == NULL);
        var_data = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT(par_context_uri);
        tmp_compexpr_left_4 = par_context_uri;
        tmp_compexpr_right_4 = Py_None;
        tmp_condition_result_3 = (tmp_compexpr_left_4 != tmp_compexpr_right_4) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
    }
    branch_yes_3:;
    CHECK_OBJECT(par_context_uri);
    tmp_dictset_value = par_context_uri;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_context_uri;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_3:;
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_5;
        PyObject *tmp_compexpr_right_5;
        CHECK_OBJECT(par_uris);
        tmp_compexpr_left_5 = par_uris;
        tmp_compexpr_right_5 = Py_None;
        tmp_condition_result_4 = (tmp_compexpr_left_5 != tmp_compexpr_right_5) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
    }
    branch_yes_4:;
    CHECK_OBJECT(par_uris);
    tmp_dictset_value = par_uris;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_uris;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_4:;
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_compexpr_left_6;
        PyObject *tmp_compexpr_right_6;
        CHECK_OBJECT(par_offset);
        tmp_compexpr_left_6 = par_offset;
        tmp_compexpr_right_6 = Py_None;
        tmp_condition_result_5 = (tmp_compexpr_left_6 != tmp_compexpr_right_6) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_5;
        } else {
            goto branch_no_5;
        }
    }
    branch_yes_5:;
    CHECK_OBJECT(par_offset);
    tmp_dictset_value = par_offset;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_offset;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_5:;
    {
        nuitka_bool tmp_condition_result_6;
        PyObject *tmp_compexpr_left_7;
        PyObject *tmp_compexpr_right_7;
        CHECK_OBJECT(par_position_ms);
        tmp_compexpr_left_7 = par_position_ms;
        tmp_compexpr_right_7 = Py_None;
        tmp_condition_result_6 = (tmp_compexpr_left_7 != tmp_compexpr_right_7) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
            goto branch_yes_6;
        } else {
            goto branch_no_6;
        }
    }
    branch_yes_6:;
    CHECK_OBJECT(par_position_ms);
    tmp_dictset_value = par_position_ms;
    CHECK_OBJECT(var_data);
    tmp_dictset_dict = var_data;
    tmp_dictset_key = const_str_plain_position_ms;
    tmp_res = PyDict_SetItem(tmp_dictset_dict, tmp_dictset_key, tmp_dictset_value);
    assert(!(tmp_res != 0));
    branch_no_6:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_called_instance_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_kw_name_1;
        PyObject *tmp_dict_key_1;
        PyObject *tmp_dict_value_1;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1325;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_called_instance_3 = par_self;
        tmp_args_element_name_1 = const_str_digest_fbe05da63d91a0174ef8bf2a7a18534f;
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_2 = par_device_id;
        frame_d05adab5b849556bfc3129c4f25b24f3->m_frame.f_lineno = 1326;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_tuple_element_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_3, const_str_plain__append_device_id, call_args);
        }

        if (tmp_tuple_element_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1326;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_name_1 = PyTuple_New(1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        tmp_dict_key_1 = const_str_plain_payload;
        CHECK_OBJECT(var_data);
        tmp_dict_value_1 = var_data;
        tmp_kw_name_1 = _PyDict_NewPresized( 1 );
        tmp_res = PyDict_SetItem(tmp_kw_name_1, tmp_dict_key_1, tmp_dict_value_1);
        assert(!(tmp_res != 0));
        frame_d05adab5b849556bfc3129c4f25b24f3->m_frame.f_lineno = 1325;
        tmp_return_value = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        Py_DECREF(tmp_kw_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1325;
            type_description_1 = "ooooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d05adab5b849556bfc3129c4f25b24f3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_d05adab5b849556bfc3129c4f25b24f3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_d05adab5b849556bfc3129c4f25b24f3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_d05adab5b849556bfc3129c4f25b24f3, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_d05adab5b849556bfc3129c4f25b24f3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_d05adab5b849556bfc3129c4f25b24f3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_d05adab5b849556bfc3129c4f25b24f3,
        type_description_1,
        par_self,
        par_device_id,
        par_context_uri,
        par_uris,
        par_offset,
        par_position_ms,
        var_data
    );


    // Release cached frame.
    if (frame_d05adab5b849556bfc3129c4f25b24f3 == cache_frame_d05adab5b849556bfc3129c4f25b24f3) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_d05adab5b849556bfc3129c4f25b24f3);
    }
    cache_frame_d05adab5b849556bfc3129c4f25b24f3 = NULL;

    assertFrameObject(frame_d05adab5b849556bfc3129c4f25b24f3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(var_data);
    var_data = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_data);
    var_data = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);
    CHECK_OBJECT(par_context_uri);
    Py_DECREF(par_context_uri);
    CHECK_OBJECT(par_uris);
    Py_DECREF(par_uris);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_position_ms);
    Py_DECREF(par_position_ms);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);
    CHECK_OBJECT(par_context_uri);
    Py_DECREF(par_context_uri);
    CHECK_OBJECT(par_uris);
    Py_DECREF(par_uris);
    CHECK_OBJECT(par_offset);
    Py_DECREF(par_offset);
    CHECK_OBJECT(par_position_ms);
    Py_DECREF(par_position_ms);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_86_pause_playback(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_device_id = python_pars[1];
    struct Nuitka_FrameObject *frame_1fa718cf358c88654ca12b337f3c6d81;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_1fa718cf358c88654ca12b337f3c6d81 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_1fa718cf358c88654ca12b337f3c6d81)) {
        Py_XDECREF(cache_frame_1fa718cf358c88654ca12b337f3c6d81);

#if _DEBUG_REFCOUNTS
        if (cache_frame_1fa718cf358c88654ca12b337f3c6d81 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_1fa718cf358c88654ca12b337f3c6d81 = MAKE_FUNCTION_FRAME(codeobj_1fa718cf358c88654ca12b337f3c6d81, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_1fa718cf358c88654ca12b337f3c6d81->m_type_description == NULL);
    frame_1fa718cf358c88654ca12b337f3c6d81 = cache_frame_1fa718cf358c88654ca12b337f3c6d81;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_1fa718cf358c88654ca12b337f3c6d81);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_1fa718cf358c88654ca12b337f3c6d81) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1335;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_2 = const_str_digest_16e376831744b80c309abc0ab80ac512;
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_1fa718cf358c88654ca12b337f3c6d81->m_frame.f_lineno = 1335;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__append_device_id, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1335;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_1fa718cf358c88654ca12b337f3c6d81->m_frame.f_lineno = 1335;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1335;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1fa718cf358c88654ca12b337f3c6d81);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_1fa718cf358c88654ca12b337f3c6d81);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_1fa718cf358c88654ca12b337f3c6d81);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_1fa718cf358c88654ca12b337f3c6d81, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_1fa718cf358c88654ca12b337f3c6d81->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_1fa718cf358c88654ca12b337f3c6d81, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_1fa718cf358c88654ca12b337f3c6d81,
        type_description_1,
        par_self,
        par_device_id
    );


    // Release cached frame.
    if (frame_1fa718cf358c88654ca12b337f3c6d81 == cache_frame_1fa718cf358c88654ca12b337f3c6d81) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_1fa718cf358c88654ca12b337f3c6d81);
    }
    cache_frame_1fa718cf358c88654ca12b337f3c6d81 = NULL;

    assertFrameObject(frame_1fa718cf358c88654ca12b337f3c6d81);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_87_next_track(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_device_id = python_pars[1];
    struct Nuitka_FrameObject *frame_94ab4af3524bbcdc411d25898f593b22;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_94ab4af3524bbcdc411d25898f593b22 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_94ab4af3524bbcdc411d25898f593b22)) {
        Py_XDECREF(cache_frame_94ab4af3524bbcdc411d25898f593b22);

#if _DEBUG_REFCOUNTS
        if (cache_frame_94ab4af3524bbcdc411d25898f593b22 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_94ab4af3524bbcdc411d25898f593b22 = MAKE_FUNCTION_FRAME(codeobj_94ab4af3524bbcdc411d25898f593b22, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_94ab4af3524bbcdc411d25898f593b22->m_type_description == NULL);
    frame_94ab4af3524bbcdc411d25898f593b22 = cache_frame_94ab4af3524bbcdc411d25898f593b22;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_94ab4af3524bbcdc411d25898f593b22);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_94ab4af3524bbcdc411d25898f593b22) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__post);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_2 = const_str_digest_9d2743a3aa01b480c9d69ac590d83c7b;
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_94ab4af3524bbcdc411d25898f593b22->m_frame.f_lineno = 1343;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__append_device_id, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_94ab4af3524bbcdc411d25898f593b22->m_frame.f_lineno = 1343;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1343;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_94ab4af3524bbcdc411d25898f593b22);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_94ab4af3524bbcdc411d25898f593b22);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_94ab4af3524bbcdc411d25898f593b22);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_94ab4af3524bbcdc411d25898f593b22, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_94ab4af3524bbcdc411d25898f593b22->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_94ab4af3524bbcdc411d25898f593b22, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_94ab4af3524bbcdc411d25898f593b22,
        type_description_1,
        par_self,
        par_device_id
    );


    // Release cached frame.
    if (frame_94ab4af3524bbcdc411d25898f593b22 == cache_frame_94ab4af3524bbcdc411d25898f593b22) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_94ab4af3524bbcdc411d25898f593b22);
    }
    cache_frame_94ab4af3524bbcdc411d25898f593b22 = NULL;

    assertFrameObject(frame_94ab4af3524bbcdc411d25898f593b22);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_88_previous_track(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_device_id = python_pars[1];
    struct Nuitka_FrameObject *frame_96b38d14a37200870473c9c6e70b2bbc;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_96b38d14a37200870473c9c6e70b2bbc = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_96b38d14a37200870473c9c6e70b2bbc)) {
        Py_XDECREF(cache_frame_96b38d14a37200870473c9c6e70b2bbc);

#if _DEBUG_REFCOUNTS
        if (cache_frame_96b38d14a37200870473c9c6e70b2bbc == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_96b38d14a37200870473c9c6e70b2bbc = MAKE_FUNCTION_FRAME(codeobj_96b38d14a37200870473c9c6e70b2bbc, module_spotipy$client, sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_96b38d14a37200870473c9c6e70b2bbc->m_type_description == NULL);
    frame_96b38d14a37200870473c9c6e70b2bbc = cache_frame_96b38d14a37200870473c9c6e70b2bbc;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_96b38d14a37200870473c9c6e70b2bbc);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_96b38d14a37200870473c9c6e70b2bbc) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__post);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1351;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_2 = const_str_digest_7b4aeedd2d02cc6c175e110c0bda8734;
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_96b38d14a37200870473c9c6e70b2bbc->m_frame.f_lineno = 1352;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__append_device_id, call_args);
        }

        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1352;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        frame_96b38d14a37200870473c9c6e70b2bbc->m_frame.f_lineno = 1351;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1351;
            type_description_1 = "oo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_96b38d14a37200870473c9c6e70b2bbc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_96b38d14a37200870473c9c6e70b2bbc);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_96b38d14a37200870473c9c6e70b2bbc);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_96b38d14a37200870473c9c6e70b2bbc, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_96b38d14a37200870473c9c6e70b2bbc->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_96b38d14a37200870473c9c6e70b2bbc, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_96b38d14a37200870473c9c6e70b2bbc,
        type_description_1,
        par_self,
        par_device_id
    );


    // Release cached frame.
    if (frame_96b38d14a37200870473c9c6e70b2bbc == cache_frame_96b38d14a37200870473c9c6e70b2bbc) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_96b38d14a37200870473c9c6e70b2bbc);
    }
    cache_frame_96b38d14a37200870473c9c6e70b2bbc = NULL;

    assertFrameObject(frame_96b38d14a37200870473c9c6e70b2bbc);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_89_seek_track(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_position_ms = python_pars[1];
    PyObject *par_device_id = python_pars[2];
    struct Nuitka_FrameObject *frame_68970f99ee773eb7d9442246d4c73a29;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_68970f99ee773eb7d9442246d4c73a29 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_68970f99ee773eb7d9442246d4c73a29)) {
        Py_XDECREF(cache_frame_68970f99ee773eb7d9442246d4c73a29);

#if _DEBUG_REFCOUNTS
        if (cache_frame_68970f99ee773eb7d9442246d4c73a29 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_68970f99ee773eb7d9442246d4c73a29 = MAKE_FUNCTION_FRAME(codeobj_68970f99ee773eb7d9442246d4c73a29, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_68970f99ee773eb7d9442246d4c73a29->m_type_description == NULL);
    frame_68970f99ee773eb7d9442246d4c73a29 = cache_frame_68970f99ee773eb7d9442246d4c73a29;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_68970f99ee773eb7d9442246d4c73a29);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_68970f99ee773eb7d9442246d4c73a29) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_position_ms);
        tmp_isinstance_inst_1 = par_position_ms;
        tmp_isinstance_cls_1 = (PyObject *)&PyLong_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1362;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1363;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_68970f99ee773eb7d9442246d4c73a29->m_frame.f_lineno = 1363;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_4000cc7b27bd107cc750c3ea4a0c9d19_tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1363;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__append_device_id);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_9ea71127940e425419165c8e7548f59f;
        CHECK_OBJECT(par_position_ms);
        tmp_right_name_1 = par_position_ms;
        tmp_args_element_name_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1367;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_68970f99ee773eb7d9442246d4c73a29->m_frame.f_lineno = 1366;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1366;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_68970f99ee773eb7d9442246d4c73a29->m_frame.f_lineno = 1365;
        tmp_return_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1365;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_68970f99ee773eb7d9442246d4c73a29);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_68970f99ee773eb7d9442246d4c73a29);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_68970f99ee773eb7d9442246d4c73a29);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_68970f99ee773eb7d9442246d4c73a29, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_68970f99ee773eb7d9442246d4c73a29->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_68970f99ee773eb7d9442246d4c73a29, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_68970f99ee773eb7d9442246d4c73a29,
        type_description_1,
        par_self,
        par_position_ms,
        par_device_id
    );


    // Release cached frame.
    if (frame_68970f99ee773eb7d9442246d4c73a29 == cache_frame_68970f99ee773eb7d9442246d4c73a29) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_68970f99ee773eb7d9442246d4c73a29);
    }
    cache_frame_68970f99ee773eb7d9442246d4c73a29 = NULL;

    assertFrameObject(frame_68970f99ee773eb7d9442246d4c73a29);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_position_ms);
    Py_DECREF(par_position_ms);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_position_ms);
    Py_DECREF(par_position_ms);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_90_repeat(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_state = python_pars[1];
    PyObject *par_device_id = python_pars[2];
    struct Nuitka_FrameObject *frame_ea0bda7a95b207898acca58f06ef419f;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_ea0bda7a95b207898acca58f06ef419f = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_ea0bda7a95b207898acca58f06ef419f)) {
        Py_XDECREF(cache_frame_ea0bda7a95b207898acca58f06ef419f);

#if _DEBUG_REFCOUNTS
        if (cache_frame_ea0bda7a95b207898acca58f06ef419f == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_ea0bda7a95b207898acca58f06ef419f = MAKE_FUNCTION_FRAME(codeobj_ea0bda7a95b207898acca58f06ef419f, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_ea0bda7a95b207898acca58f06ef419f->m_type_description == NULL);
    frame_ea0bda7a95b207898acca58f06ef419f = cache_frame_ea0bda7a95b207898acca58f06ef419f;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_ea0bda7a95b207898acca58f06ef419f);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_ea0bda7a95b207898acca58f06ef419f) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_state);
        tmp_compexpr_left_1 = par_state;
        tmp_compexpr_right_1 = LIST_COPY(const_list_str_plain_track_str_plain_context_str_plain_off_list);
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        Py_DECREF(tmp_compexpr_right_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1378;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1379;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_ea0bda7a95b207898acca58f06ef419f->m_frame.f_lineno = 1379;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_1e8042c594f592682be42de584406334_tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1379;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_1:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__append_device_id);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1382;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_cf0e60aeef8b8fd92f93cc4479500be7;
        CHECK_OBJECT(par_state);
        tmp_right_name_1 = par_state;
        tmp_args_element_name_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1383;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_ea0bda7a95b207898acca58f06ef419f->m_frame.f_lineno = 1382;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1382;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_ea0bda7a95b207898acca58f06ef419f->m_frame.f_lineno = 1381;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1381;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ea0bda7a95b207898acca58f06ef419f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_ea0bda7a95b207898acca58f06ef419f);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_ea0bda7a95b207898acca58f06ef419f);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_ea0bda7a95b207898acca58f06ef419f, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_ea0bda7a95b207898acca58f06ef419f->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_ea0bda7a95b207898acca58f06ef419f, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_ea0bda7a95b207898acca58f06ef419f,
        type_description_1,
        par_self,
        par_state,
        par_device_id
    );


    // Release cached frame.
    if (frame_ea0bda7a95b207898acca58f06ef419f == cache_frame_ea0bda7a95b207898acca58f06ef419f) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_ea0bda7a95b207898acca58f06ef419f);
    }
    cache_frame_ea0bda7a95b207898acca58f06ef419f = NULL;

    assertFrameObject(frame_ea0bda7a95b207898acca58f06ef419f);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_state);
    Py_DECREF(par_state);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_state);
    Py_DECREF(par_state);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_91_volume(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_volume_percent = python_pars[1];
    PyObject *par_device_id = python_pars[2];
    struct Nuitka_FrameObject *frame_efc2fdaf980f974e85adba56eab74e1d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_efc2fdaf980f974e85adba56eab74e1d = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_efc2fdaf980f974e85adba56eab74e1d)) {
        Py_XDECREF(cache_frame_efc2fdaf980f974e85adba56eab74e1d);

#if _DEBUG_REFCOUNTS
        if (cache_frame_efc2fdaf980f974e85adba56eab74e1d == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_efc2fdaf980f974e85adba56eab74e1d = MAKE_FUNCTION_FRAME(codeobj_efc2fdaf980f974e85adba56eab74e1d, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_efc2fdaf980f974e85adba56eab74e1d->m_type_description == NULL);
    frame_efc2fdaf980f974e85adba56eab74e1d = cache_frame_efc2fdaf980f974e85adba56eab74e1d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_efc2fdaf980f974e85adba56eab74e1d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_efc2fdaf980f974e85adba56eab74e1d) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_volume_percent);
        tmp_isinstance_inst_1 = par_volume_percent;
        tmp_isinstance_cls_1 = (PyObject *)&PyLong_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1394;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1395;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_efc2fdaf980f974e85adba56eab74e1d->m_frame.f_lineno = 1395;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_437745d19c2123e6ab1318a417676e2d_tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1395;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_2;
        int tmp_or_left_truth_1;
        nuitka_bool tmp_or_left_value_1;
        nuitka_bool tmp_or_right_value_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_tmp_or_left_value_1_object_1;
        int tmp_truth_name_1;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_tmp_or_right_value_1_object_1;
        int tmp_truth_name_2;
        CHECK_OBJECT(par_volume_percent);
        tmp_compexpr_left_1 = par_volume_percent;
        tmp_compexpr_right_1 = const_int_0;
        tmp_tmp_or_left_value_1_object_1 = RICH_COMPARE_LT_OBJECT_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        if (tmp_tmp_or_left_value_1_object_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1397;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_tmp_or_left_value_1_object_1);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_tmp_or_left_value_1_object_1);

            exception_lineno = 1397;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_left_value_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_tmp_or_left_value_1_object_1);
        tmp_or_left_truth_1 = tmp_or_left_value_1 == NUITKA_BOOL_TRUE ? 1 : 0;
        if (tmp_or_left_truth_1 == 1) {
            goto or_left_1;
        } else {
            goto or_right_1;
        }
        or_right_1:;
        CHECK_OBJECT(par_volume_percent);
        tmp_compexpr_left_2 = par_volume_percent;
        tmp_compexpr_right_2 = const_int_pos_100;
        tmp_tmp_or_right_value_1_object_1 = RICH_COMPARE_GT_OBJECT_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        if (tmp_tmp_or_right_value_1_object_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1397;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_truth_name_2 = CHECK_IF_TRUE(tmp_tmp_or_right_value_1_object_1);
        if (tmp_truth_name_2 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_tmp_or_right_value_1_object_1);

            exception_lineno = 1397;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_or_right_value_1 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_tmp_or_right_value_1_object_1);
        tmp_condition_result_2 = tmp_or_right_value_1;
        goto or_end_1;
        or_left_1:;
        tmp_condition_result_2 = tmp_or_left_value_1;
        or_end_1:;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_2;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1398;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_2 = tmp_mvar_value_2;
        frame_efc2fdaf980f974e85adba56eab74e1d->m_frame.f_lineno = 1398;
        tmp_call_result_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_1220c3da1cafe83a535c664450909a43_tuple, 0));

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1398;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_2:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_call_result_3;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__append_device_id);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1401;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_b50684ce91176f628bca5e02ea01b473;
        CHECK_OBJECT(par_volume_percent);
        tmp_right_name_1 = par_volume_percent;
        tmp_args_element_name_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1402;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_efc2fdaf980f974e85adba56eab74e1d->m_frame.f_lineno = 1401;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1401;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_efc2fdaf980f974e85adba56eab74e1d->m_frame.f_lineno = 1400;
        tmp_call_result_3 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1400;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_3);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efc2fdaf980f974e85adba56eab74e1d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_efc2fdaf980f974e85adba56eab74e1d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_efc2fdaf980f974e85adba56eab74e1d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_efc2fdaf980f974e85adba56eab74e1d, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_efc2fdaf980f974e85adba56eab74e1d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_efc2fdaf980f974e85adba56eab74e1d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_efc2fdaf980f974e85adba56eab74e1d,
        type_description_1,
        par_self,
        par_volume_percent,
        par_device_id
    );


    // Release cached frame.
    if (frame_efc2fdaf980f974e85adba56eab74e1d == cache_frame_efc2fdaf980f974e85adba56eab74e1d) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_efc2fdaf980f974e85adba56eab74e1d);
    }
    cache_frame_efc2fdaf980f974e85adba56eab74e1d = NULL;

    assertFrameObject(frame_efc2fdaf980f974e85adba56eab74e1d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto function_return_exit;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_volume_percent);
    Py_DECREF(par_volume_percent);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_volume_percent);
    Py_DECREF(par_volume_percent);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_92_shuffle(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_state = python_pars[1];
    PyObject *par_device_id = python_pars[2];
    struct Nuitka_FrameObject *frame_06b012069081bb35b69567ff4444dae3;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    int tmp_res;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_06b012069081bb35b69567ff4444dae3 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_06b012069081bb35b69567ff4444dae3)) {
        Py_XDECREF(cache_frame_06b012069081bb35b69567ff4444dae3);

#if _DEBUG_REFCOUNTS
        if (cache_frame_06b012069081bb35b69567ff4444dae3 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_06b012069081bb35b69567ff4444dae3 = MAKE_FUNCTION_FRAME(codeobj_06b012069081bb35b69567ff4444dae3, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_06b012069081bb35b69567ff4444dae3->m_type_description == NULL);
    frame_06b012069081bb35b69567ff4444dae3 = cache_frame_06b012069081bb35b69567ff4444dae3;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_06b012069081bb35b69567ff4444dae3);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_06b012069081bb35b69567ff4444dae3) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_isinstance_inst_1;
        PyObject *tmp_isinstance_cls_1;
        CHECK_OBJECT(par_state);
        tmp_isinstance_inst_1 = par_state;
        tmp_isinstance_cls_1 = (PyObject *)&PyBool_Type;
        tmp_res = Nuitka_IsInstance(tmp_isinstance_inst_1, tmp_isinstance_cls_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1414;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1414;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1415;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_1;
        frame_06b012069081bb35b69567ff4444dae3->m_frame.f_lineno = 1415;
        tmp_call_result_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_warning, &PyTuple_GET_ITEM(const_tuple_str_digest_35f78d818bb0285af39fbe7dbc808b01_tuple, 0));

        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1415;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;
    branch_no_1:;
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_2;
        PyObject *tmp_unicode_arg_1;
        CHECK_OBJECT(par_state);
        tmp_unicode_arg_1 = par_state;
        tmp_called_instance_2 = PyObject_Unicode(tmp_unicode_arg_1);
        if (tmp_called_instance_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1417;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_06b012069081bb35b69567ff4444dae3->m_frame.f_lineno = 1417;
        tmp_assign_source_1 = CALL_METHOD_NO_ARGS(tmp_called_instance_2, const_str_plain_lower);
        Py_DECREF(tmp_called_instance_2);
        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1417;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_state;
            assert(old != NULL);
            par_state = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_called_name_2;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_expression_name_1 = par_self;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_1, const_str_plain__put);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1418;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_expression_name_2 = par_self;
        tmp_called_name_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain__append_device_id);
        if (tmp_called_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1419;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_left_name_1 = const_str_digest_9dc62dec5d04c5eb8a17c90c45485f89;
        CHECK_OBJECT(par_state);
        tmp_right_name_1 = par_state;
        tmp_args_element_name_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_args_element_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);
            Py_DECREF(tmp_called_name_2);

            exception_lineno = 1420;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_device_id);
        tmp_args_element_name_3 = par_device_id;
        frame_06b012069081bb35b69567ff4444dae3->m_frame.f_lineno = 1419;
        {
            PyObject *call_args[] = {tmp_args_element_name_2, tmp_args_element_name_3};
            tmp_args_element_name_1 = CALL_FUNCTION_WITH_ARGS2(tmp_called_name_2, call_args);
        }

        Py_DECREF(tmp_called_name_2);
        Py_DECREF(tmp_args_element_name_2);
        if (tmp_args_element_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1419;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        frame_06b012069081bb35b69567ff4444dae3->m_frame.f_lineno = 1418;
        tmp_call_result_2 = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_1, tmp_args_element_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_1);
        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1418;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_06b012069081bb35b69567ff4444dae3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_06b012069081bb35b69567ff4444dae3);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_06b012069081bb35b69567ff4444dae3);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_06b012069081bb35b69567ff4444dae3, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_06b012069081bb35b69567ff4444dae3->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_06b012069081bb35b69567ff4444dae3, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_06b012069081bb35b69567ff4444dae3,
        type_description_1,
        par_self,
        par_state,
        par_device_id
    );


    // Release cached frame.
    if (frame_06b012069081bb35b69567ff4444dae3 == cache_frame_06b012069081bb35b69567ff4444dae3) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_06b012069081bb35b69567ff4444dae3);
    }
    cache_frame_06b012069081bb35b69567ff4444dae3 = NULL;

    assertFrameObject(frame_06b012069081bb35b69567ff4444dae3);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    tmp_return_value = Py_None;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(par_state);
    Py_DECREF(par_state);
    par_state = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT(par_state);
    Py_DECREF(par_state);
    par_state = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_93_add_to_queue(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_uri = python_pars[1];
    PyObject *par_device_id = python_pars[2];
    PyObject *var_endpoint = NULL;
    struct Nuitka_FrameObject *frame_5a1a0089bd1a7cb13169e5d9f0339c3b;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b)) {
        Py_XDECREF(cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b);

#if _DEBUG_REFCOUNTS
        if (cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b = MAKE_FUNCTION_FRAME(codeobj_5a1a0089bd1a7cb13169e5d9f0339c3b, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b->m_type_description == NULL);
    frame_5a1a0089bd1a7cb13169e5d9f0339c3b = cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_5a1a0089bd1a7cb13169e5d9f0339c3b);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_5a1a0089bd1a7cb13169e5d9f0339c3b) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        tmp_args_element_name_1 = const_str_plain_track;
        CHECK_OBJECT(par_uri);
        tmp_args_element_name_2 = par_uri;
        frame_5a1a0089bd1a7cb13169e5d9f0339c3b->m_frame.f_lineno = 1439;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_assign_source_1 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_uri, call_args);
        }

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1439;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = par_uri;
            assert(old != NULL);
            par_uri = tmp_assign_source_1;
            Py_DECREF(old);
        }

    }
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        tmp_left_name_1 = const_str_digest_3e78615d7227579781094c3c19b67451;
        CHECK_OBJECT(par_uri);
        tmp_right_name_1 = par_uri;
        tmp_assign_source_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_1, tmp_right_name_1);
        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1441;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        assert(var_endpoint == NULL);
        var_endpoint = tmp_assign_source_2;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        CHECK_OBJECT(par_device_id);
        tmp_compexpr_left_1 = par_device_id;
        tmp_compexpr_right_1 = Py_None;
        tmp_condition_result_1 = (tmp_compexpr_left_1 != tmp_compexpr_right_1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_3;
        CHECK_OBJECT(var_endpoint);
        tmp_left_name_2 = var_endpoint;
        tmp_left_name_3 = const_str_digest_13224bc18feb1ba01c2cde37d88d6b18;
        CHECK_OBJECT(par_device_id);
        tmp_right_name_3 = par_device_id;
        tmp_right_name_2 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_3, tmp_right_name_3);
        if (tmp_right_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1444;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE(&tmp_left_name_2, tmp_right_name_2);
        Py_DECREF(tmp_right_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1444;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_3 = tmp_left_name_2;
        var_endpoint = tmp_assign_source_3;

    }
    branch_no_1:;
    {
        PyObject *tmp_called_instance_2;
        PyObject *tmp_args_element_name_3;
        CHECK_OBJECT(par_self);
        tmp_called_instance_2 = par_self;
        CHECK_OBJECT(var_endpoint);
        tmp_args_element_name_3 = var_endpoint;
        frame_5a1a0089bd1a7cb13169e5d9f0339c3b->m_frame.f_lineno = 1446;
        {
            PyObject *call_args[] = {tmp_args_element_name_3};
            tmp_return_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain__post, call_args);
        }

        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1446;
            type_description_1 = "oooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5a1a0089bd1a7cb13169e5d9f0339c3b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_5a1a0089bd1a7cb13169e5d9f0339c3b);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_5a1a0089bd1a7cb13169e5d9f0339c3b);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_5a1a0089bd1a7cb13169e5d9f0339c3b, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_5a1a0089bd1a7cb13169e5d9f0339c3b->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_5a1a0089bd1a7cb13169e5d9f0339c3b, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_5a1a0089bd1a7cb13169e5d9f0339c3b,
        type_description_1,
        par_self,
        par_uri,
        par_device_id,
        var_endpoint
    );


    // Release cached frame.
    if (frame_5a1a0089bd1a7cb13169e5d9f0339c3b == cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_5a1a0089bd1a7cb13169e5d9f0339c3b);
    }
    cache_frame_5a1a0089bd1a7cb13169e5d9f0339c3b = NULL;

    assertFrameObject(frame_5a1a0089bd1a7cb13169e5d9f0339c3b);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(par_uri);
    Py_DECREF(par_uri);
    par_uri = NULL;

    CHECK_OBJECT(var_endpoint);
    Py_DECREF(var_endpoint);
    var_endpoint = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    CHECK_OBJECT(par_uri);
    Py_DECREF(par_uri);
    par_uri = NULL;

    Py_XDECREF(var_endpoint);
    var_endpoint = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_94__append_device_id(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_path = python_pars[1];
    PyObject *par_device_id = python_pars[2];
    struct Nuitka_FrameObject *frame_e3c0461f1c8bf2eb2a8c340eb6135f8c;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    bool tmp_result;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c)) {
        Py_XDECREF(cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);

#if _DEBUG_REFCOUNTS
        if (cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c = MAKE_FUNCTION_FRAME(codeobj_e3c0461f1c8bf2eb2a8c340eb6135f8c, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c->m_type_description == NULL);
    frame_e3c0461f1c8bf2eb2a8c340eb6135f8c = cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c) == 2); // Frame stack

    // Framed code:
    {
        nuitka_bool tmp_condition_result_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(par_device_id);
        tmp_truth_name_1 = CHECK_IF_TRUE(par_device_id);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1454;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        tmp_compexpr_left_1 = const_str_chr_63;
        CHECK_OBJECT(par_path);
        tmp_compexpr_right_1 = par_path;
        tmp_res = PySequence_Contains(tmp_compexpr_right_1, tmp_compexpr_left_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1455;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_right_name_2;
        CHECK_OBJECT(par_path);
        tmp_left_name_1 = par_path;
        tmp_left_name_2 = const_str_digest_13224bc18feb1ba01c2cde37d88d6b18;
        CHECK_OBJECT(par_device_id);
        tmp_right_name_2 = par_device_id;
        tmp_right_name_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_2, tmp_right_name_2);
        if (tmp_right_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1456;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE(&tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1456;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_1 = tmp_left_name_1;
        par_path = tmp_assign_source_1;

    }
    goto branch_end_2;
    branch_no_2:;
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_3;
        PyObject *tmp_left_name_4;
        PyObject *tmp_right_name_4;
        CHECK_OBJECT(par_path);
        tmp_left_name_3 = par_path;
        tmp_left_name_4 = const_str_digest_f0e105bf49756ecd3dea138844c26914;
        CHECK_OBJECT(par_device_id);
        tmp_right_name_4 = par_device_id;
        tmp_right_name_3 = BINARY_OPERATION_MOD_OBJECT_UNICODE_OBJECT(tmp_left_name_4, tmp_right_name_4);
        if (tmp_right_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1458;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_result = BINARY_OPERATION_ADD_OBJECT_OBJECT_INPLACE(&tmp_left_name_3, tmp_right_name_3);
        Py_DECREF(tmp_right_name_3);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1458;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_assign_source_2 = tmp_left_name_3;
        par_path = tmp_assign_source_2;

    }
    branch_end_2:;
    branch_no_1:;
    if (par_path == NULL) {

        exception_type = PyExc_UnboundLocalError;
        Py_INCREF(exception_type);
        exception_value = PyUnicode_FromFormat("local variable '%s' referenced before assignment", "path");
        exception_tb = NULL;
        NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
        CHAIN_EXCEPTION(exception_value);

        exception_lineno = 1459;
        type_description_1 = "ooo";
        goto frame_exception_exit_1;
    }

    tmp_return_value = par_path;
    Py_INCREF(tmp_return_value);
    goto frame_return_exit_1;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_e3c0461f1c8bf2eb2a8c340eb6135f8c->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_e3c0461f1c8bf2eb2a8c340eb6135f8c, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_e3c0461f1c8bf2eb2a8c340eb6135f8c,
        type_description_1,
        par_self,
        par_path,
        par_device_id
    );


    // Release cached frame.
    if (frame_e3c0461f1c8bf2eb2a8c340eb6135f8c == cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);
    }
    cache_frame_e3c0461f1c8bf2eb2a8c340eb6135f8c = NULL;

    assertFrameObject(frame_e3c0461f1c8bf2eb2a8c340eb6135f8c);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    Py_XDECREF(par_path);
    par_path = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(par_path);
    par_path = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_device_id);
    Py_DECREF(par_device_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_95__get_id(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    PyObject *par_id = python_pars[2];
    PyObject *var_fields = NULL;
    PyObject *var_itype = NULL;
    struct Nuitka_FrameObject *frame_419205c4be40b315ea5fe17707529d4d;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    NUITKA_MAY_BE_UNUSED nuitka_void tmp_unused;
    PyObject *tmp_return_value = NULL;
    static struct Nuitka_FrameObject *cache_frame_419205c4be40b315ea5fe17707529d4d = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;

    // Actual function body.
    // Tried code:
    if (isFrameUnusable(cache_frame_419205c4be40b315ea5fe17707529d4d)) {
        Py_XDECREF(cache_frame_419205c4be40b315ea5fe17707529d4d);

#if _DEBUG_REFCOUNTS
        if (cache_frame_419205c4be40b315ea5fe17707529d4d == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_419205c4be40b315ea5fe17707529d4d = MAKE_FUNCTION_FRAME(codeobj_419205c4be40b315ea5fe17707529d4d, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_419205c4be40b315ea5fe17707529d4d->m_type_description == NULL);
    frame_419205c4be40b315ea5fe17707529d4d = cache_frame_419205c4be40b315ea5fe17707529d4d;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_419205c4be40b315ea5fe17707529d4d);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_419205c4be40b315ea5fe17707529d4d) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_assign_source_1;
        PyObject *tmp_called_instance_1;
        CHECK_OBJECT(par_id);
        tmp_called_instance_1 = par_id;
        frame_419205c4be40b315ea5fe17707529d4d->m_frame.f_lineno = 1462;
        tmp_assign_source_1 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_split, &PyTuple_GET_ITEM(const_tuple_str_chr_58_tuple, 0));

        if (tmp_assign_source_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1462;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_fields == NULL);
        var_fields = tmp_assign_source_1;
    }
    {
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_compexpr_left_1;
        PyObject *tmp_compexpr_right_1;
        PyObject *tmp_len_arg_1;
        PyObject *tmp_tmp_condition_result_1_object_1;
        int tmp_truth_name_1;
        CHECK_OBJECT(var_fields);
        tmp_len_arg_1 = var_fields;
        tmp_compexpr_left_1 = BUILTIN_LEN(tmp_len_arg_1);
        if (tmp_compexpr_left_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1463;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_1 = const_int_pos_3;
        tmp_tmp_condition_result_1_object_1 = RICH_COMPARE_GE_OBJECT_OBJECT_OBJECT(tmp_compexpr_left_1, tmp_compexpr_right_1);
        Py_DECREF(tmp_compexpr_left_1);
        assert(!(tmp_tmp_condition_result_1_object_1 == NULL));
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_tmp_condition_result_1_object_1);
        assert(!(tmp_truth_name_1 == -1));
        tmp_condition_result_1 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_tmp_condition_result_1_object_1);
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    {
        nuitka_bool tmp_condition_result_2;
        PyObject *tmp_compexpr_left_2;
        PyObject *tmp_compexpr_right_2;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_subscript_name_1;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_2 = par_type;
        CHECK_OBJECT(var_fields);
        tmp_expression_name_1 = var_fields;
        tmp_subscript_name_1 = const_int_neg_2;
        tmp_compexpr_right_2 = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_1, tmp_subscript_name_1, -2);
        if (tmp_compexpr_right_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1464;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_condition_result_2 = RICH_COMPARE_NE_NBOOL_OBJECT_OBJECT(tmp_compexpr_left_2, tmp_compexpr_right_2);
        Py_DECREF(tmp_compexpr_right_2);
        if (tmp_condition_result_2 == NUITKA_BOOL_EXCEPTION) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1464;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_2;
        PyObject *tmp_mvar_value_1;
        PyObject *tmp_call_result_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        PyObject *tmp_args_element_name_3;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_subscript_name_2;
        PyObject *tmp_args_element_name_4;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_1 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1465;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_expression_name_2 = tmp_mvar_value_1;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_2, const_str_plain_warning);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1465;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_args_element_name_1 = const_str_digest_19eeb686661d8ef9861c731891632dbe;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_2 = par_type;
        CHECK_OBJECT(var_fields);
        tmp_expression_name_3 = var_fields;
        tmp_subscript_name_2 = const_int_neg_2;
        tmp_args_element_name_3 = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_3, tmp_subscript_name_2, -2);
        if (tmp_args_element_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_called_name_1);

            exception_lineno = 1466;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_id);
        tmp_args_element_name_4 = par_id;
        frame_419205c4be40b315ea5fe17707529d4d->m_frame.f_lineno = 1465;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2, tmp_args_element_name_3, tmp_args_element_name_4};
            tmp_call_result_1 = CALL_FUNCTION_WITH_ARGS4(tmp_called_name_1, call_args);
        }

        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_element_name_3);
        if (tmp_call_result_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1465;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_1);
    }
    branch_no_2:;
    {
        PyObject *tmp_expression_name_4;
        PyObject *tmp_subscript_name_3;
        CHECK_OBJECT(var_fields);
        tmp_expression_name_4 = var_fields;
        tmp_subscript_name_3 = const_int_neg_1;
        tmp_return_value = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_4, tmp_subscript_name_3, -1);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1467;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }
    branch_no_1:;
    {
        PyObject *tmp_assign_source_2;
        PyObject *tmp_called_instance_2;
        CHECK_OBJECT(par_id);
        tmp_called_instance_2 = par_id;
        frame_419205c4be40b315ea5fe17707529d4d->m_frame.f_lineno = 1468;
        tmp_assign_source_2 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_split, &PyTuple_GET_ITEM(const_tuple_str_chr_47_tuple, 0));

        if (tmp_assign_source_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1468;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        {
            PyObject *old = var_fields;
            assert(old != NULL);
            var_fields = tmp_assign_source_2;
            Py_DECREF(old);
        }

    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_compexpr_left_3;
        PyObject *tmp_compexpr_right_3;
        PyObject *tmp_len_arg_2;
        PyObject *tmp_tmp_condition_result_3_object_1;
        int tmp_truth_name_2;
        CHECK_OBJECT(var_fields);
        tmp_len_arg_2 = var_fields;
        tmp_compexpr_left_3 = BUILTIN_LEN(tmp_len_arg_2);
        if (tmp_compexpr_left_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1469;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_compexpr_right_3 = const_int_pos_3;
        tmp_tmp_condition_result_3_object_1 = RICH_COMPARE_GE_OBJECT_OBJECT_OBJECT(tmp_compexpr_left_3, tmp_compexpr_right_3);
        Py_DECREF(tmp_compexpr_left_3);
        assert(!(tmp_tmp_condition_result_3_object_1 == NULL));
        tmp_truth_name_2 = CHECK_IF_TRUE(tmp_tmp_condition_result_3_object_1);
        assert(!(tmp_truth_name_2 == -1));
        tmp_condition_result_3 = tmp_truth_name_2 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        Py_DECREF(tmp_tmp_condition_result_3_object_1);
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
    }
    branch_yes_3:;
    {
        PyObject *tmp_assign_source_3;
        PyObject *tmp_expression_name_5;
        PyObject *tmp_subscript_name_4;
        CHECK_OBJECT(var_fields);
        tmp_expression_name_5 = var_fields;
        tmp_subscript_name_4 = const_int_neg_2;
        tmp_assign_source_3 = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_5, tmp_subscript_name_4, -2);
        if (tmp_assign_source_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1470;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        assert(var_itype == NULL);
        var_itype = tmp_assign_source_3;
    }
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_compexpr_left_4;
        PyObject *tmp_compexpr_right_4;
        CHECK_OBJECT(par_type);
        tmp_compexpr_left_4 = par_type;
        CHECK_OBJECT(var_itype);
        tmp_compexpr_right_4 = var_itype;
        tmp_condition_result_4 = RICH_COMPARE_NE_NBOOL_OBJECT_OBJECT(tmp_compexpr_left_4, tmp_compexpr_right_4);
        if (tmp_condition_result_4 == NUITKA_BOOL_EXCEPTION) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1471;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_4;
        } else {
            goto branch_no_4;
        }
    }
    branch_yes_4:;
    {
        PyObject *tmp_called_instance_3;
        PyObject *tmp_mvar_value_2;
        PyObject *tmp_call_result_2;
        PyObject *tmp_args_element_name_5;
        PyObject *tmp_args_element_name_6;
        PyObject *tmp_args_element_name_7;
        PyObject *tmp_args_element_name_8;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logger);
        }

        if (tmp_mvar_value_2 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 16809 ], 28, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 1472;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }

        tmp_called_instance_3 = tmp_mvar_value_2;
        tmp_args_element_name_5 = const_str_digest_19eeb686661d8ef9861c731891632dbe;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_6 = par_type;
        CHECK_OBJECT(var_itype);
        tmp_args_element_name_7 = var_itype;
        CHECK_OBJECT(par_id);
        tmp_args_element_name_8 = par_id;
        frame_419205c4be40b315ea5fe17707529d4d->m_frame.f_lineno = 1472;
        {
            PyObject *call_args[] = {tmp_args_element_name_5, tmp_args_element_name_6, tmp_args_element_name_7, tmp_args_element_name_8};
            tmp_call_result_2 = CALL_METHOD_WITH_ARGS4(tmp_called_instance_3, const_str_plain_warning, call_args);
        }

        if (tmp_call_result_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1472;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        Py_DECREF(tmp_call_result_2);
    }
    branch_no_4:;
    {
        PyObject *tmp_expression_name_6;
        PyObject *tmp_called_instance_4;
        PyObject *tmp_expression_name_7;
        PyObject *tmp_subscript_name_5;
        PyObject *tmp_subscript_name_6;
        CHECK_OBJECT(var_fields);
        tmp_expression_name_7 = var_fields;
        tmp_subscript_name_5 = const_int_neg_1;
        tmp_called_instance_4 = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_7, tmp_subscript_name_5, -1);
        if (tmp_called_instance_4 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1474;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        frame_419205c4be40b315ea5fe17707529d4d->m_frame.f_lineno = 1474;
        tmp_expression_name_6 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_4, const_str_plain_split, &PyTuple_GET_ITEM(const_tuple_str_chr_63_tuple, 0));

        Py_DECREF(tmp_called_instance_4);
        if (tmp_expression_name_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1474;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        tmp_subscript_name_6 = const_int_0;
        tmp_return_value = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_6, tmp_subscript_name_6, 0);
        Py_DECREF(tmp_expression_name_6);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1474;
            type_description_1 = "ooooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }
    branch_no_3:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_419205c4be40b315ea5fe17707529d4d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_419205c4be40b315ea5fe17707529d4d);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto try_return_handler_1;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_419205c4be40b315ea5fe17707529d4d);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_419205c4be40b315ea5fe17707529d4d, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_419205c4be40b315ea5fe17707529d4d->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_419205c4be40b315ea5fe17707529d4d, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_419205c4be40b315ea5fe17707529d4d,
        type_description_1,
        par_self,
        par_type,
        par_id,
        var_fields,
        var_itype
    );


    // Release cached frame.
    if (frame_419205c4be40b315ea5fe17707529d4d == cache_frame_419205c4be40b315ea5fe17707529d4d) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_419205c4be40b315ea5fe17707529d4d);
    }
    cache_frame_419205c4be40b315ea5fe17707529d4d = NULL;

    assertFrameObject(frame_419205c4be40b315ea5fe17707529d4d);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto try_except_handler_1;

    frame_no_exception_1:;
    CHECK_OBJECT(par_id);
    tmp_return_value = par_id;
    Py_INCREF(tmp_return_value);
    goto try_return_handler_1;
    NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
    return NULL;
    // Return handler code:
    try_return_handler_1:;
    CHECK_OBJECT(var_fields);
    Py_DECREF(var_fields);
    var_fields = NULL;

    Py_XDECREF(var_itype);
    var_itype = NULL;

    goto function_return_exit;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_1 = exception_type;
    exception_keeper_value_1 = exception_value;
    exception_keeper_tb_1 = exception_tb;
    exception_keeper_lineno_1 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(var_fields);
    var_fields = NULL;

    Py_XDECREF(var_itype);
    var_itype = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_1;
    exception_value = exception_keeper_value_1;
    exception_tb = exception_keeper_tb_1;
    exception_lineno = exception_keeper_lineno_1;

    goto function_exception_exit;
    // End of try:

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_id);
    Py_DECREF(par_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_id);
    Py_DECREF(par_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}


static PyObject *impl_spotipy$client$$$function_96__get_uri(struct Nuitka_FunctionObject const *self, PyObject **python_pars) {
    // Preserve error status for checks
#ifndef __NUITKA_NO_ASSERT__
    NUITKA_MAY_BE_UNUSED bool had_error = ERROR_OCCURRED();
#endif

    // Local variable declarations.
    PyObject *par_self = python_pars[0];
    PyObject *par_type = python_pars[1];
    PyObject *par_id = python_pars[2];
    struct Nuitka_FrameObject *frame_302c0a2001e73a2f203141af602952e7;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    PyObject *tmp_return_value = NULL;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    static struct Nuitka_FrameObject *cache_frame_302c0a2001e73a2f203141af602952e7 = NULL;

    // Actual function body.
    if (isFrameUnusable(cache_frame_302c0a2001e73a2f203141af602952e7)) {
        Py_XDECREF(cache_frame_302c0a2001e73a2f203141af602952e7);

#if _DEBUG_REFCOUNTS
        if (cache_frame_302c0a2001e73a2f203141af602952e7 == NULL) {
            count_active_frame_cache_instances += 1;
        } else {
            count_released_frame_cache_instances += 1;
        }
        count_allocated_frame_cache_instances += 1;
#endif
        cache_frame_302c0a2001e73a2f203141af602952e7 = MAKE_FUNCTION_FRAME(codeobj_302c0a2001e73a2f203141af602952e7, module_spotipy$client, sizeof(void *)+sizeof(void *)+sizeof(void *));
#if _DEBUG_REFCOUNTS
    } else {
        count_hit_frame_cache_instances += 1;
#endif
    }
    assert(cache_frame_302c0a2001e73a2f203141af602952e7->m_type_description == NULL);
    frame_302c0a2001e73a2f203141af602952e7 = cache_frame_302c0a2001e73a2f203141af602952e7;

    // Push the new frame as the currently active one.
    pushFrameStack(frame_302c0a2001e73a2f203141af602952e7);

    // Mark the frame object as in use, ref count 1 will be up for reuse.
    assert(Py_REFCNT(frame_302c0a2001e73a2f203141af602952e7) == 2); // Frame stack

    // Framed code:
    {
        PyObject *tmp_left_name_1;
        PyObject *tmp_left_name_2;
        PyObject *tmp_left_name_3;
        PyObject *tmp_right_name_1;
        PyObject *tmp_right_name_2;
        PyObject *tmp_right_name_3;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_args_element_name_1;
        PyObject *tmp_args_element_name_2;
        tmp_left_name_3 = const_str_digest_8e9f262240f32f6727dab4cb6fe61480;
        CHECK_OBJECT(par_type);
        tmp_right_name_1 = par_type;
        tmp_left_name_2 = BINARY_OPERATION_ADD_OBJECT_UNICODE_OBJECT(tmp_left_name_3, tmp_right_name_1);
        if (tmp_left_name_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1478;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_right_name_2 = const_str_chr_58;
        tmp_left_name_1 = BINARY_OPERATION_ADD_OBJECT_OBJECT_UNICODE(tmp_left_name_2, tmp_right_name_2);
        Py_DECREF(tmp_left_name_2);
        if (tmp_left_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1478;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        CHECK_OBJECT(par_self);
        tmp_called_instance_1 = par_self;
        CHECK_OBJECT(par_type);
        tmp_args_element_name_1 = par_type;
        CHECK_OBJECT(par_id);
        tmp_args_element_name_2 = par_id;
        frame_302c0a2001e73a2f203141af602952e7->m_frame.f_lineno = 1478;
        {
            PyObject *call_args[] = {tmp_args_element_name_1, tmp_args_element_name_2};
            tmp_right_name_3 = CALL_METHOD_WITH_ARGS2(tmp_called_instance_1, const_str_plain__get_id, call_args);
        }

        if (tmp_right_name_3 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_left_name_1);

            exception_lineno = 1478;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        tmp_return_value = BINARY_OPERATION_ADD_OBJECT_OBJECT_OBJECT(tmp_left_name_1, tmp_right_name_3);
        Py_DECREF(tmp_left_name_1);
        Py_DECREF(tmp_right_name_3);
        if (tmp_return_value == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1478;
            type_description_1 = "ooo";
            goto frame_exception_exit_1;
        }
        goto frame_return_exit_1;
    }

#if 0
    RESTORE_FRAME_EXCEPTION(frame_302c0a2001e73a2f203141af602952e7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto frame_no_exception_1;

    frame_return_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_302c0a2001e73a2f203141af602952e7);
#endif

    // Put the previous frame back on top.
    popFrameStack();

    goto function_return_exit;

    frame_exception_exit_1:;

#if 0
    RESTORE_FRAME_EXCEPTION(frame_302c0a2001e73a2f203141af602952e7);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_302c0a2001e73a2f203141af602952e7, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_302c0a2001e73a2f203141af602952e7->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_302c0a2001e73a2f203141af602952e7, exception_lineno);
    }

    // Attachs locals to frame if any.
    Nuitka_Frame_AttachLocals(
        frame_302c0a2001e73a2f203141af602952e7,
        type_description_1,
        par_self,
        par_type,
        par_id
    );


    // Release cached frame.
    if (frame_302c0a2001e73a2f203141af602952e7 == cache_frame_302c0a2001e73a2f203141af602952e7) {
#if _DEBUG_REFCOUNTS
        count_active_frame_cache_instances -= 1;
        count_released_frame_cache_instances += 1;
#endif

        Py_DECREF(frame_302c0a2001e73a2f203141af602952e7);
    }
    cache_frame_302c0a2001e73a2f203141af602952e7 = NULL;

    assertFrameObject(frame_302c0a2001e73a2f203141af602952e7);

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto function_exception_exit;

    frame_no_exception_1:;

    NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
    return NULL;

function_exception_exit:
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_id);
    Py_DECREF(par_id);    assert(exception_type);
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);

    return NULL;

function_return_exit:
   // Function cleanup code if any.
    CHECK_OBJECT(par_self);
    Py_DECREF(par_self);
    CHECK_OBJECT(par_type);
    Py_DECREF(par_type);
    CHECK_OBJECT(par_id);
    Py_DECREF(par_id);

   // Actual function exit with return value, making sure we did not make
   // the error status worse despite non-NULL return.
   CHECK_OBJECT(tmp_return_value);
   assert(had_error || !ERROR_OCCURRED());
   return tmp_return_value;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_10__post(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_10__post,
        const_str_plain__post,
#if PYTHON_VERSION >= 300
        const_str_digest_c9db8737dfcddf87703a20dae86d6cc6,
#endif
        codeobj_19ef0cc82fd641b32820effcb6b76808,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_11__delete(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_11__delete,
        const_str_plain__delete,
#if PYTHON_VERSION >= 300
        const_str_digest_22b1054355e50899c6bf88a5e7c14b90,
#endif
        codeobj_fdd326dca52447a788f24431430bb6ad,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_12__put(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_12__put,
        const_str_plain__put,
#if PYTHON_VERSION >= 300
        const_str_digest_c756b049a62b03e8fe36ada60a54a03e,
#endif
        codeobj_0549faef48236c7d313fa9148d7f2f51,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_13_next() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_13_next,
        const_str_plain_next,
#if PYTHON_VERSION >= 300
        const_str_digest_08fa1fbd4fd8fbd433259816d4c0fd80,
#endif
        codeobj_8643aa3a9324f9355635999f00ad57d9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2a2c2ba43f4eedfd2d13747c6caa8b25,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_14_previous() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_14_previous,
        const_str_plain_previous,
#if PYTHON_VERSION >= 300
        const_str_digest_01799024cb32c197cee13a1245d6fb67,
#endif
        codeobj_cb5e9701bc67a8bc731fc27811cda79b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2eaee9335e32606751b873994e96fd80,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_15_track() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_15_track,
        const_str_plain_track,
#if PYTHON_VERSION >= 300
        const_str_digest_79519b954015c155dd29d1b46a9c1158,
#endif
        codeobj_20dd0dc6cd05131a2d53502a9508f1ee,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_41fba648edc091dc1004ac663d8aecf4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_16_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_16_tracks,
        const_str_plain_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_7d03408a0919929aa3016cec79244567,
#endif
        codeobj_cea786226d325130b78da7385f8f8ba9,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_147b8574c689a39dd3e1208a7a6f7a89,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_17_artist() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_17_artist,
        const_str_plain_artist,
#if PYTHON_VERSION >= 300
        const_str_digest_f73af7c71e1dcd5503718d51f23de060,
#endif
        codeobj_5197084aa1655fcba879d05a0d251a83,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_22f5858d3d743416f99b1d8706361486,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_18_artists() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_18_artists,
        const_str_plain_artists,
#if PYTHON_VERSION >= 300
        const_str_digest_bf9d8f637e1f805885861297c4fd2e7b,
#endif
        codeobj_84fc0dd7e3204da2c5289a919d64f506,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_b2eef765f8c5abb067a011988de44235,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_19_artist_albums(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_19_artist_albums,
        const_str_plain_artist_albums,
#if PYTHON_VERSION >= 300
        const_str_digest_e96964f806da53ae36961b93a992dcdc,
#endif
        codeobj_7c852edbba3637af02ee8ae23c132a9c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2774574c30cb390537d18eadfb6194c4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_1___init__(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_1___init__,
        const_str_plain___init__,
#if PYTHON_VERSION >= 300
        const_str_digest_4b2c8ed8fa5094614f7604f6c34e95fa,
#endif
        codeobj_40d458b7161fec50b845f57874bd45d9,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_aca4116a97710d2d33f68f95d3da0496,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_20_artist_top_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_20_artist_top_tracks,
        const_str_plain_artist_top_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_00b8f5f56af562fc9d94296f9e2775bc,
#endif
        codeobj_ca158fa9659faea697996b8861fbac5b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_764f11a6df082195a71078a86865117a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_21_artist_related_artists() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_21_artist_related_artists,
        const_str_plain_artist_related_artists,
#if PYTHON_VERSION >= 300
        const_str_digest_d7ab0864ba2818d4a280416965102e06,
#endif
        codeobj_9853ca544245558a309841b61c647a9d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_01c654b122905b0b1b32480ee925f6b7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_22_album() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_22_album,
        const_str_plain_album,
#if PYTHON_VERSION >= 300
        const_str_digest_e20746e27b808631c68a7de73dcbf7e4,
#endif
        codeobj_3d5ba4d98fb2a674e58851f68e9ece08,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_eca0f059baf41471e999a751e560bd50,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_23_album_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_23_album_tracks,
        const_str_plain_album_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_a98e8b7de683f2bff160c84779fead57,
#endif
        codeobj_b1c87682ae63b69b7d39c8f7d942d1f0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_066f6638a3c907c0e5cd1174d5ace6b8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_24_albums() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_24_albums,
        const_str_plain_albums,
#if PYTHON_VERSION >= 300
        const_str_digest_beb9b463b31c02c01059bbfe0eabf6bb,
#endif
        codeobj_715a641a572181e14e9adaab487920f4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_93fcca36131047b95019094338820d2f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_25_show(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_25_show,
        const_str_plain_show,
#if PYTHON_VERSION >= 300
        const_str_digest_0607b1eabf6f75dc0f138641d9491d4d,
#endif
        codeobj_f9b069c262ea13b460c89d859872c039,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_7bcf090e47dac41bef268864bc11052d,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_26_shows(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_26_shows,
        const_str_plain_shows,
#if PYTHON_VERSION >= 300
        const_str_digest_43404de583c5367e36ea771b97f2561a,
#endif
        codeobj_6bdc0596686dfc0b462deed4239e76c7,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_8162ab5fc511821afe1608ebaabcc365,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_27_show_episodes(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_27_show_episodes,
        const_str_plain_show_episodes,
#if PYTHON_VERSION >= 300
        const_str_digest_14d6f4175da676c87e845226510aa004,
#endif
        codeobj_a6d47ed3f0819257d542d41da7816cf0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_66a2e17c5d838acae507a0388b923c91,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_28_episode(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_28_episode,
        const_str_plain_episode,
#if PYTHON_VERSION >= 300
        const_str_digest_2426d2d37163dd769cdef1fa7ba0a966,
#endif
        codeobj_2f6e2042220007e67e1f735a62a30ac8,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_461572c4c90bffa6a73b81c05396465c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_29_episodes(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_29_episodes,
        const_str_plain_episodes,
#if PYTHON_VERSION >= 300
        const_str_digest_88f8614620997a7b7c5450e0473e6487,
#endif
        codeobj_09f8314dcf36acecb4822e17d6367093,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_1edf7ef291a6d2f13ad21e7a038ba6db,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_2_set_auth() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_2_set_auth,
        const_str_plain_set_auth,
#if PYTHON_VERSION >= 300
        const_str_digest_96a41717fe5579fbdcb4a2aecebaef20,
#endif
        codeobj_c7dae76b69bbb3064292f499d2086aba,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_30_search(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_30_search,
        const_str_plain_search,
#if PYTHON_VERSION >= 300
        const_str_digest_72731c07d3278ac93ddcb33bedc1ae3a,
#endif
        codeobj_b8b8b2a680fcba242b884f880392c9d6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_bb4c36c3f1ee6d15e5217090585577d5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_31_user() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_31_user,
        const_str_plain_user,
#if PYTHON_VERSION >= 300
        const_str_digest_410a71fafeb675394fe1eff0fefe1fca,
#endif
        codeobj_1992bb674c115730c3d7ca787dcfc79c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_8db972dc902d3ee7ab11dac29db55dce,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_32_current_user_playlists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_32_current_user_playlists,
        const_str_plain_current_user_playlists,
#if PYTHON_VERSION >= 300
        const_str_digest_5ea519055b607b7c1ff94d353137ea59,
#endif
        codeobj_ab1272eb3da49e1319b67cd0d702382e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_1a1f42c161bd7332ead3228a329cb87a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_33_playlist(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_33_playlist,
        const_str_plain_playlist,
#if PYTHON_VERSION >= 300
        const_str_digest_719b93109d0bcd472ce92b9ca5f0b0a1,
#endif
        codeobj_bb873134d02b7ab21991d824dee68309,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_13b574c3ba7ad6187b88b6911cadbc9a,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_34_playlist_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_34_playlist_tracks,
        const_str_plain_playlist_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_56394365e919e0b53cf3c29c5a7817fb,
#endif
        codeobj_8ee16325e7b90b2b674e1b2dda8fbb1d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_8d3d887854fd55e6c944eb78e0e51acb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_35_playlist_cover_image() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_35_playlist_cover_image,
        const_str_plain_playlist_cover_image,
#if PYTHON_VERSION >= 300
        const_str_digest_eef54eb775249e83f1addd1b51ffa30a,
#endif
        codeobj_81ae924ff3013530f1205e18ea0fb9cd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_826172b5b9d28ef349545850487317c6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_36_playlist_upload_cover_image() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_36_playlist_upload_cover_image,
        const_str_plain_playlist_upload_cover_image,
#if PYTHON_VERSION >= 300
        const_str_digest_304ab7a50291c9fae677bb6cb2a9f8c4,
#endif
        codeobj_fbd8e0ac443eebfa7fa3ac4d1e3e9cd9,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_06ce06e2e0ca5ed295843a89172ce4cf,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_37_user_playlist(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_37_user_playlist,
        const_str_plain_user_playlist,
#if PYTHON_VERSION >= 300
        const_str_digest_5e2d0d309d6799d2b2500c57eb38e379,
#endif
        codeobj_11ebf3160087fe2851050075a57a707d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_38_user_playlist_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_38_user_playlist_tracks,
        const_str_plain_user_playlist_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_ab6127a399e734894254eb9c80531bea,
#endif
        codeobj_2c79586a1ed1d017b86e3b8a016ef4f9,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_39_user_playlists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_39_user_playlists,
        const_str_plain_user_playlists,
#if PYTHON_VERSION >= 300
        const_str_digest_af8a59ee158f81b27a541e29aa6b044e,
#endif
        codeobj_48d6590f132aac7ab0ed4bc6f937525b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_1a8b6548667df279696cefce4cc3a3c1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_3_auth_manager() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_3_auth_manager,
        const_str_plain_auth_manager,
#if PYTHON_VERSION >= 300
        const_str_digest_ffa0992fc3e937316133dc1511c1babb,
#endif
        codeobj_732a0999f6a8d395b9c177f40b3df467,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_40_user_playlist_create(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_40_user_playlist_create,
        const_str_plain_user_playlist_create,
#if PYTHON_VERSION >= 300
        const_str_digest_e778dc668e45ddcafe4d67d943148e2d,
#endif
        codeobj_06fc7afb37bb590954770ef5cc01bd68,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_f79216834977c09ad46a369d9c09854c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_41_user_playlist_change_details(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_41_user_playlist_change_details,
        const_str_plain_user_playlist_change_details,
#if PYTHON_VERSION >= 300
        const_str_digest_0d902bb3bd6b845836b00d2cb91900bb,
#endif
        codeobj_c9af8615d8b382ab25d387a4ae2144bc,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_7bdf7f5f2cee1538c772082d0885025f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_42_user_playlist_unfollow() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_42_user_playlist_unfollow,
        const_str_plain_user_playlist_unfollow,
#if PYTHON_VERSION >= 300
        const_str_digest_704bea8878314747d972920e0987e163,
#endif
        codeobj_e88bbbf696a76c8d25dfac8c1b201a35,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_ea7d6548ef37d4b0632c164c6b7bea7c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_43_user_playlist_add_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_43_user_playlist_add_tracks,
        const_str_plain_user_playlist_add_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_ddf63d8e67c74433202126d85f63720d,
#endif
        codeobj_0b02fe1bf74fa2e8f3be10e4fea252d1,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_848b05d9873b21f3410831cc56f1f4f0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_44_user_playlist_replace_tracks() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_44_user_playlist_replace_tracks,
        const_str_plain_user_playlist_replace_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_7a15e76af9258d39e881ccef235c8981,
#endif
        codeobj_2d651ca3de79d85f11fde11a7e7de8a4,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_45149880b235040e3cc1276f459ecfa0,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_45_user_playlist_reorder_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_45_user_playlist_reorder_tracks,
        const_str_plain_user_playlist_reorder_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_9c2ae9a1450f607e30d3dd15ddb3202e,
#endif
        codeobj_461ef44fe0103cf3dcb9bc48cf4045fa,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_b53a9225f95dfacd53de288eb49849b4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_46_user_playlist_remove_all_occurrences_of_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_46_user_playlist_remove_all_occurrences_of_tracks,
        const_str_digest_4b32f198f6de09ec1a43edf661b1c6e4,
#if PYTHON_VERSION >= 300
        const_str_digest_d8d7e79085a29dc1ccf4d3c139ad694e,
#endif
        codeobj_b3c4b5edc4fdbdc86e95e400aff5eb12,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_4c586604e0e933a3b0da727a9d982d51,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_47_user_playlist_remove_specific_occurrences_of_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_47_user_playlist_remove_specific_occurrences_of_tracks,
        const_str_digest_f3bd18c4e4dfe3b238c61f74d4197ffd,
#if PYTHON_VERSION >= 300
        const_str_digest_e0de147f27f355d47023f4e16df331f0,
#endif
        codeobj_65974833a3df4d178e6a07b93e7b2058,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2dbaaa50149a05432865aa8002090146,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_48_user_playlist_follow_playlist() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_48_user_playlist_follow_playlist,
        const_str_plain_user_playlist_follow_playlist,
#if PYTHON_VERSION >= 300
        const_str_digest_bb9045d588645f6e09401dc640cbacf2,
#endif
        codeobj_2c52ecf04878c5e07b5a9352531b27fd,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_d50c5bd1c8d54069535879650ef443a5,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_49_user_playlist_is_following() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_49_user_playlist_is_following,
        const_str_plain_user_playlist_is_following,
#if PYTHON_VERSION >= 300
        const_str_digest_050195bad0e1f8243f136319af575115,
#endif
        codeobj_5e5a263fa0cb9631492a4fffaa6bde27,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_c176c326cbe6514933ab2d3696cbe8eb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_4_auth_manager() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_4_auth_manager,
        const_str_plain_auth_manager,
#if PYTHON_VERSION >= 300
        const_str_digest_ffa0992fc3e937316133dc1511c1babb,
#endif
        codeobj_eb387851309ccb53c81037c3614740f6,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_50_me() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_50_me,
        const_str_plain_me,
#if PYTHON_VERSION >= 300
        const_str_digest_231f278518e15360f0e83a2b4f233662,
#endif
        codeobj_00663836178c09119ca59370dbc4f5ea,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2053fcde6598069e7f533c9fe817316c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_51_current_user() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_51_current_user,
        const_str_plain_current_user,
#if PYTHON_VERSION >= 300
        const_str_digest_bac177f6409c0163a72de93274bfcfda,
#endif
        codeobj_53030939b146cc9d42e6d4f1be43e88c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_c4e4d6ee79b254fd0456272a4368eceb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_52_current_user_playing_track() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_52_current_user_playing_track,
        const_str_plain_current_user_playing_track,
#if PYTHON_VERSION >= 300
        const_str_digest_c0f7f6ac2ded292348d4d33e1370f034,
#endif
        codeobj_807d4878b190acac94f898107f81fe18,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_07e7f9ec031b8623c28ffb0538000243,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_53_current_user_saved_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_53_current_user_saved_tracks,
        const_str_plain_current_user_saved_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_df5e9278827652f7a7b9ebd1b7a18fde,
#endif
        codeobj_e234381f83cd62c5730033d0a983bd87,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_3fad55d9b16e5e6483c31abe09170773,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_54_current_user_followed_artists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_54_current_user_followed_artists,
        const_str_plain_current_user_followed_artists,
#if PYTHON_VERSION >= 300
        const_str_digest_c837bee036dd14c3f093d35248327022,
#endif
        codeobj_76dad211ce06eefadd08e6fe6a2ec222,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_3d645e04bcf949fb901ec9ddbe408b65,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_55_current_user_saved_tracks_delete(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_55_current_user_saved_tracks_delete,
        const_str_plain_current_user_saved_tracks_delete,
#if PYTHON_VERSION >= 300
        const_str_digest_72c39d9a88a6b461c157aee4ce2cc943,
#endif
        codeobj_efd3c2b04e65a2e7494c99d633f9af5b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_a140ca1afdc95e3bc95838a29ed7a7cb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_56_current_user_saved_tracks_contains(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_56_current_user_saved_tracks_contains,
        const_str_plain_current_user_saved_tracks_contains,
#if PYTHON_VERSION >= 300
        const_str_digest_a5475341d16ac442212eca2ae5ce481c,
#endif
        codeobj_b62f655676fb2fb2ac69760ff8894e32,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_3c86c46e0167d5634370eed30742bc81,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_57_current_user_saved_tracks_add(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_57_current_user_saved_tracks_add,
        const_str_plain_current_user_saved_tracks_add,
#if PYTHON_VERSION >= 300
        const_str_digest_86b299db541ebe8d4a030a5cb6ee08ca,
#endif
        codeobj_c802e26f9455ae469522a70187683133,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_7b3c05a139c5aea99aa8643803da85a9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_58_current_user_top_artists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_58_current_user_top_artists,
        const_str_plain_current_user_top_artists,
#if PYTHON_VERSION >= 300
        const_str_digest_5ffaaf10b0544615d3c06b06a2628169,
#endif
        codeobj_beb81c8ff6f3724b3c8798c4c515daca,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_cd1fee3b799518143086c98a6701773c,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_59_current_user_top_tracks(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_59_current_user_top_tracks,
        const_str_plain_current_user_top_tracks,
#if PYTHON_VERSION >= 300
        const_str_digest_fce43981ff247be47ab0a78bb306a831,
#endif
        codeobj_1350fb0c9dc013e11cfe4743a442a947,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_879242dc41bf721b411af8e2247307b4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_5___del__() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_5___del__,
        const_str_plain___del__,
#if PYTHON_VERSION >= 300
        const_str_digest_f464ef528bb072445c99cf21a2c7ffc3,
#endif
        codeobj_5ba07520ccb205f02209ae0d2350fdfc,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_904eb8663ffdf47125032c6fe29e82f7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_60_current_user_recently_played(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_60_current_user_recently_played,
        const_str_plain_current_user_recently_played,
#if PYTHON_VERSION >= 300
        const_str_digest_fc25e5cf6e0b48aa9d408ea60121013f,
#endif
        codeobj_965440f565182c6598dbf33c10541c66,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_d8a87e891106f59734dd2f86091ec954,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_61_current_user_saved_albums(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_61_current_user_saved_albums,
        const_str_plain_current_user_saved_albums,
#if PYTHON_VERSION >= 300
        const_str_digest_9a029006dffa7d97b13721aeb2f78406,
#endif
        codeobj_451a8011f44bd9fb715fc33536be8eaf,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_276fb866df82e86eb69e538ba8a0f638,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_62_current_user_saved_albums_contains(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_62_current_user_saved_albums_contains,
        const_str_plain_current_user_saved_albums_contains,
#if PYTHON_VERSION >= 300
        const_str_digest_b44ed5b039ecf981522aec07f6a4ce6f,
#endif
        codeobj_c8c71ecff826f1d926365130265beaa0,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_aac40a8551d6102f0d2c30ca4a15eac4,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_63_current_user_saved_albums_add(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_63_current_user_saved_albums_add,
        const_str_plain_current_user_saved_albums_add,
#if PYTHON_VERSION >= 300
        const_str_digest_7040c56b8e50bb41180c395c1e114602,
#endif
        codeobj_a4377935b5e1079fffa83973e17dd07e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_692c4b25f3b4e214a8f7bcfe297e5fa9,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_64_current_user_saved_albums_delete(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_64_current_user_saved_albums_delete,
        const_str_plain_current_user_saved_albums_delete,
#if PYTHON_VERSION >= 300
        const_str_digest_b21dca84fcf4e8562e492b36f54e621b,
#endif
        codeobj_ac03c002d6c914734a0ab63039d24303,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_00fb433b6c8f8c4e9d59bd70cd5fee15,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_65_current_user_saved_shows(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_65_current_user_saved_shows,
        const_str_plain_current_user_saved_shows,
#if PYTHON_VERSION >= 300
        const_str_digest_57bce8905b9357b4bbbeafff3c64bd6a,
#endif
        codeobj_91fb653747c37e13f8b2d9e64801a04b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_32a4ae71788e298e6b9dd987b7a52688,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_66_current_user_saved_shows_contains(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_66_current_user_saved_shows_contains,
        const_str_plain_current_user_saved_shows_contains,
#if PYTHON_VERSION >= 300
        const_str_digest_757ba791492fe0a6bb1e97e655265d19,
#endif
        codeobj_f52a04d1a853156b6ca0927a29e3e304,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_1e83f61e759b7fbea9a801cec29b5024,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_67_current_user_saved_shows_add(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_67_current_user_saved_shows_add,
        const_str_plain_current_user_saved_shows_add,
#if PYTHON_VERSION >= 300
        const_str_digest_c694d59c7b8c840b24e0bfebb7bc0d33,
#endif
        codeobj_e3486177e75618a26bbf2b5cd6036d4e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_875010cc3f8d07790f010cc5f17820c8,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_68_current_user_saved_shows_delete(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_68_current_user_saved_shows_delete,
        const_str_plain_current_user_saved_shows_delete,
#if PYTHON_VERSION >= 300
        const_str_digest_ad0cd2e91af697e20ab6ef3c064eeb24,
#endif
        codeobj_eb56fe42c9d4a9e33251b43172c33420,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_1efba7d43fe6a9ddb536f5135ef1050e,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_69_user_follow_artists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_69_user_follow_artists,
        const_str_plain_user_follow_artists,
#if PYTHON_VERSION >= 300
        const_str_digest_5fffeb0d87cae7fe6ec23be661f2fd69,
#endif
        codeobj_2ae85457f5c0b77074e133a648deb12f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_66b5be10145db796e200edc04368805f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_6__build_session() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_6__build_session,
        const_str_plain__build_session,
#if PYTHON_VERSION >= 300
        const_str_digest_a9b9b45a6cb5971d9dde9506256891bd,
#endif
        codeobj_3aea55e6c7de9115dae8ec0ba396670e,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_70_user_follow_users(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_70_user_follow_users,
        const_str_plain_user_follow_users,
#if PYTHON_VERSION >= 300
        const_str_digest_5be1b56c4c0b8911c4aba922d20a0188,
#endif
        codeobj_aca315e566868c59fcac8a4c130784fa,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_b3ea5a61b9afb9d8e21446f8f679560f,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_71_user_unfollow_artists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_71_user_unfollow_artists,
        const_str_plain_user_unfollow_artists,
#if PYTHON_VERSION >= 300
        const_str_digest_6e473efda59bed328f388eb28cfe5f4e,
#endif
        codeobj_195f6802c28d1d62bcec0d77580932c9,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2e3834ae29b14c0ccc2520a1888eb751,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_72_user_unfollow_users(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_72_user_unfollow_users,
        const_str_plain_user_unfollow_users,
#if PYTHON_VERSION >= 300
        const_str_digest_ad1b0c6365dc3c25056e3014de5caa7d,
#endif
        codeobj_6d428aa80f9c6f7f05fa23513004f374,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_b3ecf44f109d34b3e52af7f2f5b62594,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_73_featured_playlists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_73_featured_playlists,
        const_str_plain_featured_playlists,
#if PYTHON_VERSION >= 300
        const_str_digest_930d390398b95425d4ffd93f06305d01,
#endif
        codeobj_32675116669130ce76980bf99d864bad,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_c8a70ac71cb2b20e5082c1200ba03922,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_74_new_releases(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_74_new_releases,
        const_str_plain_new_releases,
#if PYTHON_VERSION >= 300
        const_str_digest_7c5b74be3ada649b49557a7869eb03b9,
#endif
        codeobj_8056a8f22b2faed7ea2b76e6f43dd588,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_d8013f6ad51769ccfee3dd58bb3f0652,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_75_categories(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_75_categories,
        const_str_plain_categories,
#if PYTHON_VERSION >= 300
        const_str_digest_391f9f64704d3a7c47cf625eccafc7c0,
#endif
        codeobj_2831de19996274756f58b6426de83d52,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_180864d7a3022e5d03259a9166cebeb6,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_76_category_playlists(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_76_category_playlists,
        const_str_plain_category_playlists,
#if PYTHON_VERSION >= 300
        const_str_digest_589d9c66020624c5607b648b0706e668,
#endif
        codeobj_147fb4f7b72cbe42d6cc16a449aa37f2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_188a1166bacfa060b47e8694a15a3090,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_77_recommendations(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_77_recommendations,
        const_str_plain_recommendations,
#if PYTHON_VERSION >= 300
        const_str_digest_51b7dd8ac0216ff3eefb41eb4578f977,
#endif
        codeobj_89b4b5423ea0ab4a62a22ab266feaff6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_2973be41c7df6ecef1d423c6cbae5728,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_78_recommendation_genre_seeds() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_78_recommendation_genre_seeds,
        const_str_plain_recommendation_genre_seeds,
#if PYTHON_VERSION >= 300
        const_str_digest_ad8a921df4ed7d5d7dfdb50bbff1b86a,
#endif
        codeobj_efc1505ed87c663bcff91271fe296d91,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_ec2e7cf9c1786efb908b0c0f264590c3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_79_audio_analysis() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_79_audio_analysis,
        const_str_plain_audio_analysis,
#if PYTHON_VERSION >= 300
        const_str_digest_4cd2fe7e56ff8b75b38406398ccf5849,
#endif
        codeobj_d9e89bd634fe62a085eca6d7aa03162b,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_85b964c01ed70f92a87af7b95815e594,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_7__auth_headers() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_7__auth_headers,
        const_str_plain__auth_headers,
#if PYTHON_VERSION >= 300
        const_str_digest_5a0f1de4f1f7388aa7e656e8bcb182b9,
#endif
        codeobj_719e84962d68d77f7a035970f69e1a9a,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_80_audio_features(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_80_audio_features,
        const_str_plain_audio_features,
#if PYTHON_VERSION >= 300
        const_str_digest_8a674a9696fb048c8df9608719462515,
#endif
        codeobj_408b682245f176e23a2c4ef692a9a3d6,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_4c12e1d5470fdec172110c6d89b8e1f3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_81_devices() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_81_devices,
        const_str_plain_devices,
#if PYTHON_VERSION >= 300
        const_str_digest_e0d1219e8a48804ba7d3a250a3f19160,
#endif
        codeobj_c8e859882515ed15aeb5b23f99d36210,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_f416654f39bbd99bbde9721618eb36fd,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_82_current_playback(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_82_current_playback,
        const_str_plain_current_playback,
#if PYTHON_VERSION >= 300
        const_str_digest_fce8e7d40ad236922eb432562db251e4,
#endif
        codeobj_930beb42264bc52c118db28d3d84c5e2,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_ad86a189ebf14691511cbd1323b36137,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_83_currently_playing(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_83_currently_playing,
        const_str_plain_currently_playing,
#if PYTHON_VERSION >= 300
        const_str_digest_9254db74895e65fc859713643b2ed8ae,
#endif
        codeobj_f5900a135869b2c725abedc03985587c,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_19ca16d6b65b3385e7e95a982e32ddeb,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_84_transfer_playback(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_84_transfer_playback,
        const_str_plain_transfer_playback,
#if PYTHON_VERSION >= 300
        const_str_digest_f0e0d92a883a0d37afc5c36db66989d0,
#endif
        codeobj_fbf262121f91f3804d33b3044803566e,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_52a058966bc59abea536c1108c5ed4b1,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_85_start_playback(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_85_start_playback,
        const_str_plain_start_playback,
#if PYTHON_VERSION >= 300
        const_str_digest_ba8367de31b2273f9e2a709972d2a97c,
#endif
        codeobj_d05adab5b849556bfc3129c4f25b24f3,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_dc236d8b13fa2bcf6bf5c872ea44aaa2,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_86_pause_playback(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_86_pause_playback,
        const_str_plain_pause_playback,
#if PYTHON_VERSION >= 300
        const_str_digest_b89a24c0a3cc4571b4b02536ba3d2fd4,
#endif
        codeobj_1fa718cf358c88654ca12b337f3c6d81,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_f309ed4485e7bd297d91d86c0feee8f3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_87_next_track(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_87_next_track,
        const_str_plain_next_track,
#if PYTHON_VERSION >= 300
        const_str_digest_6bda413d1a4d6e15ff4de52373c1a00e,
#endif
        codeobj_94ab4af3524bbcdc411d25898f593b22,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_44d4f41b8805ad55f08f3244d0e3b445,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_88_previous_track(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_88_previous_track,
        const_str_plain_previous_track,
#if PYTHON_VERSION >= 300
        const_str_digest_2ae13eed670f9290bb0c4f0c9875dd03,
#endif
        codeobj_96b38d14a37200870473c9c6e70b2bbc,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_787903cd874d847847a2eb2ef416f6c3,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_89_seek_track(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_89_seek_track,
        const_str_plain_seek_track,
#if PYTHON_VERSION >= 300
        const_str_digest_24c4dd15df6ed2447b60cca67615bd7b,
#endif
        codeobj_68970f99ee773eb7d9442246d4c73a29,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_a3c47fe9db46a4cbfc5719fa2ef262a7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_8__internal_call() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_8__internal_call,
        const_str_plain__internal_call,
#if PYTHON_VERSION >= 300
        const_str_digest_ab8a4dee974a2c8d40c89f0c65db03e5,
#endif
        codeobj_495194454ffc762d87d48093ed2144a7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_90_repeat(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_90_repeat,
        const_str_plain_repeat,
#if PYTHON_VERSION >= 300
        const_str_digest_19a37dfa2366a4f037bdcf195f572705,
#endif
        codeobj_ea0bda7a95b207898acca58f06ef419f,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_04a9401e879dd7f163ef999a3d8c8737,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_91_volume(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_91_volume,
        const_str_plain_volume,
#if PYTHON_VERSION >= 300
        const_str_digest_fcff0159a761cd6996e868984e5eb286,
#endif
        codeobj_efc2fdaf980f974e85adba56eab74e1d,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_1668a40f9d67d62504803c85c35ad2c7,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_92_shuffle(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_92_shuffle,
        const_str_plain_shuffle,
#if PYTHON_VERSION >= 300
        const_str_digest_65c509e2a4b059c00782449ebd31f314,
#endif
        codeobj_06b012069081bb35b69567ff4444dae3,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_5a23bff0529b8d304971c75ac5c0c642,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_93_add_to_queue(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_93_add_to_queue,
        const_str_plain_add_to_queue,
#if PYTHON_VERSION >= 300
        const_str_digest_bc9ddd864c719d358505256c02db1172,
#endif
        codeobj_5a1a0089bd1a7cb13169e5d9f0339c3b,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_329cc980f9b9d0864824ea93bbfb8a73,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_94__append_device_id() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_94__append_device_id,
        const_str_plain__append_device_id,
#if PYTHON_VERSION >= 300
        const_str_digest_54e4b558d0d0cb3a69eebc739356fc4d,
#endif
        codeobj_e3c0461f1c8bf2eb2a8c340eb6135f8c,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        const_str_digest_131c4d8f12787eb624dbe9d8626d17ce,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_95__get_id() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_95__get_id,
        const_str_plain__get_id,
#if PYTHON_VERSION >= 300
        const_str_digest_fcd3a7c6c8bc32050163417ad987af39,
#endif
        codeobj_419205c4be40b315ea5fe17707529d4d,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_96__get_uri() {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_96__get_uri,
        const_str_plain__get_uri,
#if PYTHON_VERSION >= 300
        const_str_digest_1e1ba398d96e94b69ce683dfb2e1f429,
#endif
        codeobj_302c0a2001e73a2f203141af602952e7,
        NULL,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}



static PyObject *MAKE_FUNCTION_spotipy$client$$$function_9__get(PyObject *defaults) {
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        impl_spotipy$client$$$function_9__get,
        const_str_plain__get,
#if PYTHON_VERSION >= 300
        const_str_digest_3d01ef8d22d715e36161185be7af38c8,
#endif
        codeobj_2ca5dd22ca3a8bc538a80cd11b80d295,
        defaults,
#if PYTHON_VERSION >= 300
        NULL,
        NULL,
#endif
        module_spotipy$client,
        NULL,
        0
    );

    return (PyObject *)result;
}


extern PyObject *const_str_plain___compiled__;

extern PyObject *const_str_plain___package__;
extern PyObject *const_str_empty;

#if PYTHON_VERSION >= 300
extern PyObject *const_str_dot;
extern PyObject *const_str_plain___loader__;
#endif

#if PYTHON_VERSION >= 340
extern PyObject *const_str_plain___spec__;
extern PyObject *const_str_plain__initializing;
extern PyObject *const_str_plain_submodule_search_locations;
#endif

extern void _initCompiledCellType();
extern void _initCompiledGeneratorType();
extern void _initCompiledFunctionType();
extern void _initCompiledMethodType();
extern void _initCompiledFrameType();

extern PyTypeObject Nuitka_Loader_Type;

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
// Provide a way to create find a function via its C code and create it back
// in another process, useful for multiprocessing extensions like dill

function_impl_code functable_spotipy$client[] = {
    impl_spotipy$client$$$function_1___init__,
    impl_spotipy$client$$$function_2_set_auth,
    impl_spotipy$client$$$function_3_auth_manager,
    impl_spotipy$client$$$function_4_auth_manager,
    impl_spotipy$client$$$function_5___del__,
    impl_spotipy$client$$$function_6__build_session,
    impl_spotipy$client$$$function_7__auth_headers,
    impl_spotipy$client$$$function_8__internal_call,
    impl_spotipy$client$$$function_9__get,
    impl_spotipy$client$$$function_10__post,
    impl_spotipy$client$$$function_11__delete,
    impl_spotipy$client$$$function_12__put,
    impl_spotipy$client$$$function_13_next,
    impl_spotipy$client$$$function_14_previous,
    impl_spotipy$client$$$function_15_track,
    impl_spotipy$client$$$function_16_tracks,
    impl_spotipy$client$$$function_17_artist,
    impl_spotipy$client$$$function_18_artists,
    impl_spotipy$client$$$function_19_artist_albums,
    impl_spotipy$client$$$function_20_artist_top_tracks,
    impl_spotipy$client$$$function_21_artist_related_artists,
    impl_spotipy$client$$$function_22_album,
    impl_spotipy$client$$$function_23_album_tracks,
    impl_spotipy$client$$$function_24_albums,
    impl_spotipy$client$$$function_25_show,
    impl_spotipy$client$$$function_26_shows,
    impl_spotipy$client$$$function_27_show_episodes,
    impl_spotipy$client$$$function_28_episode,
    impl_spotipy$client$$$function_29_episodes,
    impl_spotipy$client$$$function_30_search,
    impl_spotipy$client$$$function_31_user,
    impl_spotipy$client$$$function_32_current_user_playlists,
    impl_spotipy$client$$$function_33_playlist,
    impl_spotipy$client$$$function_34_playlist_tracks,
    impl_spotipy$client$$$function_35_playlist_cover_image,
    impl_spotipy$client$$$function_36_playlist_upload_cover_image,
    impl_spotipy$client$$$function_37_user_playlist,
    impl_spotipy$client$$$function_38_user_playlist_tracks,
    impl_spotipy$client$$$function_39_user_playlists,
    impl_spotipy$client$$$function_40_user_playlist_create,
    impl_spotipy$client$$$function_41_user_playlist_change_details,
    impl_spotipy$client$$$function_42_user_playlist_unfollow,
    impl_spotipy$client$$$function_43_user_playlist_add_tracks,
    impl_spotipy$client$$$function_44_user_playlist_replace_tracks,
    impl_spotipy$client$$$function_45_user_playlist_reorder_tracks,
    impl_spotipy$client$$$function_46_user_playlist_remove_all_occurrences_of_tracks,
    impl_spotipy$client$$$function_47_user_playlist_remove_specific_occurrences_of_tracks,
    impl_spotipy$client$$$function_48_user_playlist_follow_playlist,
    impl_spotipy$client$$$function_49_user_playlist_is_following,
    impl_spotipy$client$$$function_50_me,
    impl_spotipy$client$$$function_51_current_user,
    impl_spotipy$client$$$function_52_current_user_playing_track,
    impl_spotipy$client$$$function_53_current_user_saved_tracks,
    impl_spotipy$client$$$function_54_current_user_followed_artists,
    impl_spotipy$client$$$function_55_current_user_saved_tracks_delete,
    impl_spotipy$client$$$function_56_current_user_saved_tracks_contains,
    impl_spotipy$client$$$function_57_current_user_saved_tracks_add,
    impl_spotipy$client$$$function_58_current_user_top_artists,
    impl_spotipy$client$$$function_59_current_user_top_tracks,
    impl_spotipy$client$$$function_60_current_user_recently_played,
    impl_spotipy$client$$$function_61_current_user_saved_albums,
    impl_spotipy$client$$$function_62_current_user_saved_albums_contains,
    impl_spotipy$client$$$function_63_current_user_saved_albums_add,
    impl_spotipy$client$$$function_64_current_user_saved_albums_delete,
    impl_spotipy$client$$$function_65_current_user_saved_shows,
    impl_spotipy$client$$$function_66_current_user_saved_shows_contains,
    impl_spotipy$client$$$function_67_current_user_saved_shows_add,
    impl_spotipy$client$$$function_68_current_user_saved_shows_delete,
    impl_spotipy$client$$$function_69_user_follow_artists,
    impl_spotipy$client$$$function_70_user_follow_users,
    impl_spotipy$client$$$function_71_user_unfollow_artists,
    impl_spotipy$client$$$function_72_user_unfollow_users,
    impl_spotipy$client$$$function_73_featured_playlists,
    impl_spotipy$client$$$function_74_new_releases,
    impl_spotipy$client$$$function_75_categories,
    impl_spotipy$client$$$function_76_category_playlists,
    impl_spotipy$client$$$function_77_recommendations,
    impl_spotipy$client$$$function_78_recommendation_genre_seeds,
    impl_spotipy$client$$$function_79_audio_analysis,
    impl_spotipy$client$$$function_80_audio_features,
    impl_spotipy$client$$$function_81_devices,
    impl_spotipy$client$$$function_82_current_playback,
    impl_spotipy$client$$$function_83_currently_playing,
    impl_spotipy$client$$$function_84_transfer_playback,
    impl_spotipy$client$$$function_85_start_playback,
    impl_spotipy$client$$$function_86_pause_playback,
    impl_spotipy$client$$$function_87_next_track,
    impl_spotipy$client$$$function_88_previous_track,
    impl_spotipy$client$$$function_89_seek_track,
    impl_spotipy$client$$$function_90_repeat,
    impl_spotipy$client$$$function_91_volume,
    impl_spotipy$client$$$function_92_shuffle,
    impl_spotipy$client$$$function_93_add_to_queue,
    impl_spotipy$client$$$function_94__append_device_id,
    impl_spotipy$client$$$function_95__get_id,
    impl_spotipy$client$$$function_96__get_uri,
    NULL
};

static char const *_reduce_compiled_function_argnames[] = {
    "func",
    NULL
};

static PyObject *_reduce_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    PyObject *func;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "O:reduce_compiled_function", (char **)_reduce_compiled_function_argnames, &func, NULL)) {
        return NULL;
    }

    if (Nuitka_Function_Check(func) == false) {
        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "not a compiled function");
        return NULL;
    }

    struct Nuitka_FunctionObject *function = (struct Nuitka_FunctionObject *)func;

    function_impl_code *current = functable_spotipy$client;
    int offset = 0;

    while (*current != NULL) {
        if (*current == function->m_c_code) {
            break;
        }

        current += 1;
        offset += 1;
    }

    if (*current == NULL) {
        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "Cannot find compiled function in module.");
        return NULL;
    }

    PyObject *code_object_desc = PyTuple_New(6);
    PyTuple_SET_ITEM0(code_object_desc, 0, function->m_code_object->co_filename);
    PyTuple_SET_ITEM0(code_object_desc, 1, function->m_code_object->co_name);
    PyTuple_SET_ITEM(code_object_desc, 2, PyLong_FromLong(function->m_code_object->co_firstlineno));
    PyTuple_SET_ITEM0(code_object_desc, 3, function->m_code_object->co_varnames);
    PyTuple_SET_ITEM(code_object_desc, 4, PyLong_FromLong(function->m_code_object->co_argcount));
    PyTuple_SET_ITEM(code_object_desc, 5, PyLong_FromLong(function->m_code_object->co_flags));

    CHECK_OBJECT_DEEP(code_object_desc);

    PyObject *result = PyTuple_New(4);
    PyTuple_SET_ITEM(result, 0, PyLong_FromLong(offset));
    PyTuple_SET_ITEM(result, 1, code_object_desc);
    PyTuple_SET_ITEM0(result, 2, function->m_defaults);
    PyTuple_SET_ITEM0(result, 3, function->m_doc != NULL ? function->m_doc : Py_None);

    CHECK_OBJECT_DEEP(result);

    return result;
}

static PyMethodDef _method_def_reduce_compiled_function = {"reduce_compiled_function", (PyCFunction)_reduce_compiled_function,
                                                           METH_VARARGS | METH_KEYWORDS, NULL};

static char const *_create_compiled_function_argnames[] = {
    "func",
    "code_object_desc",
    "defaults",
    "doc",
    NULL
};


static PyObject *_create_compiled_function(PyObject *self, PyObject *args, PyObject *kwds) {
    CHECK_OBJECT_DEEP(args);

    PyObject *func;
    PyObject *code_object_desc;
    PyObject *defaults;
    PyObject *doc;

    if (!PyArg_ParseTupleAndKeywords(args, kwds, "OOOO:create_compiled_function", (char **)_create_compiled_function_argnames, &func, &code_object_desc, &defaults, &doc, NULL)) {
        return NULL;
    }

    int offset = PyLong_AsLong(func);

    if (offset == -1 && ERROR_OCCURRED()) {
        return NULL;
    }

    if (offset > sizeof(functable_spotipy$client) || offset < 0) {
        SET_CURRENT_EXCEPTION_TYPE0_STR(PyExc_TypeError, "Wrong offset for compiled function.");
        return NULL;
    }

    PyObject *filename = PyTuple_GET_ITEM(code_object_desc, 0);
    PyObject *function_name = PyTuple_GET_ITEM(code_object_desc, 1);
    PyObject *line = PyTuple_GET_ITEM(code_object_desc, 2);
    int line_int = PyLong_AsLong(line);
    assert(!ERROR_OCCURRED());

    PyObject *argnames = PyTuple_GET_ITEM(code_object_desc, 3);
    PyObject *arg_count = PyTuple_GET_ITEM(code_object_desc, 4);
    int arg_count_int = PyLong_AsLong(arg_count);
    assert(!ERROR_OCCURRED());
    PyObject *flags = PyTuple_GET_ITEM(code_object_desc, 5);
    int flags_int = PyLong_AsLong(flags);
    assert(!ERROR_OCCURRED());

    PyCodeObject *code_object = MAKE_CODEOBJECT(
        filename,
        line_int,
        flags_int,
        function_name,
        argnames,
        arg_count_int,
        0, // TODO: Missing kw_only_count
        0 // TODO: Missing pos_only_count
    );

    // TODO: More stuff needed for Python3, best to re-order arguments of MAKE_CODEOBJECT.
    struct Nuitka_FunctionObject *result = Nuitka_Function_New(
        functable_spotipy$client[offset],
        code_object->co_name,
#if PYTHON_VERSION >= 300
        NULL, // TODO: Not transferring qualname yet
#endif
        code_object,
        defaults,
#if PYTHON_VERSION >= 300
        NULL, // kwdefaults are done on the outside currently
        NULL, // TODO: Not transferring annotations
#endif
        module_spotipy$client,
        doc,
        0
    );

    return (PyObject *)result;
}

static PyMethodDef _method_def_create_compiled_function = {
    "create_compiled_function",
    (PyCFunction)_create_compiled_function,
    METH_VARARGS | METH_KEYWORDS, NULL
};


#endif

// Internal entry point for module code.
PyObject *modulecode_spotipy$client(PyObject *module) {
    module_spotipy$client = module;

#if defined(_NUITKA_EXE) || PYTHON_VERSION >= 300
    static bool _init_done = false;

    // Modules might be imported repeatedly, which is to be ignored.
    if (_init_done) {
        return module_spotipy$client;
    } else {
        _init_done = true;
    }
#endif

#ifdef _NUITKA_MODULE
    // In case of a stand alone extension module, need to call initialization
    // the init here because that's the first and only time we are going to get
    // called here.

    // May have to activate constants blob.
#if defined(_NUITKA_CONSTANTS_FROM_RESOURCE)
    loadConstantsResource();
#endif

    // Initialize the constant values used.
    _initBuiltinModule();
    createGlobalConstants();

    /* Initialize the compiled types of Nuitka. */
    _initCompiledCellType();
    _initCompiledGeneratorType();
    _initCompiledFunctionType();
    _initCompiledMethodType();
    _initCompiledFrameType();

#if PYTHON_VERSION < 300
    _initSlotCompare();
#endif
#if PYTHON_VERSION >= 270
    _initSlotIternext();
#endif

    patchBuiltinModule();
    patchTypeComparison();

    // Enable meta path based loader if not already done.
#ifdef _NUITKA_TRACE
    PRINT_STRING("spotipy.client: Calling setupMetaPathBasedLoader().\n");
#endif
    setupMetaPathBasedLoader();

#if PYTHON_VERSION >= 300
    patchInspectModule();
#endif

#endif

    /* The constants only used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("spotipy.client: Calling createModuleConstants().\n");
#endif
    createModuleConstants();

    /* The code objects used by this module are created now. */
#ifdef _NUITKA_TRACE
    PRINT_STRING("spotipy.client: Calling createModuleCodeObjects().\n");
#endif
    createModuleCodeObjects();

    // PRINT_STRING("in initspotipy$client\n");

    // Create the module object first. There are no methods initially, all are
    // added dynamically in actual code only.  Also no "__doc__" is initially
    // set at this time, as it could not contain NUL characters this way, they
    // are instead set in early module code.  No "self" for modules, we have no
    // use for it.

    moduledict_spotipy$client = MODULE_DICT(module_spotipy$client);

#ifdef _NUITKA_PLUGIN_DILL_ENABLED
    {
        PyObject *function_tables = PyObject_GetAttrString((PyObject *)builtin_module, "compiled_function_tables");
        if (function_tables == NULL)
        {
            DROP_ERROR_OCCURRED();
            function_tables = PyDict_New();
        }
        PyObject_SetAttrString((PyObject *)builtin_module, "compiled_function_tables", function_tables);
        PyObject *funcs = PyTuple_New(2);
        PyTuple_SET_ITEM(funcs, 0, PyCFunction_New(&_method_def_reduce_compiled_function, NULL));
        PyTuple_SET_ITEM(funcs, 1, PyCFunction_New(&_method_def_create_compiled_function, NULL));
        PyDict_SetItemString(function_tables, module_full_name, funcs);
    }
#endif

    // Set "__compiled__" to what version information we have.
    UPDATE_STRING_DICT0(
        moduledict_spotipy$client,
        (Nuitka_StringObject *)const_str_plain___compiled__,
        Nuitka_dunder_compiled_value
    );

    // Update "__package__" value to what it ought to be.
    {
#if 0
        UPDATE_STRING_DICT0(
            moduledict_spotipy$client,
            (Nuitka_StringObject *)const_str_plain___package__,
            const_str_empty
        );
#elif 0
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___name__);

        UPDATE_STRING_DICT0(
            moduledict_spotipy$client,
            (Nuitka_StringObject *)const_str_plain___package__,
            module_name
        );
#else

#if PYTHON_VERSION < 300
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___name__);
        char const *module_name_cstr = PyString_AS_STRING(module_name);

        char const *last_dot = strrchr(module_name_cstr, '.');

        if (last_dot != NULL)
        {
            UPDATE_STRING_DICT1(
                moduledict_spotipy$client,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyString_FromStringAndSize(module_name_cstr, last_dot - module_name_cstr)
            );
        }
#else
        PyObject *module_name = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___name__);
        Py_ssize_t dot_index = PyUnicode_Find(module_name, const_str_dot, 0, PyUnicode_GetLength(module_name), -1);

        if (dot_index != -1)
        {
            UPDATE_STRING_DICT1(
                moduledict_spotipy$client,
                (Nuitka_StringObject *)const_str_plain___package__,
                PyUnicode_Substring(module_name, 0, dot_index)
            );
        }
#endif
#endif
    }

    CHECK_OBJECT(module_spotipy$client);

    // For deep importing of a module we need to have "__builtins__", so we set
    // it ourselves in the same way than CPython does. Note: This must be done
    // before the frame object is allocated, or else it may fail.

    if (GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___builtins__) == NULL)
    {
        PyObject *value = (PyObject *)builtin_module;

        // Check if main module, not a dict then but the module itself.
#if !defined(_NUITKA_EXE) || !0
        value = PyModule_GetDict(value);
#endif

        UPDATE_STRING_DICT0(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___builtins__, value);
    }

#if PYTHON_VERSION >= 300
    UPDATE_STRING_DICT0(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___loader__, (PyObject *)&Nuitka_Loader_Type);
#endif

#if PYTHON_VERSION >= 340
// Set the "__spec__" value

#if 0
    // Main modules just get "None" as spec.
    UPDATE_STRING_DICT0(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___spec__, Py_None);
#else
    // Other modules get a "ModuleSpec" from the standard mechanism.
    {
        PyObject *bootstrap_module = PyImport_ImportModule("importlib._bootstrap");
        CHECK_OBJECT(bootstrap_module);
        PyObject *module_spec_class = PyObject_GetAttrString(bootstrap_module, "ModuleSpec");
        Py_DECREF(bootstrap_module);

        PyObject *args[] = {
            GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___name__),
            (PyObject *)&Nuitka_Loader_Type
        };

        PyObject *spec_value = CALL_FUNCTION_WITH_ARGS2(
            module_spec_class,
            args
        );
        Py_DECREF(module_spec_class);

        // We can assume this to never fail, or else we are in trouble anyway.
        CHECK_OBJECT(spec_value);

// For packages set the submodule search locations as well, even if to empty
// list, so investigating code will consider it a package.
#if 0
        SET_ATTRIBUTE(spec_value, const_str_plain_submodule_search_locations, PyList_New(0));
#endif

// Mark the execution in the "__spec__" value.
        SET_ATTRIBUTE(spec_value, const_str_plain__initializing, Py_True);

        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___spec__, spec_value);
    }
#endif
#endif

    // Temp variables if any
    PyObject *outline_0_var___class__ = NULL;
    PyObject *tmp_class_creation_1__bases = NULL;
    PyObject *tmp_class_creation_1__class_decl_dict = NULL;
    PyObject *tmp_class_creation_1__metaclass = NULL;
    PyObject *tmp_class_creation_1__prepared = NULL;
    struct Nuitka_FrameObject *frame_73c68707901485c856bd6798b6ebb929;
    NUITKA_MAY_BE_UNUSED char const *type_description_1 = NULL;
    bool tmp_result;
    PyObject *exception_type = NULL;
    PyObject *exception_value = NULL;
    PyTracebackObject *exception_tb = NULL;
    NUITKA_MAY_BE_UNUSED int exception_lineno = 0;
    int tmp_res;
    PyObject *tmp_dictdel_dict;
    PyObject *tmp_dictdel_key;
    PyObject *locals_spotipy$client_20 = NULL;
    PyObject *tmp_dictset_value;
    struct Nuitka_FrameObject *frame_624df6905d3bc9676105aeac478b5f31_2;
    NUITKA_MAY_BE_UNUSED char const *type_description_2 = NULL;
    static struct Nuitka_FrameObject *cache_frame_624df6905d3bc9676105aeac478b5f31_2 = NULL;
    PyObject *exception_keeper_type_1;
    PyObject *exception_keeper_value_1;
    PyTracebackObject *exception_keeper_tb_1;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_1;
    PyObject *exception_keeper_type_2;
    PyObject *exception_keeper_value_2;
    PyTracebackObject *exception_keeper_tb_2;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_2;
    PyObject *exception_keeper_type_3;
    PyObject *exception_keeper_value_3;
    PyTracebackObject *exception_keeper_tb_3;
    NUITKA_MAY_BE_UNUSED int exception_keeper_lineno_3;

    // Module code.
    {
        PyObject *tmp_assign_source_1;
        tmp_assign_source_1 = const_str_digest_98b1ec6a4ee97b8abcc611c4f94337a4;
        UPDATE_STRING_DICT0(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___doc__, tmp_assign_source_1);
    }
    {
        PyObject *tmp_assign_source_2;
        tmp_assign_source_2 = const_str_digest_a9e497a69e6698a5ac0200bc3be01588;
        UPDATE_STRING_DICT0(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___file__, tmp_assign_source_2);
    }
    // Frame without reuse.
    frame_73c68707901485c856bd6798b6ebb929 = MAKE_MODULE_FRAME(codeobj_73c68707901485c856bd6798b6ebb929, module_spotipy$client);

    // Push the new frame as the currently active one, and we should be exclusively
    // owning it.
    pushFrameStack(frame_73c68707901485c856bd6798b6ebb929);
    assert(Py_REFCNT(frame_73c68707901485c856bd6798b6ebb929) == 2);

    // Framed code:
    {
        PyObject *tmp_assattr_name_1;
        PyObject *tmp_assattr_target_1;
        PyObject *tmp_mvar_value_1;
        tmp_assattr_name_1 = const_str_digest_a9e497a69e6698a5ac0200bc3be01588;
        tmp_mvar_value_1 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___spec__);

        if (unlikely(tmp_mvar_value_1 == NULL)) {
            tmp_mvar_value_1 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__);
        }

        CHECK_OBJECT(tmp_mvar_value_1);
        tmp_assattr_target_1 = tmp_mvar_value_1;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_1, const_str_plain_origin, tmp_assattr_name_1);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assattr_name_2;
        PyObject *tmp_assattr_target_2;
        PyObject *tmp_mvar_value_2;
        tmp_assattr_name_2 = Py_True;
        tmp_mvar_value_2 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___spec__);

        if (unlikely(tmp_mvar_value_2 == NULL)) {
            tmp_mvar_value_2 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain___spec__);
        }

        CHECK_OBJECT(tmp_mvar_value_2);
        tmp_assattr_target_2 = tmp_mvar_value_2;
        tmp_result = SET_ATTRIBUTE(tmp_assattr_target_2, const_str_plain_has_location, tmp_assattr_name_2);
        if (tmp_result == false) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1;

            goto frame_exception_exit_1;
        }
    }
    {
        PyObject *tmp_assign_source_3;
        tmp_assign_source_3 = Py_None;
        UPDATE_STRING_DICT0(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___cached__, tmp_assign_source_3);
    }
    {
        PyObject *tmp_assign_source_4;
        tmp_assign_source_4 = LIST_COPY(const_list_str_plain_Spotify_str_plain_SpotifyException_list);
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain___all__, tmp_assign_source_4);
    }
    {
        PyObject *tmp_assign_source_5;
        PyObject *tmp_name_name_1;
        PyObject *tmp_globals_name_1;
        PyObject *tmp_locals_name_1;
        PyObject *tmp_fromlist_name_1;
        PyObject *tmp_level_name_1;
        tmp_name_name_1 = const_str_plain_json;
        tmp_globals_name_1 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_1 = Py_None;
        tmp_fromlist_name_1 = Py_None;
        tmp_level_name_1 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 7;
        tmp_assign_source_5 = IMPORT_MODULE5(tmp_name_name_1, tmp_globals_name_1, tmp_locals_name_1, tmp_fromlist_name_1, tmp_level_name_1);
        if (tmp_assign_source_5 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 7;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_json, tmp_assign_source_5);
    }
    {
        PyObject *tmp_assign_source_6;
        PyObject *tmp_name_name_2;
        PyObject *tmp_globals_name_2;
        PyObject *tmp_locals_name_2;
        PyObject *tmp_fromlist_name_2;
        PyObject *tmp_level_name_2;
        tmp_name_name_2 = const_str_plain_logging;
        tmp_globals_name_2 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_2 = Py_None;
        tmp_fromlist_name_2 = Py_None;
        tmp_level_name_2 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 8;
        tmp_assign_source_6 = IMPORT_MODULE5(tmp_name_name_2, tmp_globals_name_2, tmp_locals_name_2, tmp_fromlist_name_2, tmp_level_name_2);
        if (tmp_assign_source_6 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 8;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logging, tmp_assign_source_6);
    }
    {
        PyObject *tmp_assign_source_7;
        PyObject *tmp_name_name_3;
        PyObject *tmp_globals_name_3;
        PyObject *tmp_locals_name_3;
        PyObject *tmp_fromlist_name_3;
        PyObject *tmp_level_name_3;
        tmp_name_name_3 = const_str_plain_warnings;
        tmp_globals_name_3 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_3 = Py_None;
        tmp_fromlist_name_3 = Py_None;
        tmp_level_name_3 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 9;
        tmp_assign_source_7 = IMPORT_MODULE5(tmp_name_name_3, tmp_globals_name_3, tmp_locals_name_3, tmp_fromlist_name_3, tmp_level_name_3);
        if (tmp_assign_source_7 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 9;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_warnings, tmp_assign_source_7);
    }
    {
        PyObject *tmp_assign_source_8;
        PyObject *tmp_name_name_4;
        PyObject *tmp_globals_name_4;
        PyObject *tmp_locals_name_4;
        PyObject *tmp_fromlist_name_4;
        PyObject *tmp_level_name_4;
        tmp_name_name_4 = const_str_plain_requests;
        tmp_globals_name_4 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_4 = Py_None;
        tmp_fromlist_name_4 = Py_None;
        tmp_level_name_4 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 11;
        tmp_assign_source_8 = IMPORT_MODULE5(tmp_name_name_4, tmp_globals_name_4, tmp_locals_name_4, tmp_fromlist_name_4, tmp_level_name_4);
        if (tmp_assign_source_8 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 11;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_requests, tmp_assign_source_8);
    }
    {
        PyObject *tmp_assign_source_9;
        PyObject *tmp_name_name_5;
        PyObject *tmp_globals_name_5;
        PyObject *tmp_locals_name_5;
        PyObject *tmp_fromlist_name_5;
        PyObject *tmp_level_name_5;
        tmp_name_name_5 = const_str_plain_urllib3;
        tmp_globals_name_5 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_5 = Py_None;
        tmp_fromlist_name_5 = Py_None;
        tmp_level_name_5 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 12;
        tmp_assign_source_9 = IMPORT_MODULE5(tmp_name_name_5, tmp_globals_name_5, tmp_locals_name_5, tmp_fromlist_name_5, tmp_level_name_5);
        if (tmp_assign_source_9 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 12;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_urllib3, tmp_assign_source_9);
    }
    {
        PyObject *tmp_assign_source_10;
        PyObject *tmp_name_name_6;
        PyObject *tmp_globals_name_6;
        PyObject *tmp_locals_name_6;
        PyObject *tmp_fromlist_name_6;
        PyObject *tmp_level_name_6;
        tmp_name_name_6 = const_str_plain_six;
        tmp_globals_name_6 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_6 = Py_None;
        tmp_fromlist_name_6 = Py_None;
        tmp_level_name_6 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 13;
        tmp_assign_source_10 = IMPORT_MODULE5(tmp_name_name_6, tmp_globals_name_6, tmp_locals_name_6, tmp_fromlist_name_6, tmp_level_name_6);
        if (tmp_assign_source_10 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 13;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_six, tmp_assign_source_10);
    }
    {
        PyObject *tmp_assign_source_11;
        PyObject *tmp_import_name_from_1;
        PyObject *tmp_name_name_7;
        PyObject *tmp_globals_name_7;
        PyObject *tmp_locals_name_7;
        PyObject *tmp_fromlist_name_7;
        PyObject *tmp_level_name_7;
        tmp_name_name_7 = const_str_digest_9b53e2759f78e025448df529ac650919;
        tmp_globals_name_7 = (PyObject *)moduledict_spotipy$client;
        tmp_locals_name_7 = Py_None;
        tmp_fromlist_name_7 = const_tuple_str_plain_SpotifyException_tuple;
        tmp_level_name_7 = const_int_0;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 15;
        tmp_import_name_from_1 = IMPORT_MODULE5(tmp_name_name_7, tmp_globals_name_7, tmp_locals_name_7, tmp_fromlist_name_7, tmp_level_name_7);
        if (tmp_import_name_from_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto frame_exception_exit_1;
        }
        if (PyModule_Check(tmp_import_name_from_1)) {
           tmp_assign_source_11 = IMPORT_NAME_OR_MODULE(
                tmp_import_name_from_1,
                (PyObject *)moduledict_spotipy$client,
                const_str_plain_SpotifyException,
                const_int_0
            );
        } else {
           tmp_assign_source_11 = IMPORT_NAME(tmp_import_name_from_1, const_str_plain_SpotifyException);
        }

        Py_DECREF(tmp_import_name_from_1);
        if (tmp_assign_source_11 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 15;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_SpotifyException, tmp_assign_source_11);
    }
    {
        PyObject *tmp_assign_source_12;
        PyObject *tmp_called_instance_1;
        PyObject *tmp_mvar_value_3;
        tmp_mvar_value_3 = GET_STRING_DICT_VALUE(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logging);

        if (unlikely(tmp_mvar_value_3 == NULL)) {
            tmp_mvar_value_3 = GET_STRING_DICT_VALUE(dict_builtin, (Nuitka_StringObject *)const_str_plain_logging);
        }

        if (tmp_mvar_value_3 == NULL) {

            exception_type = PyExc_NameError;
            Py_INCREF(exception_type);
            exception_value = UNSTREAM_STRING(&constant_bin[ 2085 ], 29, 0);
            exception_tb = NULL;
            NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
            CHAIN_EXCEPTION(exception_value);

            exception_lineno = 17;

            goto frame_exception_exit_1;
        }

        tmp_called_instance_1 = tmp_mvar_value_3;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 17;
        tmp_assign_source_12 = CALL_METHOD_WITH_ARGS1(tmp_called_instance_1, const_str_plain_getLogger, &PyTuple_GET_ITEM(const_tuple_str_digest_453d9a13f190051d0fb607026b4faf41_tuple, 0));

        if (tmp_assign_source_12 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 17;

            goto frame_exception_exit_1;
        }
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_logger, tmp_assign_source_12);
    }
    // Tried code:
    {
        PyObject *tmp_assign_source_13;
        PyObject *tmp_dircall_arg1_1;
        tmp_dircall_arg1_1 = const_tuple_type_object_tuple;
        Py_INCREF(tmp_dircall_arg1_1);

        {
            PyObject *dir_call_args[] = {tmp_dircall_arg1_1};
            tmp_assign_source_13 = impl___internal__$$$function_4__mro_entries_conversion(dir_call_args);
        }
        if (tmp_assign_source_13 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        assert(tmp_class_creation_1__bases == NULL);
        tmp_class_creation_1__bases = tmp_assign_source_13;
    }
    {
        PyObject *tmp_assign_source_14;
        tmp_assign_source_14 = PyDict_New();
        assert(tmp_class_creation_1__class_decl_dict == NULL);
        tmp_class_creation_1__class_decl_dict = tmp_assign_source_14;
    }
    {
        PyObject *tmp_assign_source_15;
        PyObject *tmp_metaclass_name_1;
        nuitka_bool tmp_condition_result_1;
        PyObject *tmp_key_name_1;
        PyObject *tmp_dict_name_1;
        PyObject *tmp_dict_name_2;
        PyObject *tmp_key_name_2;
        nuitka_bool tmp_condition_result_2;
        int tmp_truth_name_1;
        PyObject *tmp_type_arg_1;
        PyObject *tmp_expression_name_1;
        PyObject *tmp_subscript_name_1;
        PyObject *tmp_bases_name_1;
        tmp_key_name_1 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dict_name_1 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_1, tmp_key_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_condition_result_1 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_1 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_1;
        } else {
            goto condexpr_false_1;
        }
        condexpr_true_1:;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dict_name_2 = tmp_class_creation_1__class_decl_dict;
        tmp_key_name_2 = const_str_plain_metaclass;
        tmp_metaclass_name_1 = DICT_GET_ITEM(tmp_dict_name_2, tmp_key_name_2);
        if (tmp_metaclass_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        goto condexpr_end_1;
        condexpr_false_1:;
        CHECK_OBJECT(tmp_class_creation_1__bases);
        tmp_truth_name_1 = CHECK_IF_TRUE(tmp_class_creation_1__bases);
        if (tmp_truth_name_1 == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_condition_result_2 = tmp_truth_name_1 == 1 ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_2 == NUITKA_BOOL_TRUE) {
            goto condexpr_true_2;
        } else {
            goto condexpr_false_2;
        }
        condexpr_true_2:;
        CHECK_OBJECT(tmp_class_creation_1__bases);
        tmp_expression_name_1 = tmp_class_creation_1__bases;
        tmp_subscript_name_1 = const_int_0;
        tmp_type_arg_1 = LOOKUP_SUBSCRIPT_CONST(tmp_expression_name_1, tmp_subscript_name_1, 0);
        if (tmp_type_arg_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_metaclass_name_1 = BUILTIN_TYPE1(tmp_type_arg_1);
        Py_DECREF(tmp_type_arg_1);
        if (tmp_metaclass_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        goto condexpr_end_2;
        condexpr_false_2:;
        tmp_metaclass_name_1 = (PyObject *)&PyType_Type;
        Py_INCREF(tmp_metaclass_name_1);
        condexpr_end_2:;
        condexpr_end_1:;
        CHECK_OBJECT(tmp_class_creation_1__bases);
        tmp_bases_name_1 = tmp_class_creation_1__bases;
        tmp_assign_source_15 = SELECT_METACLASS(tmp_metaclass_name_1, tmp_bases_name_1);
        Py_DECREF(tmp_metaclass_name_1);
        if (tmp_assign_source_15 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        assert(tmp_class_creation_1__metaclass == NULL);
        tmp_class_creation_1__metaclass = tmp_assign_source_15;
    }
    {
        nuitka_bool tmp_condition_result_3;
        PyObject *tmp_key_name_3;
        PyObject *tmp_dict_name_3;
        tmp_key_name_3 = const_str_plain_metaclass;
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_dict_name_3 = tmp_class_creation_1__class_decl_dict;
        tmp_res = PyDict_Contains(tmp_dict_name_3, tmp_key_name_3);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_condition_result_3 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_3 == NUITKA_BOOL_TRUE) {
            goto branch_yes_1;
        } else {
            goto branch_no_1;
        }
    }
    branch_yes_1:;
    CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
    tmp_dictdel_dict = tmp_class_creation_1__class_decl_dict;
    tmp_dictdel_key = const_str_plain_metaclass;
    tmp_result = DICT_REMOVE_ITEM(tmp_dictdel_dict, tmp_dictdel_key);
    if (tmp_result == false) {
        assert(ERROR_OCCURRED());

        FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


        exception_lineno = 20;

        goto try_except_handler_1;
    }
    branch_no_1:;
    {
        nuitka_bool tmp_condition_result_4;
        PyObject *tmp_expression_name_2;
        CHECK_OBJECT(tmp_class_creation_1__metaclass);
        tmp_expression_name_2 = tmp_class_creation_1__metaclass;
        tmp_res = PyObject_HasAttr(tmp_expression_name_2, const_str_plain___prepare__);
        tmp_condition_result_4 = (tmp_res != 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_4 == NUITKA_BOOL_TRUE) {
            goto branch_yes_2;
        } else {
            goto branch_no_2;
        }
    }
    branch_yes_2:;
    {
        PyObject *tmp_assign_source_16;
        PyObject *tmp_called_name_1;
        PyObject *tmp_expression_name_3;
        PyObject *tmp_args_name_1;
        PyObject *tmp_tuple_element_1;
        PyObject *tmp_kw_name_1;
        CHECK_OBJECT(tmp_class_creation_1__metaclass);
        tmp_expression_name_3 = tmp_class_creation_1__metaclass;
        tmp_called_name_1 = LOOKUP_ATTRIBUTE(tmp_expression_name_3, const_str_plain___prepare__);
        if (tmp_called_name_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_tuple_element_1 = const_str_plain_Spotify;
        tmp_args_name_1 = PyTuple_New(2);
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_name_1, 0, tmp_tuple_element_1);
        CHECK_OBJECT(tmp_class_creation_1__bases);
        tmp_tuple_element_1 = tmp_class_creation_1__bases;
        Py_INCREF(tmp_tuple_element_1);
        PyTuple_SET_ITEM(tmp_args_name_1, 1, tmp_tuple_element_1);
        CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
        tmp_kw_name_1 = tmp_class_creation_1__class_decl_dict;
        frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 20;
        tmp_assign_source_16 = CALL_FUNCTION(tmp_called_name_1, tmp_args_name_1, tmp_kw_name_1);
        Py_DECREF(tmp_called_name_1);
        Py_DECREF(tmp_args_name_1);
        if (tmp_assign_source_16 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        assert(tmp_class_creation_1__prepared == NULL);
        tmp_class_creation_1__prepared = tmp_assign_source_16;
    }
    {
        nuitka_bool tmp_condition_result_5;
        PyObject *tmp_operand_name_1;
        PyObject *tmp_expression_name_4;
        CHECK_OBJECT(tmp_class_creation_1__prepared);
        tmp_expression_name_4 = tmp_class_creation_1__prepared;
        tmp_res = PyObject_HasAttr(tmp_expression_name_4, const_str_plain___getitem__);
        tmp_operand_name_1 = (tmp_res != 0) ? Py_True : Py_False;
        tmp_res = CHECK_IF_TRUE(tmp_operand_name_1);
        if (tmp_res == -1) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_condition_result_5 = (tmp_res == 0) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
        if (tmp_condition_result_5 == NUITKA_BOOL_TRUE) {
            goto branch_yes_3;
        } else {
            goto branch_no_3;
        }
    }
    branch_yes_3:;
    {
        PyObject *tmp_raise_type_1;
        PyObject *tmp_raise_value_1;
        PyObject *tmp_left_name_1;
        PyObject *tmp_right_name_1;
        PyObject *tmp_tuple_element_2;
        PyObject *tmp_getattr_target_1;
        PyObject *tmp_getattr_attr_1;
        PyObject *tmp_getattr_default_1;
        PyObject *tmp_expression_name_5;
        PyObject *tmp_type_arg_2;
        tmp_raise_type_1 = PyExc_TypeError;
        tmp_left_name_1 = const_str_digest_75fd71b1edada749c2ef7ac810062295;
        CHECK_OBJECT(tmp_class_creation_1__metaclass);
        tmp_getattr_target_1 = tmp_class_creation_1__metaclass;
        tmp_getattr_attr_1 = const_str_plain___name__;
        tmp_getattr_default_1 = const_str_angle_metaclass;
        tmp_tuple_element_2 = BUILTIN_GETATTR(tmp_getattr_target_1, tmp_getattr_attr_1, tmp_getattr_default_1);
        if (tmp_tuple_element_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        tmp_right_name_1 = PyTuple_New(2);
        PyTuple_SET_ITEM(tmp_right_name_1, 0, tmp_tuple_element_2);
        CHECK_OBJECT(tmp_class_creation_1__prepared);
        tmp_type_arg_2 = tmp_class_creation_1__prepared;
        tmp_expression_name_5 = BUILTIN_TYPE1(tmp_type_arg_2);
        assert(!(tmp_expression_name_5 == NULL));
        tmp_tuple_element_2 = LOOKUP_ATTRIBUTE(tmp_expression_name_5, const_str_plain___name__);
        Py_DECREF(tmp_expression_name_5);
        if (tmp_tuple_element_2 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
            Py_DECREF(tmp_right_name_1);

            exception_lineno = 20;

            goto try_except_handler_1;
        }
        PyTuple_SET_ITEM(tmp_right_name_1, 1, tmp_tuple_element_2);
        tmp_raise_value_1 = BINARY_OPERATION_MOD_OBJECT_UNICODE_TUPLE(tmp_left_name_1, tmp_right_name_1);
        Py_DECREF(tmp_right_name_1);
        if (tmp_raise_value_1 == NULL) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_1;
        }
        exception_type = tmp_raise_type_1;
        Py_INCREF(tmp_raise_type_1);
        exception_value = tmp_raise_value_1;
        exception_lineno = 20;
        RAISE_EXCEPTION_IMPLICIT(&exception_type, &exception_value, &exception_tb);

        goto try_except_handler_1;
    }
    branch_no_3:;
    goto branch_end_2;
    branch_no_2:;
    {
        PyObject *tmp_assign_source_17;
        tmp_assign_source_17 = PyDict_New();
        assert(tmp_class_creation_1__prepared == NULL);
        tmp_class_creation_1__prepared = tmp_assign_source_17;
    }
    branch_end_2:;
    {
        PyObject *tmp_assign_source_18;
        {
            PyObject *tmp_set_locals_1;
            CHECK_OBJECT(tmp_class_creation_1__prepared);
            tmp_set_locals_1 = tmp_class_creation_1__prepared;
            locals_spotipy$client_20 = tmp_set_locals_1;
            Py_INCREF(tmp_set_locals_1);
        }
        // Tried code:
        // Tried code:
        tmp_dictset_value = const_str_digest_453d9a13f190051d0fb607026b4faf41;
        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain___module__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_3;
        }
        tmp_dictset_value = const_str_digest_bd0f2b232e10978ffc7d0f9d3001ad87;
        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain___doc__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_3;
        }
        tmp_dictset_value = const_str_plain_Spotify;
        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain___qualname__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_3;
        }
        if (isFrameUnusable(cache_frame_624df6905d3bc9676105aeac478b5f31_2)) {
            Py_XDECREF(cache_frame_624df6905d3bc9676105aeac478b5f31_2);

#if _DEBUG_REFCOUNTS
            if (cache_frame_624df6905d3bc9676105aeac478b5f31_2 == NULL) {
                count_active_frame_cache_instances += 1;
            } else {
                count_released_frame_cache_instances += 1;
            }
            count_allocated_frame_cache_instances += 1;
#endif
            cache_frame_624df6905d3bc9676105aeac478b5f31_2 = MAKE_FUNCTION_FRAME(codeobj_624df6905d3bc9676105aeac478b5f31, module_spotipy$client, sizeof(void *));
#if _DEBUG_REFCOUNTS
        } else {
            count_hit_frame_cache_instances += 1;
#endif
        }
        assert(cache_frame_624df6905d3bc9676105aeac478b5f31_2->m_type_description == NULL);
        frame_624df6905d3bc9676105aeac478b5f31_2 = cache_frame_624df6905d3bc9676105aeac478b5f31_2;

        // Push the new frame as the currently active one.
        pushFrameStack(frame_624df6905d3bc9676105aeac478b5f31_2);

        // Mark the frame object as in use, ref count 1 will be up for reuse.
        assert(Py_REFCNT(frame_624df6905d3bc9676105aeac478b5f31_2) == 2); // Frame stack

        // Framed code:
        tmp_dictset_value = const_int_pos_3;
        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_max_retries, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 35;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = const_tuple_int_pos_429_int_pos_500_int_pos_502_int_pos_503_int_pos_504_tuple;
        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_default_retry_codes, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 36;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_1;
            PyObject *tmp_tuple_element_3;
            tmp_tuple_element_3 = Py_None;
            tmp_defaults_1 = PyTuple_New(11);
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 0, tmp_tuple_element_3);
            tmp_tuple_element_3 = Py_True;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 1, tmp_tuple_element_3);
            tmp_tuple_element_3 = Py_None;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 2, tmp_tuple_element_3);
            tmp_tuple_element_3 = Py_None;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 3, tmp_tuple_element_3);
            tmp_tuple_element_3 = Py_None;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 4, tmp_tuple_element_3);
            tmp_tuple_element_3 = Py_None;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 5, tmp_tuple_element_3);
            tmp_tuple_element_3 = const_int_pos_5;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 6, tmp_tuple_element_3);
            tmp_tuple_element_3 = Py_None;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 7, tmp_tuple_element_3);
            tmp_tuple_element_3 = PyObject_GetItem(locals_spotipy$client_20, const_str_plain_max_retries);

            if (tmp_tuple_element_3 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {
                Py_DECREF(tmp_defaults_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 16900 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 48;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_tuple_element_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_defaults_1);

                exception_lineno = 48;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            PyTuple_SET_ITEM(tmp_defaults_1, 8, tmp_tuple_element_3);
            tmp_tuple_element_3 = PyObject_GetItem(locals_spotipy$client_20, const_str_plain_max_retries);

            if (tmp_tuple_element_3 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {
                Py_DECREF(tmp_defaults_1);
                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 16900 ], 33, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_tuple_element_3 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);
                Py_DECREF(tmp_defaults_1);

                exception_lineno = 49;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            PyTuple_SET_ITEM(tmp_defaults_1, 9, tmp_tuple_element_3);
            tmp_tuple_element_3 = const_float_0_3;
            Py_INCREF(tmp_tuple_element_3);
            PyTuple_SET_ITEM(tmp_defaults_1, 10, tmp_tuple_element_3);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_1___init__(tmp_defaults_1);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain___init__, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 38;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_2_set_auth();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_set_auth, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 103;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            nuitka_bool tmp_condition_result_6;
            PyObject *tmp_called_name_2;
            PyObject *tmp_args_element_name_1;
            PyObject *tmp_called_name_3;
            PyObject *tmp_args_element_name_2;
            tmp_res = MAPPING_HAS_ITEM(locals_spotipy$client_20, const_str_plain_property);

            if (tmp_res == -1) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 106;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_condition_result_6 = (tmp_res == 1) ? NUITKA_BOOL_TRUE : NUITKA_BOOL_FALSE;
            if (tmp_condition_result_6 == NUITKA_BOOL_TRUE) {
                goto condexpr_true_3;
            } else {
                goto condexpr_false_3;
            }
            condexpr_true_3:;
            tmp_called_name_2 = PyObject_GetItem(locals_spotipy$client_20, const_str_plain_property);

            if (tmp_called_name_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 1016 ], 30, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 106;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_name_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 106;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_1 = MAKE_FUNCTION_spotipy$client$$$function_3_auth_manager();



            frame_624df6905d3bc9676105aeac478b5f31_2->m_frame.f_lineno = 106;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_2, tmp_args_element_name_1);
            Py_DECREF(tmp_called_name_2);
            Py_DECREF(tmp_args_element_name_1);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 106;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            goto condexpr_end_3;
            condexpr_false_3:;
            tmp_called_name_3 = (PyObject *)&PyProperty_Type;
            tmp_args_element_name_2 = MAKE_FUNCTION_spotipy$client$$$function_3_auth_manager();



            frame_624df6905d3bc9676105aeac478b5f31_2->m_frame.f_lineno = 106;
            tmp_dictset_value = CALL_FUNCTION_WITH_SINGLE_ARG(tmp_called_name_3, tmp_args_element_name_2);
            Py_DECREF(tmp_args_element_name_2);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 106;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            condexpr_end_3:;
            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_auth_manager, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 106;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_called_instance_2;
            PyObject *tmp_args_element_name_3;
            tmp_called_instance_2 = PyObject_GetItem(locals_spotipy$client_20, const_str_plain_auth_manager);

            if (tmp_called_instance_2 == NULL && CHECK_AND_CLEAR_KEY_ERROR_OCCURRED()) {

                exception_type = PyExc_NameError;
                Py_INCREF(exception_type);
                exception_value = UNSTREAM_STRING(&constant_bin[ 16933 ], 34, 0);
                exception_tb = NULL;
                NORMALIZE_EXCEPTION(&exception_type, &exception_value, &exception_tb);
                CHAIN_EXCEPTION(exception_value);

                exception_lineno = 110;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }

            if (tmp_called_instance_2 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 110;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_args_element_name_3 = MAKE_FUNCTION_spotipy$client$$$function_4_auth_manager();



            frame_624df6905d3bc9676105aeac478b5f31_2->m_frame.f_lineno = 110;
            {
                PyObject *call_args[] = {tmp_args_element_name_3};
                tmp_dictset_value = CALL_METHOD_WITH_ARGS1(tmp_called_instance_2, const_str_plain_setter, call_args);
            }

            Py_DECREF(tmp_called_instance_2);
            Py_DECREF(tmp_args_element_name_3);
            if (tmp_dictset_value == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 110;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_auth_manager, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 110;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_5___del__();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain___del__, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 119;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_6__build_session();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__build_session, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 124;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_7__auth_headers();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__auth_headers, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 138;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_8__internal_call();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__internal_call, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 147;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_2;
            tmp_defaults_2 = const_tuple_none_none_tuple;
            Py_INCREF(tmp_defaults_2);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_9__get(tmp_defaults_2);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__get, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 203;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_3;
            tmp_defaults_3 = const_tuple_none_none_tuple;
            Py_INCREF(tmp_defaults_3);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_10__post(tmp_defaults_3);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__post, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 209;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_4;
            tmp_defaults_4 = const_tuple_none_none_tuple;
            Py_INCREF(tmp_defaults_4);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_11__delete(tmp_defaults_4);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__delete, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 214;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_5;
            tmp_defaults_5 = const_tuple_none_none_tuple;
            Py_INCREF(tmp_defaults_5);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_12__put(tmp_defaults_5);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__put, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 219;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_13_next();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_next, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 224;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_14_previous();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_previous, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 235;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_15_track();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_track, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 246;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_6;
            tmp_defaults_6 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_6);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_16_tracks(tmp_defaults_6);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 256;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_17_artist();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_artist, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 267;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_18_artists();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_artists, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 277;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_7;
            tmp_defaults_7 = const_tuple_none_none_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_7);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_19_artist_albums(tmp_defaults_7);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_artist_albums, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 287;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_8;
            tmp_defaults_8 = const_tuple_str_plain_US_tuple;
            Py_INCREF(tmp_defaults_8);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_20_artist_top_tracks(tmp_defaults_8);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_artist_top_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 309;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_21_artist_related_artists();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_artist_related_artists, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 321;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_22_album();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_album, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 332;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_9;
            tmp_defaults_9 = const_tuple_int_pos_50_int_0_tuple;
            Py_INCREF(tmp_defaults_9);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_23_album_tracks(tmp_defaults_9);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_album_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 342;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_24_albums();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_albums, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 356;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_10;
            tmp_defaults_10 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_10);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_25_show(tmp_defaults_10);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_show, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 366;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_11;
            tmp_defaults_11 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_11);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_26_shows(tmp_defaults_11);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_shows, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 381;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_12;
            tmp_defaults_12 = const_tuple_int_pos_50_int_0_none_tuple;
            Py_INCREF(tmp_defaults_12);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_27_show_episodes(tmp_defaults_12);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_show_episodes, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 396;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_13;
            tmp_defaults_13 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_13);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_28_episode(tmp_defaults_13);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_episode, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 415;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_14;
            tmp_defaults_14 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_14);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_29_episodes(tmp_defaults_14);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_episodes, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 430;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_15;
            tmp_defaults_15 = const_tuple_int_pos_10_int_0_str_plain_track_none_tuple;
            Py_INCREF(tmp_defaults_15);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_30_search(tmp_defaults_15);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_search, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 445;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_31_user();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 462;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_16;
            tmp_defaults_16 = const_tuple_int_pos_50_int_0_tuple;
            Py_INCREF(tmp_defaults_16);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_32_current_user_playlists(tmp_defaults_16);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_playlists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 470;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_17;
            tmp_defaults_17 = const_tuple_none_none_tuple_str_plain_track_tuple_tuple;
            Py_INCREF(tmp_defaults_17);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_33_playlist(tmp_defaults_17);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_playlist, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 478;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_18;
            tmp_defaults_18 = const_tuple_none_int_pos_100_int_0_none_tuple_str_plain_track_tuple_tuple;
            Py_INCREF(tmp_defaults_18);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_34_playlist_tracks(tmp_defaults_18);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_playlist_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 497;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_35_playlist_cover_image();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_playlist_cover_image, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 527;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_36_playlist_upload_cover_image();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_playlist_upload_cover_image, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 536;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_19;
            tmp_defaults_19 = const_tuple_none_none_none_tuple;
            Py_INCREF(tmp_defaults_19);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_37_user_playlist(tmp_defaults_19);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 551;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_20;
            tmp_defaults_20 = const_tuple_none_none_none_int_pos_100_int_0_none_tuple;
            Py_INCREF(tmp_defaults_20);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_38_user_playlist_tracks(tmp_defaults_20);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 568;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_21;
            tmp_defaults_21 = const_tuple_int_pos_50_int_0_tuple;
            Py_INCREF(tmp_defaults_21);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_39_user_playlists(tmp_defaults_21);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 600;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_22;
            tmp_defaults_22 = const_tuple_true_str_empty_tuple;
            Py_INCREF(tmp_defaults_22);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_40_user_playlist_create(tmp_defaults_22);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_create, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 612;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_23;
            tmp_defaults_23 = const_tuple_none_none_none_none_tuple;
            Py_INCREF(tmp_defaults_23);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_41_user_playlist_change_details(tmp_defaults_23);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_change_details, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 625;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_42_user_playlist_unfollow();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_unfollow, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 658;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_24;
            tmp_defaults_24 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_24);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_43_user_playlist_add_tracks(tmp_defaults_24);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_add_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 669;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_44_user_playlist_replace_tracks();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_replace_tracks, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 688;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_25;
            tmp_defaults_25 = const_tuple_int_pos_1_none_tuple;
            Py_INCREF(tmp_defaults_25);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_45_user_playlist_reorder_tracks(tmp_defaults_25);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_reorder_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 703;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_26;
            tmp_defaults_26 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_26);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_46_user_playlist_remove_all_occurrences_of_tracks(tmp_defaults_26);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_digest_4b32f198f6de09ec1a43edf661b1c6e4, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 736;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_27;
            tmp_defaults_27 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_27);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_47_user_playlist_remove_specific_occurrences_of_tracks(tmp_defaults_27);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_digest_f3bd18c4e4dfe3b238c61f74d4197ffd, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 758;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_48_user_playlist_follow_playlist();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_follow_playlist, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 790;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_49_user_playlist_is_following();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_playlist_is_following, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 805;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_50_me();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_me, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 823;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_51_current_user();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 829;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_52_current_user_playing_track();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_playing_track, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 835;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_28;
            tmp_defaults_28 = const_tuple_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_28);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_53_current_user_saved_tracks(tmp_defaults_28);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 840;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_29;
            tmp_defaults_29 = const_tuple_int_pos_20_none_tuple;
            Py_INCREF(tmp_defaults_29);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_54_current_user_followed_artists(tmp_defaults_29);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_followed_artists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 851;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_30;
            tmp_defaults_30 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_30);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_55_current_user_saved_tracks_delete(tmp_defaults_30);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_tracks_delete, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 864;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_31;
            tmp_defaults_31 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_31);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_56_current_user_saved_tracks_contains(tmp_defaults_31);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_tracks_contains, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 876;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_32;
            tmp_defaults_32 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_32);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_57_current_user_saved_tracks_add(tmp_defaults_32);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_tracks_add, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 888;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_33;
            tmp_defaults_33 = const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple;
            Py_INCREF(tmp_defaults_33);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_58_current_user_top_artists(tmp_defaults_33);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_top_artists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 900;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_34;
            tmp_defaults_34 = const_tuple_int_pos_20_int_0_str_plain_medium_term_tuple;
            Py_INCREF(tmp_defaults_34);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_59_current_user_top_tracks(tmp_defaults_34);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_top_tracks, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 915;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_35;
            tmp_defaults_35 = const_tuple_int_pos_50_none_none_tuple;
            Py_INCREF(tmp_defaults_35);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_60_current_user_recently_played(tmp_defaults_35);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_recently_played, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 930;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_36;
            tmp_defaults_36 = const_tuple_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_36);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_61_current_user_saved_albums(tmp_defaults_36);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_albums, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 949;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_37;
            PyObject *tmp_tuple_element_4;
            tmp_tuple_element_4 = PyList_New(0);
            tmp_defaults_37 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_37, 0, tmp_tuple_element_4);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_62_current_user_saved_albums_contains(tmp_defaults_37);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_albums_contains, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 960;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_38;
            PyObject *tmp_tuple_element_5;
            tmp_tuple_element_5 = PyList_New(0);
            tmp_defaults_38 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_38, 0, tmp_tuple_element_5);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_63_current_user_saved_albums_add(tmp_defaults_38);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_albums_add, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 970;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_39;
            PyObject *tmp_tuple_element_6;
            tmp_tuple_element_6 = PyList_New(0);
            tmp_defaults_39 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_39, 0, tmp_tuple_element_6);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_64_current_user_saved_albums_delete(tmp_defaults_39);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_albums_delete, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 979;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_40;
            tmp_defaults_40 = const_tuple_int_pos_50_int_0_tuple;
            Py_INCREF(tmp_defaults_40);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_65_current_user_saved_shows(tmp_defaults_40);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_shows, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 989;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_41;
            PyObject *tmp_tuple_element_7;
            tmp_tuple_element_7 = PyList_New(0);
            tmp_defaults_41 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_41, 0, tmp_tuple_element_7);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_66_current_user_saved_shows_contains(tmp_defaults_41);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_shows_contains, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1000;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_42;
            PyObject *tmp_tuple_element_8;
            tmp_tuple_element_8 = PyList_New(0);
            tmp_defaults_42 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_42, 0, tmp_tuple_element_8);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_67_current_user_saved_shows_add(tmp_defaults_42);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_shows_add, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1010;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_43;
            PyObject *tmp_tuple_element_9;
            tmp_tuple_element_9 = PyList_New(0);
            tmp_defaults_43 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_43, 0, tmp_tuple_element_9);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_68_current_user_saved_shows_delete(tmp_defaults_43);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_user_saved_shows_delete, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1019;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_44;
            PyObject *tmp_tuple_element_10;
            tmp_tuple_element_10 = PyList_New(0);
            tmp_defaults_44 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_44, 0, tmp_tuple_element_10);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_69_user_follow_artists(tmp_defaults_44);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_follow_artists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1029;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_45;
            PyObject *tmp_tuple_element_11;
            tmp_tuple_element_11 = PyList_New(0);
            tmp_defaults_45 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_45, 0, tmp_tuple_element_11);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_70_user_follow_users(tmp_defaults_45);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_follow_users, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1036;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_46;
            PyObject *tmp_tuple_element_12;
            tmp_tuple_element_12 = PyList_New(0);
            tmp_defaults_46 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_46, 0, tmp_tuple_element_12);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_71_user_unfollow_artists(tmp_defaults_46);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_unfollow_artists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1043;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_47;
            PyObject *tmp_tuple_element_13;
            tmp_tuple_element_13 = PyList_New(0);
            tmp_defaults_47 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_47, 0, tmp_tuple_element_13);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_72_user_unfollow_users(tmp_defaults_47);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_user_unfollow_users, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1050;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_48;
            tmp_defaults_48 = const_tuple_none_none_none_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_48);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_73_featured_playlists(tmp_defaults_48);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_featured_playlists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1057;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_49;
            tmp_defaults_49 = const_tuple_none_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_49);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_74_new_releases(tmp_defaults_49);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_new_releases, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1090;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_50;
            tmp_defaults_50 = const_tuple_none_none_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_50);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_75_categories(tmp_defaults_50);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_categories, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1107;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_51;
            tmp_defaults_51 = const_tuple_none_none_int_pos_20_int_0_tuple;
            Py_INCREF(tmp_defaults_51);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_76_category_playlists(tmp_defaults_51);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_category_playlists, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1131;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_52;
            tmp_defaults_52 = const_tuple_none_none_none_int_pos_20_none_tuple;
            Py_INCREF(tmp_defaults_52);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_77_recommendations(tmp_defaults_52);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_recommendations, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1155;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_78_recommendation_genre_seeds();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_recommendation_genre_seeds, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1221;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_79_audio_analysis();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_audio_analysis, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1226;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_53;
            PyObject *tmp_tuple_element_14;
            tmp_tuple_element_14 = PyList_New(0);
            tmp_defaults_53 = PyTuple_New(1);
            PyTuple_SET_ITEM(tmp_defaults_53, 0, tmp_tuple_element_14);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_80_audio_features(tmp_defaults_53);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_audio_features, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1234;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_81_devices();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_devices, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1252;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        {
            PyObject *tmp_defaults_54;
            tmp_defaults_54 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_54);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_82_current_playback(tmp_defaults_54);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_current_playback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1257;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_55;
            tmp_defaults_55 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_55);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_83_currently_playing(tmp_defaults_55);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_currently_playing, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1265;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_56;
            tmp_defaults_56 = const_tuple_true_tuple;
            Py_INCREF(tmp_defaults_56);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_84_transfer_playback(tmp_defaults_56);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_transfer_playback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1273;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_57;
            tmp_defaults_57 = const_tuple_none_none_none_none_none_tuple;
            Py_INCREF(tmp_defaults_57);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_85_start_playback(tmp_defaults_57);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_start_playback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1286;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_58;
            tmp_defaults_58 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_58);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_86_pause_playback(tmp_defaults_58);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_pause_playback, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1329;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_59;
            tmp_defaults_59 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_59);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_87_next_track(tmp_defaults_59);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_next_track, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1337;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_60;
            tmp_defaults_60 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_60);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_88_previous_track(tmp_defaults_60);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_previous_track, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1345;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_61;
            tmp_defaults_61 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_61);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_89_seek_track(tmp_defaults_61);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_seek_track, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1355;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_62;
            tmp_defaults_62 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_62);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_90_repeat(tmp_defaults_62);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_repeat, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1371;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_63;
            tmp_defaults_63 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_63);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_91_volume(tmp_defaults_63);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_volume, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1387;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_64;
            tmp_defaults_64 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_64);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_92_shuffle(tmp_defaults_64);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_shuffle, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1407;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        {
            PyObject *tmp_defaults_65;
            tmp_defaults_65 = const_tuple_none_tuple;
            Py_INCREF(tmp_defaults_65);
            tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_93_add_to_queue(tmp_defaults_65);



            tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain_add_to_queue, tmp_dictset_value);
            Py_DECREF(tmp_dictset_value);
            if (tmp_res != 0) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 1424;
                type_description_2 = "o";
                goto frame_exception_exit_2;
            }
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_94__append_device_id();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__append_device_id, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1448;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_95__get_id();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__get_id, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1461;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }
        tmp_dictset_value = MAKE_FUNCTION_spotipy$client$$$function_96__get_uri();



        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain__get_uri, tmp_dictset_value);
        Py_DECREF(tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 1477;
            type_description_2 = "o";
            goto frame_exception_exit_2;
        }

#if 0
        RESTORE_FRAME_EXCEPTION(frame_624df6905d3bc9676105aeac478b5f31_2);
#endif

        // Put the previous frame back on top.
        popFrameStack();

        goto frame_no_exception_1;

        frame_exception_exit_2:;

#if 0
        RESTORE_FRAME_EXCEPTION(frame_624df6905d3bc9676105aeac478b5f31_2);
#endif

        if (exception_tb == NULL) {
            exception_tb = MAKE_TRACEBACK(frame_624df6905d3bc9676105aeac478b5f31_2, exception_lineno);
        } else if (exception_tb->tb_frame != &frame_624df6905d3bc9676105aeac478b5f31_2->m_frame) {
            exception_tb = ADD_TRACEBACK(exception_tb, frame_624df6905d3bc9676105aeac478b5f31_2, exception_lineno);
        }

        // Attachs locals to frame if any.
        Nuitka_Frame_AttachLocals(
            frame_624df6905d3bc9676105aeac478b5f31_2,
            type_description_2,
            outline_0_var___class__
        );


        // Release cached frame.
        if (frame_624df6905d3bc9676105aeac478b5f31_2 == cache_frame_624df6905d3bc9676105aeac478b5f31_2) {
#if _DEBUG_REFCOUNTS
            count_active_frame_cache_instances -= 1;
            count_released_frame_cache_instances += 1;
#endif

            Py_DECREF(frame_624df6905d3bc9676105aeac478b5f31_2);
        }
        cache_frame_624df6905d3bc9676105aeac478b5f31_2 = NULL;

        assertFrameObject(frame_624df6905d3bc9676105aeac478b5f31_2);

        // Put the previous frame back on top.
        popFrameStack();

        // Return the error.
        goto nested_frame_exit_1;

        frame_no_exception_1:;
        goto skip_nested_handling_1;
        nested_frame_exit_1:;

        goto try_except_handler_3;
        skip_nested_handling_1:;
        {
            nuitka_bool tmp_condition_result_7;
            PyObject *tmp_compexpr_left_1;
            PyObject *tmp_compexpr_right_1;
            CHECK_OBJECT(tmp_class_creation_1__bases);
            tmp_compexpr_left_1 = tmp_class_creation_1__bases;
            tmp_compexpr_right_1 = const_tuple_type_object_tuple;
            tmp_condition_result_7 = RICH_COMPARE_NE_NBOOL_OBJECT_TUPLE(tmp_compexpr_left_1, tmp_compexpr_right_1);
            if (tmp_condition_result_7 == NUITKA_BOOL_EXCEPTION) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 20;

                goto try_except_handler_3;
            }
            if (tmp_condition_result_7 == NUITKA_BOOL_TRUE) {
                goto branch_yes_4;
            } else {
                goto branch_no_4;
            }
        }
        branch_yes_4:;
        tmp_dictset_value = const_tuple_type_object_tuple;
        tmp_res = PyObject_SetItem(locals_spotipy$client_20, const_str_plain___orig_bases__, tmp_dictset_value);
        if (tmp_res != 0) {
            assert(ERROR_OCCURRED());

            FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


            exception_lineno = 20;

            goto try_except_handler_3;
        }
        branch_no_4:;
        {
            PyObject *tmp_assign_source_19;
            PyObject *tmp_called_name_4;
            PyObject *tmp_args_name_2;
            PyObject *tmp_tuple_element_15;
            PyObject *tmp_kw_name_2;
            CHECK_OBJECT(tmp_class_creation_1__metaclass);
            tmp_called_name_4 = tmp_class_creation_1__metaclass;
            tmp_tuple_element_15 = const_str_plain_Spotify;
            tmp_args_name_2 = PyTuple_New(3);
            Py_INCREF(tmp_tuple_element_15);
            PyTuple_SET_ITEM(tmp_args_name_2, 0, tmp_tuple_element_15);
            CHECK_OBJECT(tmp_class_creation_1__bases);
            tmp_tuple_element_15 = tmp_class_creation_1__bases;
            Py_INCREF(tmp_tuple_element_15);
            PyTuple_SET_ITEM(tmp_args_name_2, 1, tmp_tuple_element_15);
            tmp_tuple_element_15 = locals_spotipy$client_20;
            Py_INCREF(tmp_tuple_element_15);
            PyTuple_SET_ITEM(tmp_args_name_2, 2, tmp_tuple_element_15);
            CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
            tmp_kw_name_2 = tmp_class_creation_1__class_decl_dict;
            frame_73c68707901485c856bd6798b6ebb929->m_frame.f_lineno = 20;
            tmp_assign_source_19 = CALL_FUNCTION(tmp_called_name_4, tmp_args_name_2, tmp_kw_name_2);
            Py_DECREF(tmp_args_name_2);
            if (tmp_assign_source_19 == NULL) {
                assert(ERROR_OCCURRED());

                FETCH_ERROR_OCCURRED(&exception_type, &exception_value, &exception_tb);


                exception_lineno = 20;

                goto try_except_handler_3;
            }
            assert(outline_0_var___class__ == NULL);
            outline_0_var___class__ = tmp_assign_source_19;
        }
        CHECK_OBJECT(outline_0_var___class__);
        tmp_assign_source_18 = outline_0_var___class__;
        Py_INCREF(tmp_assign_source_18);
        goto try_return_handler_3;
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_3:;
        Py_DECREF(locals_spotipy$client_20);
        locals_spotipy$client_20 = NULL;
        goto try_return_handler_2;
        // Exception handler code:
        try_except_handler_3:;
        exception_keeper_type_1 = exception_type;
        exception_keeper_value_1 = exception_value;
        exception_keeper_tb_1 = exception_tb;
        exception_keeper_lineno_1 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        Py_DECREF(locals_spotipy$client_20);
        locals_spotipy$client_20 = NULL;
        // Re-raise.
        exception_type = exception_keeper_type_1;
        exception_value = exception_keeper_value_1;
        exception_tb = exception_keeper_tb_1;
        exception_lineno = exception_keeper_lineno_1;

        goto try_except_handler_2;
        // End of try:
        NUITKA_CANNOT_GET_HERE("tried codes exits in all cases");
        return NULL;
        // Return handler code:
        try_return_handler_2:;
        CHECK_OBJECT(outline_0_var___class__);
        Py_DECREF(outline_0_var___class__);
        outline_0_var___class__ = NULL;

        goto outline_result_1;
        // Exception handler code:
        try_except_handler_2:;
        exception_keeper_type_2 = exception_type;
        exception_keeper_value_2 = exception_value;
        exception_keeper_tb_2 = exception_tb;
        exception_keeper_lineno_2 = exception_lineno;
        exception_type = NULL;
        exception_value = NULL;
        exception_tb = NULL;
        exception_lineno = 0;

        // Re-raise.
        exception_type = exception_keeper_type_2;
        exception_value = exception_keeper_value_2;
        exception_tb = exception_keeper_tb_2;
        exception_lineno = exception_keeper_lineno_2;

        goto outline_exception_1;
        // End of try:
        NUITKA_CANNOT_GET_HERE("Return statement must have exited already.");
        return NULL;
        outline_exception_1:;
        exception_lineno = 20;
        goto try_except_handler_1;
        outline_result_1:;
        UPDATE_STRING_DICT1(moduledict_spotipy$client, (Nuitka_StringObject *)const_str_plain_Spotify, tmp_assign_source_18);
    }
    goto try_end_1;
    // Exception handler code:
    try_except_handler_1:;
    exception_keeper_type_3 = exception_type;
    exception_keeper_value_3 = exception_value;
    exception_keeper_tb_3 = exception_tb;
    exception_keeper_lineno_3 = exception_lineno;
    exception_type = NULL;
    exception_value = NULL;
    exception_tb = NULL;
    exception_lineno = 0;

    Py_XDECREF(tmp_class_creation_1__bases);
    tmp_class_creation_1__bases = NULL;

    Py_XDECREF(tmp_class_creation_1__class_decl_dict);
    tmp_class_creation_1__class_decl_dict = NULL;

    Py_XDECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    Py_XDECREF(tmp_class_creation_1__prepared);
    tmp_class_creation_1__prepared = NULL;

    // Re-raise.
    exception_type = exception_keeper_type_3;
    exception_value = exception_keeper_value_3;
    exception_tb = exception_keeper_tb_3;
    exception_lineno = exception_keeper_lineno_3;

    goto frame_exception_exit_1;
    // End of try:
    try_end_1:;

    // Restore frame exception if necessary.
#if 0
    RESTORE_FRAME_EXCEPTION(frame_73c68707901485c856bd6798b6ebb929);
#endif
    popFrameStack();

    assertFrameObject(frame_73c68707901485c856bd6798b6ebb929);

    goto frame_no_exception_2;

    frame_exception_exit_1:;
#if 0
    RESTORE_FRAME_EXCEPTION(frame_73c68707901485c856bd6798b6ebb929);
#endif

    if (exception_tb == NULL) {
        exception_tb = MAKE_TRACEBACK(frame_73c68707901485c856bd6798b6ebb929, exception_lineno);
    } else if (exception_tb->tb_frame != &frame_73c68707901485c856bd6798b6ebb929->m_frame) {
        exception_tb = ADD_TRACEBACK(exception_tb, frame_73c68707901485c856bd6798b6ebb929, exception_lineno);
    }

    // Put the previous frame back on top.
    popFrameStack();

    // Return the error.
    goto module_exception_exit;

    frame_no_exception_2:;
    CHECK_OBJECT(tmp_class_creation_1__bases);
    Py_DECREF(tmp_class_creation_1__bases);
    tmp_class_creation_1__bases = NULL;

    CHECK_OBJECT(tmp_class_creation_1__class_decl_dict);
    Py_DECREF(tmp_class_creation_1__class_decl_dict);
    tmp_class_creation_1__class_decl_dict = NULL;

    CHECK_OBJECT(tmp_class_creation_1__metaclass);
    Py_DECREF(tmp_class_creation_1__metaclass);
    tmp_class_creation_1__metaclass = NULL;

    CHECK_OBJECT(tmp_class_creation_1__prepared);
    Py_DECREF(tmp_class_creation_1__prepared);
    tmp_class_creation_1__prepared = NULL;


    return module_spotipy$client;
    module_exception_exit:
    RESTORE_ERROR_OCCURRED(exception_type, exception_value, exception_tb);
    return NULL;
}
